undefined
undefined says üëã ***Hey! ***

*Did we miss a channel for your favorite language? If there is enough demand, we'll make it happen. Until then, this channel is a good place for discussions on all other languages. :)*

Check out our rollups-examples repo https://github.com/cartesi/rollups-examples
undefined says my friend asked if there is any java support...
undefined says Hey @fabio.oshiro 
Currently we haven't ported the jvm to the cartesi machine. If you have an attractive app, we'll consider porting it.
undefined says and nodejs?
undefined says Nodejs is still unsupported but is in our medium term goals. However we have support for JavaScript, through another JS engine. Check the rollups-examples, there is an echo-js
undefined says Any behind the scenes work on getting Golang into the ctsi-machine.
undefined says We plan to run tests with Golang once we‚Äôve implemented the microarchitecture and other RISC-V extensions. We‚Äôll release an example as soon as we‚Äôre satisfied with its performance inside the Cartesi Machine.
undefined says Will it ever be possible to run springboot on a Cartesi?
undefined says Springboot is a Java-based framework. Anything in this direction could only be thought once we have JVM ported inside the Cartesi Machine.
undefined says Is that in the works?
undefined says Not really, but if you have some cool idea in mind or an open source Java library that makes sense to port to Cartesi Machine! We could possibly think of putting effort into it!
undefined says I'd be willing to contribute to the code as well. Let me think on this.
undefined says hi
undefined says Hey! üëã
undefined says Need some help? Any questions?
undefined says nice
undefined says gm
undefined says hu
undefined says my lua dapp works with lua 5.3, but not with lua 5.4. Some incompatibility with luasocket. I get the error below. Any idea @edubart ?
```
lua: /usr/share/lua/5.4/socket/http.lua:41: bad argument #1 to 'receive' (string expected, got light userdata)
stack traceback:
 [C]: in function 'socket.http.request'
 /opt/cartesi/dapp/dapp.lua:14: in local 'http_post'
 /opt/cartesi/dapp/dapp.lua:47: in main chunk
 [C]: in ?
```
undefined says Does @diego.nehab still give support for LuaSocket?  He created it üôÇ . LuaSocket was ported to Lua5.4 right? Any API changed in 5.4?
undefined says I think it's a bug that happens with 5.4.4 (which is the version for ubuntu 22.04. http://lua-users.org/lists/lua-l/2021-06/msg00101.html
undefined says https://github.com/lunarmodules/luasocket/issues/331
undefined says I see, looks like that is the problem, it was fixed in LuaSocket 3.1, but Ubuntu provides 3.0 üòï . I guess you will need to use LuaRocks after all to workaround this and install with `luarocks install --lua-version=5.4 luasocket`, have a C compiler, maybe use a multi-stage build, it's more painful.
undefined says Or stick with Lua5.3 .. Sadly
undefined says I think I'll stick with lua5.3. LuaRocks does not play nicely with lua5.4 either. Its ubuntu package is not updated to depend on lua5.4, so it's kind of a mess.
undefined says I mean, I'm sure I could make it work.
undefined says @diego.nehab any opinion on how should we recommend using Lua in rollups examples? With 5.3 or 5.4? With LuaRocks or Ubuntu packages? With luasocket or something else?
undefined says Sad that the Ubuntu package managers leave some part of the Lua 5.4 ecosystem broken in their packages.
undefined says @diego.nehab linked to this https://github.com/cartesi/machine-emulator/blob/14ad23327865adbc4d4d0761687ae4783feb4315/.github/workflows/Dockerfile#L13
Which is still using 5.3. Let's see what kind of problem will happen there. You have a working branch for 5.4, right?
undefined says Yes, I have a working branch that I ported machine-emulator to use Lua 5.4 already, and it works on Ubuntu/Debian, but this in x86_64 host.
undefined says I see you do, `feature/update-lua5.4`
And you have `lua5.4 liblua5.4-dev luarocks`
This `luarocks` will bring `lua5.1` with him.
undefined says But that is not a problem, just the default Lua that comes with it, luarocks is supposed to work and capable of installing packages for all Lua versions.
undefined says Yeah, I just need to do that on a build stage, to not mess with the runtime stage with two lua versions.
undefined says It works üëè
undefined says curious that the http agent is `LuaSocket 3.0.0`, not `LuaSocket 3.1.0`
undefined says variable was not updated.
undefined says https://github.com/lunarmodules/luasocket/issues/401
looks like to be another issue from LuaRocks
undefined says the maintainer forgot to bump in last release üòï
undefined says I don't. üôÇ
undefined says gm
undefined says gm!
undefined says merhabalar
undefined says Hi @Glowinthedark, this channel makes references to other programming languages. If you want to connect with Cartesi's Turkish community, please join us here https://t.me/CartesiTR and follow Cartesi Turkey on Twitter as well https://twitter.com/CartesiTurkiye. 

Also, if you are eager to build with Cartesi, you'll be pleased to know that in November, we'll be participating in ETHGlobal Istanbul, and we'd be happy to see you at the hackathon: https://ethglobal.com/events/istanbul
undefined says If you are interested, I can be a MOD for Turkish language accounts in your community.
undefined
undefined says üëã ***Hi, Python lovers!***

This channel is for all your needs. Ask questions about setting up, building or deploying Python DApps.

**Run a simple Python DApp**
Check our echo-python example: https://github.com/cartesi/rollups-examples/tree/main/echo-python

**Create your own custom DApp**
Get started with the template here: https://github.com/cartesi/rollups-examples/tree/main/custom-dapps

*Not sure where to begin your Cartesi Dev Journey? *
Head over to #üê£‚îÉbeginner-friendly channel to take your first step.
undefined says i want to use python to write a project like cmc and cg
undefined says anyone can help me or join me
undefined says and my target is the dapp can defeat both cmc and cg
undefined says Hey @Deleted User, might wanna share more about this in #üí°‚îÉideasÔºÜuse-cases channel! Let's then tag our developers here!
undefined says Hi guys, how can I find examples in Python for creating NFTs our Tokens in Python?
undefined says or* Tokens
undefined says Maybe you will find something here: https://docs.openzeppelin.com/contracts/2.x/erc721
undefined says O thank you very much!! I¬¥ll take a look!
undefined says Hey @Tony Garcia! To create Ethereum based assets(NFTs or Tokens), you'll have to work on the Smart Contract layer that @wch-dawid-m | webchefs shared. It requires you to have some Solidity knowledge.
Another path is to develop on Application layer and use these assets as per your DApp's logic. You can very well use Python here. We've an ERC-20 example for this purpose: https://github.com/cartesi/rollups-examples/tree/main/erc20
undefined says Thanks!!
undefined says Hi, team!

**Context**
We are trying to run a custom DApp written in Python

**What we tried**
We followed the tutorial on github (https://github.com/cartesi/rollups-examples/blob/main/custom-dapps/template/README.md) and made the following file (`house.py`)
undefined says (This message has house.py)
undefined says We then used one of the addresses displayed while running `docker compose up` and ran the frontend as follows: `yarn start input send --payload '{"lot" : 300000, "bed" : 3}' --dapp house --address 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f`
undefined says However, we were getting the following error:

```sh
connecting to http://localhost:8545
connected to chain 31337
using account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
sending "{"lot" : 300000, "bed" : 3}"
transaction: 0x66f7a93c86cb4bd8d2415c84d6748108faa5944f22628a0fc25a1c0313a13bb3
waiting for confirmation...
index.ts input send

Send string input to DApp

Options:
  --help          Show help                                          [boolean]
  --version       Show version number                                [boolean]
  --rpc           JSON-RPC provider URL
                                   [string] [default: "http://localhost:8545"]
  --mnemonic      Wallet mnemonic
   [string] [required] [default: "test test test test test test test test test
                                                              test test junk"]
  --accountIndex  Account index from mnemonic            [number] [default: 0]
  --dapp          DApp name                         [string] [default: "dapp"]
  --address       Rollups contract address                            [string]
  --addressFile   File with rollups contract address                  [string]
  --payload       Input payload to send                    [string] [required]

Error: InputAdded event not found in receipt of transaction 0x66f7a93c86cb4bd8d2415c84d6748108faa5944f22628a0fc25a1c0313a13bb3
    at getInputKeys (/home/vijay/Desktop/projects/hackathons/ethindia/rollups-examples/frontend-console/src/commands/input_commands/send.ts:59:15)
    at Object.handler (/home/vijay/Desktop/projects/hackathons/ethindia/rollups-examples/frontend-console/src/commands/input_commands/send.ts:106:35)
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
```
undefined says For your reference, the log of the docker compose command is as follows.
undefined says Can someone please help us resolve this issue? Thanks a lot üôÇ
undefined says Hey @Vijay Jaisankar ! This is running in host mode right? Does this work without adding --dapp or --address as options?
undefined says For local hardhat deployment you can drop the --dapp
undefined says Hi @Shaheen!

Thanks for the suggestion, here are the screenshots of the runs without `--dapp` and `--address`; the app still doesn't seem to work üò¶
undefined says and when both of them are added, this is the error we're getting.
undefined says @Vijay Jaisankar are you at ETH-India venue? If yes, please visit us at the booth!
undefined says I am currently not at the venue, can we please have a discord call?
undefined says As in, a VC
undefined says (or any other method of communication is also perfectly fine üôÇ )
undefined says Which network are you using? Host mode?
undefined says Local hardhat node?
undefined says Yes, I am using hardhat - I did **not** run it with the host mode docs i.e
```sh
python3 -m venv .venv
. .venv/bin/activate
pip install -r requirements.txt
ROLLUP_HTTP_SERVER_URL="http://127.0.0.1:5004" python3 house.py
```, as it was producing errors

So yes I think it is in local hardhat mode üôÇ
undefined says Locally, you always have a hardhat node spin up!
undefined says That could be used in host mode as well as local production mode!
undefined says Oh, okay, thanks for the clarification üôÇ
Sorry, I'm new to web3 and am a bit confused.

I think it is local hardhat mode as I did not run the script given in the host mode docs - what should I do next?
undefined says Internet connection is bad here. Let me try a call! Wait!
undefined says Sure thing üôÇ
undefined says Hey @Vijay Jaisankar , the parameters --dapp, --address, --addressFile serve the same purpose to get the address of the contracts tied to your dapp.
With --address you provide the address directly, --addressFile you provide the file with address and  --dapp you provide the name of the dapp, so the frontend console searches for the dapp address in deployments/<network>/<dapp>.address. And without any of these parameters  the frontend console searches for the dapp address in deployments/localhost/dapp.address

In your case, you used the custom DApp template to create the dapp and started the node there, so the address of your dapp should be in custom-dapps/house/deployments/localhost/dapp.address
You can either provide the address directly (with --address) or provide the address file path (with --addressFile).

Regarding the host mode, what errors did you get?
undefined says Hello guys,  I'm trying to use "yarn start input send --payload command inside a python code passing the value of a variable as payload using "os.system"  command but when I try to see the notices, only the variable name is published, not the content. Can someone please help me?
undefined says Could you share the code snippet where you generate notice? Are you building frontend app in Python?
undefined says Hello @Shaheen , thank you for your reply, this is a code snippet:  if aggregated_weights is not None:
            # Save aggregated_weights
            print(f"Saving round {rnd} aggregated_weights...")
            np.savez(f"round-{rnd}-weights.npz", *aggregated_weights)
            os.system("cd ..")
            os.system("yarn start input send --payload 'INSERT INTO ROUNDS VALUES (rnd, accuracy)'")
undefined says I pre-created this ROUNDS table using frontend, I'm running sqlite dapp. I imagine that it doesn't get the value of the variables because os.system runs outside the code, in the OS but I would like to know if there is anything that can be done.
undefined says Hello, @jpaulobg.
It looks like you aren't replacing the "rnd" and "accuracy" variables by their values in the command that goes to os.system.
Since this command is a string, you could build it before executing it:
```
os.system("cd ..")
cmd = f"yarn start input send --payload 'INSERT INTO ROUNDS VALUES ({rnd}, {accuracy})'"
os.system(cmd)
```
undefined says Hello @Arthur Vianna, I had already tried this solution before but unfortunately it didn't work either.
undefined says And it produced the same result (notices)?
If you have this code in a repository or remember the operations that you did, I could try to reproduce the issue.
undefined says Yes! In this specific case, it generates empty notices as the input data is not in the correct table format.  @Shaheen , any sugestion? Thank you!
undefined says Hey @jpaulobg we suggest you use `addInput` call to submit SQL query inputs to the backend. Here's a simple python example that you could give a try:
```
from web3 import Web3
import time
import json
‚Äã
RPC_URL = "http://localhost:8545"
ROLLUPS_ADDRESS = "../deployments/localhost/dapp.json"
ROLLUPS_ABIS_PATH = "../deployments/localhost/" 
INPUT_FACET_FILE = "InputFacet.json"
‚Äã
def main():
    web3 = Web3(Web3.HTTPProvider(RPC_URL))
‚Äã
    account = None
    
    while not account:
        try:
            account_index = input("Please enter the account index to use: ")
            account_index = int(account_index)
            account = web3.eth.accounts[account_index]
            print(f"Account (index {account_index}): {account}")
        except Exception as e:
            print(f"Error: {e}")
‚Äã
    address_file = open(ROLLUPS_ADDRESS,'r')
    json_address_file = json.load(address_file)
    rollups_address = json_address_file["address"]
    
    input_abi_file = open(ROLLUPS_ABIS_PATH+INPUT_FACET_FILE,'r')
    input_abi_json = json.load(input_abi_file)
    input_abi = input_abi_json["abi"]
    input_contract = web3.eth.contract(abi=input_abi, address=rollups_address)
    input_added_filter = input_contract.events.InputAdded.createFilter(fromBlock='latest')
‚Äã
    input_msg = "Hello world!"
    print("Sending input",input_msg)
    input_payload = "0x" + input_msg.encode("utf-8").hex()
‚Äã
    tx_parameters = {"from":account}
    tx_hash = input_contract.functions.addInput(input_payload).transact(tx_parameters)
‚Äã
    tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
    while not (new_entries := input_added_filter.get_new_entries()): time.sleep(1)
    tx_event = new_entries.pop()
    print(f"epoch {tx_event['args']['epochNumber']} - index {tx_event['args']['inputIndex']}")
‚Äã
main()
```
undefined says thanks @Shaheen, I ran the program with some modifications but I have a doubt, what is the account index? I tried a Ethereum address acount and received an error.
undefined says When you spin up Hardhat node, it creates multiple accounts for you. The account index is to simply select one from the list of accounts.
undefined says thank you, is it just a integer between 1 and 20?
undefined says Yes.
undefined says Should start from 0 though!
undefined says thanks @Shaheen, it worked and I saw the output using "yarn start notice list". So in this  case  is my application already a dapp? I inserted the code in my federated learning application.
undefined says Did you run the backend in host mode or production mode? And we'd love to know more about your DApp. If you wanna showcase to everyone what you're building, #üöÄ‚îÉcommunity-dapps is the channel!
undefined says hey @Shaheen, I am using in Production Mode but I want to deploy it in the public testnet Goerli.
undefined says @jpaulobg These steps should help you deploy https://github.com/cartesi/rollups-examples#deploying-dapps
undefined says thank you! In this case will I be using the smarts contracts from Cartesi in Solidity already deployed in the Goerli testnet?
undefined says True! These Solidity smart contracts are part of on-chain Rollups components. The development and deployment process abstracts it from developers so you can focus on the core logic of the DApp in language of your choice. But yeah, good to have its theoretical knowledge. For instance, whenever you call `addInput` method(as shared in Python code above), it is a JSON-RPC call to the Goerli smart contract function defined here https://github.com/cartesi/rollups/blob/main/onchain/rollups/contracts/facets/InputFacet.sol#L28
undefined says Wow! Really nice this parallel!
undefined says every time i try to run a yarn command i keep getting this error
undefined says anyone know how i can solve this issue
undefined says It should be working if you export your account's MNEMONIC and an RPC_URL correctly. It's not able to find the network, were you able to generate an RPC URL link from Alchemy or any other third party?
undefined says I realized that I hadn't downloaded python correctly and that caused this issue
undefined says I got it working now!
undefined says Aha! Good to hear that! Let us know if you face any other issues!
undefined says will do!
undefined says Hello @Shaheen, I saw a presentation about Cartesi  and in a slide is mentioned that packages Numpy and Scikit-learn were ported to Cartesi machine and I could¬¥t  do that.  Do you have any specific tip of how they managed to do that?
undefined says Hey @jpaulobg! I think @Felipe Grael can give us better tips on playing with huge python libraries.
undefined says Hey @jpaulobg! Indeed we can use most python libraries, including numpy and sklearn. Using the new build system based on docker, you can install it from the ubuntu repository or build it by yourself. The catch is that you need to either cross-compile it to riscv64 or build it inside the emulated docker container. The second option is easier, albeit quite slow...
undefined says Have a look on the README of this repository: https://github.com/prototyp3-dev/sentiment . There I go through the process of building numpy and scikit-learn wheels, and then use these to build the final Dapp container
undefined says Hey, @Felipe Grael , I managed to execute the steps in the respository, but for my application I am still receiving the following error when trying to build the image: #0 118.6   note: This error originates from a subprocess, and is likely not a problem with pip.
#0 118.6   ERROR: Failed building wheel for numpy
#0 118.6 Failed to build numpy
#0 118.6 ERROR: Could not build wheels for numpy, which is required to install pyproject.toml-based projects
Seems that albeit the webserver is running, docker is not accessing, it, and instead is trying to download a version from repository. is there anythong else I am missing?
undefined says Hello @Felipe Grael , I already solved the problem, it worked. Thank you!
undefined says Hi, may I know how you solved it? As i am facing similar issue now
undefined says I managed to install some module but not all
undefined says Hey all, I am having an issue getting the echo-python example on https://docs.cartesi.io/cartesi-rollups/build-dapps/run-dapp/ to run. Seeing the following after verifying all prereqs satisfied:
undefined says Using WSL2 Ubuntu
undefined says Nevermind, figured it out. WSL was being strange about following paths
undefined says https://techxplore.com/news/2023-08-scientists-open-source-tool-language-python.html

@Shaheen @Felipe Grael 
Have you considered this?
undefined says Hello everyone! I am wondering if anyone has experience running OpenCV inside a Cartesi Machine
undefined says I attempted to generate the compiled wheels for riscv, following the repository shared by @Felipe Grael  (https://github.com/prototyp3-dev/sentiment), but was unsuccessful.
undefined says could you show what errors you're hitting? perhaps using gist.github.com and pasting link here
undefined says This is the error message I am getting: https://gist.github.com/mmvazzano/67d7431aa4474f2a2346b96ba304483b
undefined says At a glance you need the OpenSSL development headers installed
undefined says I‚Äôm gonna make a wild guess here but try: 

docker run --rm -it -v $PWD:/opt/cartesi/dapp --platform=linux/riscv64 cartesi-python-builder:latest /bin/bash

apt-get update && apt-get install libssl-dev

pip wheel -r req.txt -w wheels
undefined says And see if it gets further
In theory, you can develop front-end ian any language including SwiftUI. The back-end logic however runs inside the Cartesi Machine, our VM based on RISC-V architecture. Hence, it is important to know that the language in question can be cross-compiled to RISC-V. It seems that it can be pulled off with Swift but not going to be an easy path!
undefined
undefined says Open community channel for questions, doubts and discussions focused on the Cartesi Machine.
undefined says whats the cartesi machine?
undefined says https://docs.cartesi.io/machine/intro/
undefined says idle curiousity, did anyone try cartesi machine as a bare metal target for let's say, embedded Rust? Linux kernel-less, that is
undefined says In the cartesi machine team, we often build freestanding RISC-V binaries (without the need of a kernel), to run tests of the RISC-V instruction set, though most tests are made in RISC-V assembly, some parts are in C. So it is certainly possible to use freestanding C, I bet Rust can be compiled to freestanding environment too. However when you are in freestanding environment, you don't have access to any driver, virtual memory, general purpose allocator, or all the goodies that kernel handles for you, if you can live without that features and re implement the rollups/yield drivers from scratch, it would be possible. You could maybe re-implement them by looking the documentation and our drives in the kernel sources.
undefined says Not bare metal, but I did experiment sometimes "distroless" dapp. That is, I still boot the Linux, but with a custom `init=/dapp`, where `/dapp` is the only and lone file in the filesystem for my dapp. I build it as a RISC-V binary in freestanding mode and use just syscalls to call the kernel drivers and print stuff to stdout. This way the dapp is compiled to a freestadling environment, that is, no libc or any library linked. However you still can perform kernel syscalls to use kernel provided features or access drives.
undefined says yeah should make a sample myself at some point, played a bit around with it for the MIPS/RISC-V-to-EVM transpiler I was working on (now a WASM to EVM); it's a nice way perhaps to lower the trusted computing base a lot
undefined says even though linux as part of TCB is considered relatively OK today üôÇ
undefined says Linux has an enormous code base, though most of it is disabled in the default cartesi machine config, we just enabled the features actually needed. So the attack surface is much lower when you compare with the Linux that comes with any distribution. Also I've seen in the past, by looking in Linux CVEs, that most vulnerabilities in the Linux seems like to come from vendor specific drivers, and they are all disabled.
undefined says But I bet you could even be more strict and disable more kernel configs, to minimize the attack surface further, and also enable some stricter security features like hardened Linux usually do, but all of them have cost in performance. You would need to provide a custom Linux kernel for your dapp, and that is doable.
undefined says @diego.nehab how does a 'dehashing device' look in 2023 out of curiousity? with uarch and so on involved - no major change?
undefined says The magic dehashing operation has to be performed by the uarch. So in a sense, it becomes a device that exists both at the big and small architecture level. When running the big machine, there is some mmio address that, when written to, triggers a dehashing operation. But that same address is mmio when running the small machine. Does it make sense? This is because, when the small machine is emulating the SD of the big machine to that mmio address, it has to trigger the dehashing  operation as well. So it gets into the step log.
undefined says think it makes sense, will try to draw it a bit - for things like replacing rollup memory input ranges it's seen more as separate execution-until-yield runs from state S to S+1?
undefined says There has been some discussion about offering a simplified version of the dehashing device just to allow for on-demand inputs, under the auspices of alternative ways to run arbitration for rollups. But I don‚Äôt see this happening anytime soon. I‚Äôd like to see the dehashing device soon, in its full glory, to enable blockchain introspection or even cross-chain state reads. Every now and then, somebody shows up with an App idea that would benefit from that.
undefined says There are several parts to this. One is the creation and construction of a key/value database of existing hash/data values reachable from the latest block header. Another is the implementation of the device in the big and small architectures. Another is the implementation of the same logic in the solidity step. Another is the driver and higher level APIs to consume this data. It seems as though the first and last steps could be implemented with some help from minigeth.
undefined says also been looking a bit at https://www.laconic.com/blog/how-laconic-network-uses-ipld 's approach in the past, it's kind of a derivation from parity's old eth->ipld stuff
undefined says Just to add another thing we have to figure out, is the size of the pre-images. If it‚Äôs too large, we won‚Äôt be able to perform onchain `step` since it could exceed the size of an Ethereum block. Furthermore, things like ERC-4844 may make this even harder to deal with. Bottom line; that‚Äôs an issue and I don‚Äôt have a clear fix in my head.

However, if we could generate a ZK proof that tells us the hash of a certain pre-image matches a merkle root hash of the same pre-image, I believe it would fix all issues.
undefined says Well, a bit of a roundabout way could be to settle into a one-step 200kb risczero proof which then itself is sent on chain and gets verified in a separate cartesi machine execution yielding the output state..
undefined says But I guess it becomes turtles all way down quickly
undefined says I‚Äôd be curious to see how long risc0 takes to generate a proof that a chunk of data has a certain keccak hash. I‚Äôd be especially curious to see if there are other practical limitations on how large the block can be.
undefined says well, they have accelerated sha256 which isn't too bad, but keccak comes later on i think
undefined says I don‚Äôt think it would be that difficult to do the hash incrementally. It was designed to be incremental anyway.
undefined says So you could create a Cartesi Machine, feed it chunks of data, and as a result it gives you both the Merkle tree root and the keccak of the data.
undefined says I think they are the same.
undefined says re perf, this was back in march of risczero perf if curious
undefined says roughly ~1 cycle per most risc-v instructions
undefined says This is looking a lot better than when we tried! Pretty cool.
undefined says Any idea of how much memory the program can use?
undefined says they are about to put out a release that allows 'continuations' as in separate a risc-v execution into multiple slices, but i think last i discussed this:

"For the upcoming v0.12 release, the stack is 16MB and the heap is 32MB."
undefined says it eats into the cycles as the input becomes hashed and so on naturally
undefined says oh and also interesting other tidbit: we managed to get cross-compiled c/c++ into risczero the other week, + zippie has an old uarch transpiled to rust somewhere
undefined says in case we want to play with this topic at some point
undefined says So, their best benchmark is 98 kHz in M2 Macbook, while I bet the cartesi machine could boot at 100+ MHz in M2, so cartesi is 1000x ahead? Not counting how much RAM.
undefined says Nice performance datasheet, I think the cartesi machine could benefit from having something like that eventually, to track performance progress
undefined says yeah 1000x to generate ZK sounds about right with current state of art - this is execution + proof generation tho, probably the risc-v trace is a lot quicker than the proof
undefined says (and proof part can be divided up based on slices of risc-v and done in parallel)
undefined says So is it possible to benchmark it without proof? It would be interesting to know how its RISC-V interpreter compares with Cartesi Machine RISC-V interpreter
undefined says I am biased, but I bet cartesi machine interpreter is faster, and there is still room for future optimizations in case we need to focus on this
undefined says yeah, they changed their API for this recently so can't tell you the exact way, we did it before, they run a pretty straightforward rv32im
undefined says Oh just rv32im, cartesi machine does a lot more than that, not fair to compare then.
undefined says my personal feeling is that for actual deterministic linux/system running there's pretty much nobody else that does it as well as cartesi
undefined says but there's certain areas where a cartesi (uarch or bigarch?)+risczero combo could make a lot of sense
undefined says It's also not a fair comparison with 1 core vs all cores, right?
undefined says There is another factor of 10 at least there.
undefined says Maybe 20.
undefined says You could be running 10 independent Dapps on the same hardware, each 1000x faster.
undefined says But I am positively impressed by the performance.
undefined says I'd like to know about the memory restrictions, if there are any.
undefined says Oh, I believe using risc0 inside Cartesi dapps is definitely a great use-case! Really using ZK for its zero-knowledge properties, instead of using it for rollups. I tried doing that (putting risc0‚Äôs verifier inside CM) for a hackathon with mixed results heh, @Carsten | Zippie even gave me some advice.

And I think the endgame for maximum performance is bare-metal. Don‚Äôt generate proofs at all (unless you need them), and don‚Äôt even pay the price of emulation; balls to the wall performance in rollups!
undefined says I am not much familiar with ZKP. But since you played with this, I have a question, if I want to use zero-knowledge properties inside Cartesi Machine, say for a decentralized identity dapp, where I want prove for the dapp that I am myself without reveling myself, is risc0 a good choice for this? Do we have other options?
undefined says Or more concrete example, decentralized voting, a dapp where I want to vote without revealing myself, therefore keeping my vote private. So using zero-knowledge properties inside a Cartesi dapp.
undefined says A while ago I was playing around with these ones:
https://github.com/iden3/snarkjs
https://github.com/enricobottazzi/ZKverse

They are pretty cool and explain step by step what is going on! Even with a good explanation, it still a very complex topic...but worth it to play around.
There was also some circuit generator that I saw once, but can't remember the link. It was something that would turn normal code into a circuit, which is what you'd need I think. 

Another very useful resource is this compilation:
https://github.com/matter-labs/awesome-zero-knowledge-proofs

Also, pretty sure there is an Ethereum project that does something similar with proofs of membership and also private votes...the name escaped me now but I'm sure @Gabriel Coutinho de Paula remembers it üôÇ
undefined says I‚Äôd favor risc0, for many many reasons. Now, please take everything I say with a grain of salt, my research wasn‚Äôt super thorough, and things change very fast. And I‚Äôm sure @Carsten | Zippie knows more about risc0 than I do!

I‚Äôll list a few reasons why I favor risc0, and something I worry about.

* Their team is pretty solid and is delivering improvements on the regular.
* Their verifier is in Rust nowadays I believe, so easy to put on CM. I believe many other projects rely on a Solidity implementation of their verifier, since the goal is blockchain first.
* Their prover is (as far as I know) open source and distributed under a permissive license. I‚Äôm not sure this has changed, and if they‚Äôve promised to remain this way. I remember there were talks about possibly releasing a hardware-accelerated version under a different license. In any case, other projects prover generally are not permissive at all, as far as being closed source.
* Great programmability. Since it‚Äôs RISC-V, we can really code our programs in Rust. Other projects it‚Äôs usually something weird like janky DSLs like Cairo, or even directly building circuits. For example, I remember there was a Cairo implementation of EDSA for signature verification. For risc0, I could just import standard Rust implementations of ECDSA.
* STARK, so no trusted setup needed. Maybe this isn‚Äôt such a big issue.

Now, I worry about proof size. I remember they weren‚Äôt so small, and blockspace is a very limited resource.
undefined says https://blog.pantherprotocol.io/zk-snarks-vs-zk-starks-differences-in-zero-knowledge-technologies/
undefined says might be outdated, but this is what I usually check when I need to think of STARK vs SNARK, cause I always forget the details haha
undefined says I was searching for that now! The name escapes me unfortunately. I think maybe periscope? Or maybe that was the Twitter thing haha, don‚Äôt remember.

But yeah, I tried to re-implement that with risc0 inside CM. Don‚Äôt know if it made sense though haha, but it did came out fast and simple. I don‚Äôt believe that project in Solidity was that simple. I hit on issues related to building their verifier to our rv (nowadays should be trivial, since I believe they rewrote it in Rust and we have more extensions). And issues related to proof size.
undefined says You might be thinking of sismo ( https://docs.sismo.io/ ) or Personae labs ( https://twitter.com/personae_labs )? Personae is helping build out anon forum for Noun holders: https://twitter.com/HeyAnoun
undefined says Now they do delayed release of new features (recursion for example) so there's 'early access program', but most development happens in open. GPU accel is public now.
undefined says Proof size is irritating and so is the lack of a evm based verifier.
undefined says It was Semaphore! @felipeargento
undefined says @edubart https://wasmer.io/posts/announcing-wasix
undefined says > WASIX is ready today for the community to build awesome apps and complete their runtimes: supporting threads, Berkeley sockets, forking and many more things that have been available for almost all the life of POSIX.
Wow cool, even `fork()` support? @diego.nehab 
This further opens the possibility of what I said to package the emulator, or really maybe even other cartesi components into portable .wasm binaries, that are able to run on any system, with mostly the same behavior. I like that WASM + WASI makes the dream of shipping a single binary to be supported on Linux, Windows, MacOS, or anything that WASI runtime is available viable, usually paying the price of something like ~20% performance hit when you have JIT or AOT compilation.
undefined says Their interactive page at https://wasmer.sh/
Is also very cool, I want to experiment doing a page like this for the Cartesi Machine someday, where people could play with a full Linux being emulated directly in the web browser with the cartesi machine, just to show off
undefined says @edubart could we do anything fun with a risczero proof being proved in browser setting (i got a PoC of that working the other week) and a cartesi machine-in-browser?
undefined says I am not much familiar with risczero, so not sure what we could do with it and cartesi machine in the context of a web-browser.
undefined says sure, just in general generate ZK execution proofs that's easy to evaluate inside a cartesi machine; inside a browser
undefined says If we get the cartesi machine to run in a browser, we also get Linux and anything that can run on Linux in the browser. But have in mind that running Linux in browser is nothing new, this have been done before a dozen times, in projects like TinyEMU, WebVM, and others. WebVM even has networking support. Nevertheless I think yet-another Linux in the browser with Cartesi Machine is cool to show off.
undefined says true
undefined says Btw readme.md still says ‚ÄòThe emulator implements RISC-V's RV64IMASU ISA‚Äô
undefined says @edubart is TLBConfig and providing a file for it a mandatory machine config element? Looks a lot like it in grpc and jsonrpc but wondered - and what should be the contents of such file?

context, we're making a default machine config here: https://github.com/cartesi/machine-manager/blob/2e2f1d1380765d9e8cde081afedbb70ddbb3f594/tests/demo-machine-manager-client/src/main.rs#L23
undefined says For boot, it's not mandatory. But if you have saved a snapshot of the machine and try to load later, you need to always provide TLB config otherwise its state will be lost and won't function properly, and of course to preserve the machine root hash.
undefined says so should really be optional in here: https://github.com/cartesi/grpc-interfaces/blob/develop/cartesi-machine.proto#L270 / https://github.com/cartesi/machine-emulator/blob/develop/src/jsonrpc-discover.json#L1583 ?
undefined says i guess the command line tools and such kinda bypass this as we save a machine there
undefined says ugh, moment, wrong urls..
undefined says https://github.com/cartesi/grpc-interfaces/blob/main/cartesi-machine.proto#L270 and https://github.com/cartesi/machine-emulator/blob/main/src/jsonrpc-discover.json#L1583
undefined says Indeed, could be optional, like other fields we mark as optional in `struct machine_config` (rollups and ram image filename), but are not optional in grpc or jsonrpc interfaces. CC @diego.nehab
undefined says Ugly, but you could workaround by grabbing `.bin` image for TLB memory range for any snapshot dump at cycle 0.
undefined says would be fine for the moment to work around it with a PMA_SHADOW_TLB_LENGTH empty file?
undefined says ah, or that
undefined says The `.bin` of TLB are not all 0 on init, unfortunately, it has an unspecified formatting and values on initialization.
undefined says at MachineRequest state tho?
undefined says as in, not from a saved state but fresh from scratch machine
undefined says I say unspecified because its length/value is an implementation detail that we may change if the TLB changes in the future.
undefined says ah yeah
undefined says ok, so some kind of test helper that gets that .bin generated with the emulator then
undefined says As in `cartesi-machine --store=dump --max-mcycle=0` and then grab the `dump/0000000000020000-6000.bin` file.
undefined says thanks, @Liza | Zippie this gets you a file that we can use as tlbconfig filename; you'll take it forward from there?
undefined says @edubart i'll file a ticket on machine-emulator on the optionality thing?
undefined says Not sure I understand the issue here. The default machine config should be obtained from the machine itself.
undefined says Isn't there a `machine::get_default_config`?
undefined says Then you fill out whatever you want.
undefined says This is for languages that do not have access to the C++ constructor for `machine_config`.
undefined says Oh true, there is that, yet the get default config won't save `.bin` file for the TLB
undefined says @diego.nehab not in grpc/jsonrpc protocol at least, or some 'create a default machine'
undefined says There is a get_default_config in jsonrpc.
undefined says it's not a 'real' issue for us in machine-manager but there is at least a call that makes a config and instantiates a machine with it
undefined says ah, yes there is, my bad
undefined says What is the scenario in which the TLB is a problem?
undefined says and so there is grpc
undefined says Yea, also in grpc.
undefined says i'll have to look at what the tlbconfig is set to there tho
undefined says It will probably be set to empty.
undefined says And the machine initialization figures out what to do about that on its own.
undefined says Why do you care, is my question, I guess. üôÇ
undefined says Oh true, you could just leave the image filename empty, like "", I am little slow this morning
undefined says machine-manager test cases that configures a runtime config from client side which now seems a bit wrong üòÇ
undefined says @Liza | Zippie ok, new plan: try to leave the image filename empty
undefined says ideally we use GetDefaultConfig tho and change that
undefined says I forgot for a brief moment that we use empty filenames as optionals
undefined says If they are starting the machine from a machine_config, just leave the field empty.
undefined says The field is important internally, when loading a machine that was stored into a directory.
undefined says Then the config will contain the name of a file whose contents is the internal TLB format you shouldn't have to care about.
undefined says There is an internal `get_serialization_config` which, called at any point in the execution, would give you that config. But again, unless you are being creative, no need to mess with that.
undefined says what was the reason post emulator 0.11+ for the 'range of flash drive X must use at most 56 bits to be addressable' thing, where we have to move away from 1<<63 and onwards positioned drives?
undefined says In short, because the RISC-V spec says so, that is, virtual memory translation can only translate to 56-bit physical address space:
> The Sv39 and Sv48 page-based virtual-memory schemes described in Sections 4.4 and 4.5 support
> a 56-bit physical address space
We made a thorough review of the RISC-V spec, and this went missing.
We also updated RISC-V privileged spec to 1.12, and started handling some new bits in page table entries and found that any physical address space using more than 56-bits would overflow into these new bits and cause serious issues in the emulator and kernel, so this was also a bug fix.
undefined says alright, that makes a lot of sense - i thought it was somehow hypervisor or virtualization related for some reason. Thank you!
undefined says studying uarch machine-emulator part a bit.. uarch-machine-state-access is basically a "HAL" for the big emulator? as in, how the big emulator code accesses the machine's memory and other bits; and because we're practically inside our big memory's memory image, we can basically just read 'real' memory?
undefined says very early proof of concept: big emulator built  in uarch fashion compiled into rv32im and running inside a risczero ZKVM guest; next up want to map up memory accesses to an external memory access list to get around 64-bit vs 32-bit pointers issue (and actually backing it with a 'physical memory') 

[yes that's a cartesi machine emulator inside a ZK proof]
undefined says Why would you run  Cartesi machine inside risc zero? Is it so you can run native code without changing within zk?
undefined says well, there surely are some use-cases around being possibly able to run full Linux-API computation in ZK, especially if you can store the proofs of what happened before some point
undefined says Would it remove the need for a fraud proof of the Cartesi vm?
undefined says i don't personally think fraud proofs will go away any time soon because the ZK proof generation is still super heavy, but it might be another very useful thing in the toolbox
undefined says So then why add the overhead of zk on top?
undefined says General computation is already possible and fraud proven, what is the purpose of zkvm on top?
undefined says all about expressability to me, plus there -might- be interesting bits where we can do let's say, a few computation cycles running on confidential data, for example
undefined says Personally I‚Äôd love if risc zero team wrote up plans for parallel trace proving, to create economies of scale.. if zkvm can be broken up and merklized like how polygon zkEVM is doing it, the overhead of zk can be minimized and actually cheaper
undefined says you saw their continuations stuff?
undefined says Ah ok so zk for private data in the same program.. no I reached out the that girl who got hired on Twitter on their team, she‚Äôs in Seattle I think but she never replied back so that‚Äôs the last I looked at risc zero
undefined says Tldr?
undefined says https://www.risczero.com/blog/continuations
undefined says tl;dr slice execution up in pieces and prove them separately
undefined says without having to care about the slice points as a coder
undefined says There you go
undefined says Was waiting for that, it‚Äôs a good direction and will minimize the overhead long term.. I think 3-5 years still before zk catches up
undefined says So can you not just run zkvm along side Cartesi vm and include the proof inside the vm which is verified inside it (again fraud proven as well)
undefined says This way you get the confidentiality and seperate the execution environments?
undefined says well you have to remember the fraud proof requires 1 honest node to really work, i.e. it's a narrowing down point of disagreement between a claimer and a disputer; but that doesn't mean you can't ZK prove that 'for some duration of blockchain history nobody successfully disputed'
undefined says but still requires the disputer(s) to have access to same state of machine
undefined says either way, i'm just messing around with this because even in it's most expensive proving, there can be usecases to being able to stuff a whole linux machine or part of it's execution into a ZK proof
undefined says for fast transaction stuff probably still some way to go üôÇ
undefined says Ok so for pseudo instant confirmation within the state transition time
undefined says Without bond perhaps
undefined says Aslong as you use DA on layer 1 I think the witness data can be all derived
undefined says Pls keep me in loop, interesting line of research and thx for the link
undefined says sure, this is all public goods work i'm doing
undefined says at least what i really like is that now ZK is now possible to develop in without having to think about execution steps/constraints/etc at first; and then optimize your way down to feasibility with proper profiling information
undefined says so you can do 'stupid' things like stuffing a real linux VM inside it and understand how it could be made practical
undefined says versus the mode of 'i'm inside this tiny arduino and need to always fit or i don't have anything working to demonstrate'
undefined says Yup.. I mean you don‚Äôt need fraud prover if you have zk of it but the provers are still inefficient.. but I get you
undefined says Wonder if risc zero applies stark/snark recursion optimization like plonky2
undefined says probably a topic for their discord; but yeah they have (early access program) recursion
undefined says Now with segments maybe it makes sense
undefined says in general just happy to see verified computation get bigger and bigger topic, ideal place for cartesi too
undefined says I think it has a part to play in ai alignment technically
undefined says Hi all, sorry for noob question. But would like to ask how can i install/build multiple binaries inside the dockerfile. Thanks
undefined says I have existing dockerfile ready for arm64, but the dockerfile base that i am using is ubuntu, instead of the single language such as python/js.
undefined says Thanks for advice
undefined says @LeongKH so you want to add in python or node js and so on into your ubuntu docker image basically?
undefined says Yep
undefined says In addition, i wanna install app like blender
undefined says basically what you need is RUN apt-get update && apt-get install <package names>
undefined says inside the dockerfile
undefined says if it's packaged for ubuntu
undefined says I can do it in my existing arm64 system
undefined says this is for rollup?
undefined says I wanna replicate the dockerfile for rollup. I have done it in AWS lambda
undefined says ok, bit out of my depth here but i'm sure some of the rollup team guys have some ideas üôÇ
undefined says @Stephen Chen so https://github.com/cartesi/machine-solidity-step/blob/3d066f6fcc7437638c52bc51f57be29cb01321e3/test/UArchReplay.t.sol#L117 takes proofs in style of coming out of cartesi machine and turns them into IAccessLogs.Context metastep style proofs?
undefined says @diego.nehab any particular reason there's no snapshot/rollback in the new jsonrpc interface?
undefined says I believe it has been replaced in favor of fork! But I‚Äôd wait for his reply haha.
undefined says Hey üëã I was reading the Cartesi whitepaper and I was wondering where I could find more documentation on this DAG scripting language they introduce
undefined says It is implemented on top of the new "fork".
undefined says This was planned but the demand for it was never there to justify the implementation. Can you explain your use case for the feature?
undefined says @Carlo
undefined says üëã
undefined says Thanks @Max @Carlo
undefined says Hi all, i am trying to work on dockerfile that i generated from the template, but it seems i couldnt pass the simple docker syntax

`docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl --load`
undefined says below is the error message, any help will be appreciated
undefined says is there anything that missed out from my installation?
undefined says Make sure you have qemu installed on your machine to emulate riscv
In Ubuntu you can install with:
```
apt install qemu-user-static
```
undefined says Thanks for the tip, it solves the exec format error. 
However, i am having difficulty to install scipy and some other python modules, do you have idea how to overcome this? Thanks in advance.
undefined says If you try to install with pip it will download the sources and build, so you should have compilers and a prepared environment for it.
But you can install the binaries from the distro:
```
apt install -y --no-install-recommends python3-numpy python3-scipy
```
If it doesn't find the package you can redefine the python path variable: 
```export PYTHONPATH=PYTHONPATH:/usr/local/lib/python3.10/:/usr/lib/python3/dist-packages/```
undefined says Ok, this is helpful, another dummy question, may i know how do i see the info that i log in the python script?
undefined says These the the container ids after compose, but none of these give me the log that i added in the python script
undefined says It should be the container running the image ```cartesi/dapp:<name>-devel-server```, (probably cartesi/dapp:pg-devel-server)
It will have the server manager logs and also the logs you printed on your dapp.
You can check with 
```
docker logs -f <container>
```
undefined says hmm, surprisingly, i couldnt find the log in the server. Is there special setting needed?
undefined says And also how do i clean the cache of previous logs. Thanks
undefined says No special setting. You can print some debug messages to check the overall logic.
To clean the cache and previous logs, you should remove the containers and volumes. If you are running an example from rollups-example you can run:

```
docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml down -v
```
If you are running a custom dapp you can run (just check the location of the yml files)
```
docker compose -f docker-compose.yml -f docker-compose.override.yml down -v
```
Optionally you can list the containers and volumes and remove them with

```
docker ps -a
docker rm <container1> <container2> ...
docker volume ls
docker volume rm <volume1> <volume2> ...
```
undefined says Question

Do the NODES run DOCKER IMAGE ( the cartesi smart contracts ) of the DAPP and act as the server of DAPPs ?

Or... Do they only verify the STATE of the cartesi emulator, which is being run by the DAPP's own server ?
undefined says You have to build a docker image to deploy the backend of the dapp that essentially runs inside the Cartesi machine in production. This kinda acts like your backend server however, the data source and verification game(in case of dispute) still runs on the underlying base chain/L1. In other words,  the cartesi node(running your backend server) will read inputs from the blockchain and submit outputs back to the base chain.
undefined says Hope that answers the question!
undefined says So.... There's a common Cartesi machine for all the DAPPs ?
undefined says All the DAPP images will run on the same machine ?
undefined says No, each dapp has its own cartesi machine, that's what makes cartesi rollups application-specific. Here's a good article to dive in https://medium.com/cartesi/application-specific-rollups-e12ed5d9de01
undefined says And... Who runs the machine ? 

The node runners ? Or... The dapp sends machine logs to mode to verify ?
undefined says In theory, it is a set of validators who run the node. Not sure if you're thinking the cartesi machine and your dapp backend running on separate nodes, rather your backend is packaged to run inside the machine so it's the same node. Any state changes to the machine are recorded on-chain by the node.
undefined says Just need a little more clarity about Cartesi Machine vs Compute SDK.

As of now, Cartesi is geared towards using Cartesi Machine and not the Compute SDK , right? 

Is it right to say that as of v0.9,  Compute SDK is obsolete?
undefined says Cartesi Machine is a core product (a VM) used by two products: Compute SDK and Rollups SDK.
Compute SDK is being updated to use the latest version of the Cartesi Machine.
undefined says Alright.  What exactly does the command "cartesi-machine" do?

I was following the Hello World Machine and saw that command in this context:

docker run \
  --rm cartesi/playground:0.5.0 cartesi-machine \
    --append-rom-bootargs="single=yes" \
    -- $'echo Hello World!'
undefined says Take a look at this!
https://docs.cartesi.io/machine/host/cmdline/
undefined says @mpolitzer does genext2fs have a 4gb fs size limit / u32?
undefined says No. It should revision 1 of ext2 where file size is 64bits.
lower 32 bits on `i_size` and higher 32 bits on `i_dir_acl`.

ref: https://www.nongnu.org/ext2-doc/ext2.html#i-size
undefined says Hmm, ok, I‚Äôll dig a bit more
undefined says Can you give a bit more details on what is happening?
undefined says was doing SOURCE_DATE_EPOCH=1689943775 genext2fs -N 1638400 -f -d /replicate/release -b 8388608 /replicate/image.ext2

and hit:

genext2fs: Internal error, block out of range
undefined says was fine at 2097152
undefined says this being cartesi/genext2fs v1.5.2 fwiw
undefined says You may want to experiment with different block sizes for larger filesystems
undefined says alright
undefined says Here are some limits based on block size: https://www.nongnu.org/ext2-doc/ext2.html#def-blocks
undefined says I usually recommend using 4096 bytes for block size, because that will match the kernel page cache size, and TLB entry size. But what is the default block size of genext2fs?
undefined says think 1024
undefined says Would be a good idea to make 4096 the default in our patched genext2fs ?
undefined says or at least a honorable mention in README maybe
undefined says I think so. We care more about speed than size overhead.
Did you measure the speedup?
undefined says does the whole pmem thing bring any speedups btw? or just properly away from mtd semantics
undefined says (for example, being able to use partitions of a 'flash drive')
undefined says Yes, there was about ~20% cycle less usage for reading/writing files in some benchmarks I made
undefined says In theory it should be faster, but I did not measure or confirm
undefined says I just had a look at the code and it looks like you ran out of blocks.
Can you try out the automatic block calculation to check if this value is correct.
Something like `SOURCE_DATE_EPOCH=1689943775 genext2fs -N 1638400 -f -d /replicate/release -r +1% /replicate/image.ext2` Should work.
You can then check your actual block usage with: `e2freefrag $IMG | grep 'Total blocks'` - `e2freefrag $IMG | grep 'Free blocks'`
undefined says yep will queue that for tomorrow
undefined says Hey @Machine Ref Unit sharing here a draft article that @felipeargento and I wrote.  We'd welcome any review, comment, and feedback from anyone inclined to take a read.  (There's also a very high-level comparison to EVM+ and WASM projects that we'd like to make sure is fair and accurate.)  Feel free to have a look if you'd like!

https://docs.google.com/document/d/1D9HBVdobIS9REluPZRCogoqWJ0FGeiYqZ2De-GA0MkQ/edit
undefined says cc @Diego @Augusto @Carsten | Zippie
undefined says probably a stupid question, but, could i theoretically have a real risc-v board with hypervisor extension run a VM and end up in same memory state as same initial VM inside a cartesi machine with hypervisor extension? I presume timers are a nightmare
undefined says didn't see anything completely outrageous here
undefined says Great text, congrats. Just two small comments:
- I believe even the WASM platforms still make "instruction-based metering", see WASMER. So in a sense they are following the same dynamics of "shared block space" as the EVM.
- The point is not only that it would take decades to rebuild the current software infrastructure. The problem is that this is a moving target and after rewriting 10000 libraries in Solidity, there would be one million new ones.
undefined says An interesting discussion of WASM vs RISC-V vs eBPF vs custom VM in context of smart contracts that happened on Polkadot forum.
https://forum.polkadot.network/t/exploring-alternatives-to-wasm-for-smart-contracts/2434
There are some interesting insights there that might be worth reading and add. The author made a good write up and even benchmark the options. cc @Augusto @felipeargento
undefined says I am aware that the emulator unit has recently been working on various benchmarks. Is there a document or location where these analyses have been compiled or summarized?
undefined says We often run benchmarks internally on specific things we are working on, but it's not much useful for others to see. Last time we presented benchmarks for others to see in a nice chart was in a slide of December internal updates, in this screenshot.
But that was for SDK 0.12 vs 0.13, since then SDK 0.14 and 0.15 was released, so it is outdated. For instance I know Linux Boot is taking ~0.3 seconds instead of ~1.1 seconds. We have a task to provide benchmarks more often in the future. @alexmikhalevich made these benchmarks
undefined says Super interesting discussion! Thanks for the tag @edubart !

About the benchmarks, these improvements would be nice as stand-alone updates to share on socials too...Linux Boot going from 1.1seconds to ~0.3 seconds is definitely a feel-good nugget of information haha
undefined says Indeed, I was also thinking on possible ways to share this kind of information to a broader technical audience in the industry.
undefined says Try Cartesi Machine from the latest SDK in interactive mode in your browser page:
https://cartesi-machine.surge.sh/
I got the Cartesi Machine to compile to WASM in a cleaner way this week,  then I hacked this this morning. Works on Google Chrome.
undefined says Very cool! Some cool use cases popping
undefined says works in Safari as well
undefined says I cannot get it to work on Firefox yet, dunno why
undefined says yeah, doesn't start in my firefox
undefined says in the sunodo web deployment procedure I was thinking about fetching the machine from IPFS (which works in the browser using a JS ipfs library), and then executing the machine in the browser to calculate its hash. Do you think it's easy to do that?
undefined says It is possible, just kind slow, I did compute machine root hash in WASM, it took a minute for a 64MB machine.
undefined says yeah, don't know either how it would be to download a gigabyte machine in browser's memory space
undefined says may be peanuts compared to chrome's core memory üòÜ
undefined says 
undefined says I shared this in #‚ú®‚îÉspotlight
undefined says `cartesi-term.js` is generated from where?
undefined says Works on my iPhone:
undefined says @edubart hitting "Uncaught ReferenceError: SharedArrayBuffer is not defined" on latest Brave and Chrome
undefined says Started a thread.
undefined says @edubart something more over in zkCartesi or JIT, but you ever saw https://twitter.com/snfernandez/status/1383394958317551616 ? pre-compiles a bunch of 'gadgets' for very common operations to emulate
undefined says I have discussed something very similar a few times before with the machine team and @diego.nehab , we call this just tracing. The idea is to first make a cache of decoded instructions from hot traces, often called trace cache, then to execute the instructions handlers chained by calling and returning from these "gadgets", which really are just each instruction implementation. We have an issue for it in <https://github.com/cartesi/machine-emulator/issues/48>, though the issue says nothing about chaining yet.
It is something we want to explore in the future, I often say the emulator is 40x slower than native for single-threaded non-SIMD code, I *think* this idea has potential to make the emulator below 10x magnitude, and yet there is no need to use a JIT, everything is pre-compiled. But making this is a huge effort, and will require a huge rewrite in our interpreter, hopefully one day we will tackle this.
This idea is not new, it was described in 2008 by the Bochs x86 emulator author, in <http://emulators.com/docs/nx25_nostradamus.htm>
undefined says how are you guys best handling 'uninitialized urandom read (8 bytes read)' and getrandom blocking these days on cartesi machine software images?
undefined says rndaddentropy used to be it but with non-buildroot i'm not as sure
undefined says Started a thread.
undefined says Amazing! Do you have any thoughts about bare metal execution, using the lambda machine and leveraging good compilers?
undefined says I have biased opinions about on how to approach bare-metal execution, but I don't want spark a long conversation or generate noise üôÇ
undefined says @edubart since you were down in the machine room, how difficult is it if i wanted to utilize another hash function for all the merkleization like let's say poseidon or other STARK/ZK friendly stuff? (got this question when talking to someone about my ZK demo)? "one" place to change, or many? (ignoring one-step using keccak for the moment)
undefined says Actually @diego.nehab experimented using KangaorooTwelve instead of Keccak yesterday, so in his commit you can get and idea of what files you should change https://github.com/cartesi/machine-emulator/commit/2c2997bddae1d86319c28e4e8a34871722b71d46 , you basically need to implement a class like `xkcp_kangarootwelve_hasher` from this commit, and rename a few lines to use it.
undefined says cool, had some good discussions with one of the Tip5 hash authors as well
undefined says Ping me if you need any help.
undefined says watf
undefined says crazy lol
undefined says @edubart if you ever want to try would be curious to see how we build for https://wasix.org/
undefined says WASIX is cool because it adds `fork()` support, TTY support, and other goodies. But the cartesi machine library can be compiled to pure WASI (just tested now), the only benefit of using WASIX would be TTY support for interactive terminals. The libcartesi library does not need `fork()`, this is used only in `remote-cartesi-machine`.
undefined says yeah thinking maybe threading if we wanted to calculate state hashes maybe
undefined says is there a way currently in between calculations of state hashes, on jsonrpc level, to get a list of 'dirty' pages (not hashed since last state hash update)? kinda the merkle tree update queue
undefined says There is no API for that. In the C++ code we do have a state of dirty pages, but it is an implementation detail for internal optimizations, and it does not track precisely dirty pages because of the TLB, pages in TLB are always considered dirty even when not touched between state changes. I am not sure if an API for that should ever exist. What is the use case?
undefined says thinking storing a whole machine state can be a bit heavy and storing deltas in state instead could be interesting
undefined says like machine diff kind of thing
undefined says and for ZK could be a way to know what pages will get touched / written out so it becomes confirmation instead of writing
undefined says Another option would be an API to retrieve a merkle tree nodes up to 4096 bytes leaves (or higher number), then you can use this to compute diffs between the merkle trees, I think such API would make more sense than relying on tracking dirty pages.
undefined says There is no way to track dirty pages precisely without hurting performance, so I think merkle tree APIs makes more sense, but just an idea
undefined says ah, that actually makes sense
undefined says Hello everyone, how's it going?!

I purchased this RISC-V microprocessor called Vision Five 2: https://www.starfivetech.com/en/site/boards, and in the upcoming weeks, I'm going to attempt to run a DApp node on it.

The idea is to see if I'll be surprised by any performance, as per the docs:

"This means that software running inside it will not perform as well as running on the host machine using an x86 or ARM architecture. Expect performance to be at least 50x slower than bare metal."

Does anyone have any tips or suggestions?
undefined says a hardware RISC-V will only help you to build binaries targeting RISC-V. Not related to running the Cartesi Machine or the Cartesi Node.
undefined says I'm working on getting llvm/clang to crosscompile to riscv64 in the cartesi/toolchain image (prereq for Godot engine) and running into some issues. I got clang compiling with gcc and it looks like it worked

```
root@e15ce56e1551:/opt/riscv# clang -v
clang version 18.0.0
Target: riscv64-cartesi-linux-gnu
Thread model: posix
InstalledDir: /opt/riscv/riscv64-cartesi-linux-gnu/bin
Found candidate GCC installation: /opt/riscv/riscv64-cartesi-linux-gnu/bin/../lib/gcc/riscv64-cartesi-linux-gnu/10.2.0
Selected GCC installation: /opt/riscv/riscv64-cartesi-linux-gnu/bin/../lib/gcc/riscv64-cartesi-linux-gnu/10.2.0
```

But it's trying to pull in nonexistent headers when compiling a simple hello world:
```
In file included from hello.cpp:1:
In file included from /opt/riscv/riscv64-cartesi-linux-gnu/bin/../lib/gcc/riscv64-cartesi-linux-gnu/10.2.0/../../../../riscv64-cartesi-linux-gnu/include/c++/10.2.0/iostream:38:
In file included from /opt/riscv/riscv64-cartesi-linux-gnu/bin/../lib/gcc/riscv64-cartesi-linux-gnu/10.2.0/../../../../riscv64-cartesi-linux-gnu/include/c++/10.2.0/riscv64-cartesi-linux-gnu/bits/c++config.h:518:
In file included from /opt/riscv/riscv64-cartesi-linux-gnu/bin/../lib/gcc/riscv64-cartesi-linux-gnu/10.2.0/../../../../riscv64-cartesi-linux-gnu/include/c++/10.2.0/riscv64-cartesi-linux-gnu/bits/os_defines.h:39:
In file included from /opt/riscv/riscv64-cartesi-linux-gnu/riscv64-cartesi-linux-gnu/sysroot/usr/include/features.h:489:
/opt/riscv/riscv64-cartesi-linux-gnu/riscv64-cartesi-linux-gnu/sysroot/usr/include/gnu/stubs.h:11:11: fatal error: 'gnu/stubs-lp64d.h' file not found
   11 | # include <gnu/stubs-lp64d.h>
```

I see a `gnu/stubs-lp64.h` but haven't been able to get clang to compile with soft floats. If I try to set `-mfloat-abi=lp64`  I get an error that the option isn't supported. The cartesi machine emulator readme also mentions that Cartesi implements RV64IMASU, which floating point (single OR double precision) is missing from.

What am I doing wrong here? Does cartesi-riscv include floating point support?
undefined says newest emulator/toolchain should be rv64gc
undefined says what toolchain version image are you on?
undefined says i pulled latest yesterday
undefined says that's good to know we're on GC at least
undefined says Don't use the toolchain image, this toolchain image is to be used to compile the kernel, but for dapps you should use your dapp distribution toolchain, and you won't need to deal with cross compiling which can be painful
undefined says Cross compiling is painful indeed üòÜ
undefined says Pull a Docker Ubuntu riscv64 image, and compile inside it, make sure to use the same Ubuntu for the dapp, this is the easiest way, here is a command:
```
docker run --rm -it --platform=linux/riscv64 riscv64/ubuntu:22.04
root@bc7b3421419f:/#
```
Then compile stuff as you would typically compile for Ubuntu, you can later create a Dockerfile to automate compiling and move files around for you.
undefined says Aaahh okay I'll try this next. Thank you!
undefined says Of course, your dapp will need to be using Ubuntu too (if its not already), things compiled inside Ubuntu  works inside Ubuntu
undefined says Yes using Ubuntu already
undefined says Is it generally safe to assume that if I compile something on riscv64 Ubuntu, it will run on the Cartesi machine?
undefined says As long the Cartesi Machine rootfs is also Ubuntu, this is not the case if you are using `cartesi/image-rootfs` for example
undefined says The `cartesi/image-rootfs` is to be deprecated and you should avoid using it for dapps, in favor of using Ubuntu
undefined says did the base image discussion land on ubuntu or debian ooi?
undefined says Okay good to know, appreciate the help here
undefined says We are still using Ubuntu because it has proper release tags in Docker hub, Debian announced official support for riscv64 few weeks ago, I will suggest switching to it once it has proper stable tags on Docker hub, at this time there are only `unstable`, `sid`, `experimental` tags.
undefined says re: lambda

do we have any stats on 'time to load a machine from snapshot/stored machine' and 'actual execution starting with run()'?
undefined says Not yet
undefined says Loading machine from storage can be slow if you want to check the merkle tree. Loading from a snapshot should be very fast. We are thinking about using the second alternative, and if we move to the second, we are thinking about how to optimize it.
undefined
undefined says Welcome!
undefined says Can‚Äôt wait üòù
undefined says ÂìàÂìà  Êñ∞È¢ëÈÅìÔºåÊúâÊÉ≥‰∫ÜËß£ctsiÊåñÁüøÁöÑ‰∏≠ÂõΩÁî®Êà∑ÂèØ‰ª•ËÅîÁ≥ªÊàëÔºå‰∏ÄÁõ¥Âú®Á∫øÂì¶
undefined says for ?
undefined says descartes rollups on testnet and eventually Ethereum mainnet üôÇ
undefined says When will this be released?
undefined says We don't have a date yet, but it is one of the main objectives for this year's roadmap
undefined says try to partner with IOTA, they are working on smart contracts. would be awesome as IOTA is using bleeding edge technology aswell
undefined says serguei is already an early investor and advisor here
undefined says (and also Augusto's co-author and friend  üòä )
undefined says cheers~~ nice to see you here!üëç
undefined says Partner with Cardano
undefined says Cardano partner!!
undefined says sorry what?
undefined says ?
undefined says Cartesi roll ups is perfect for cardano, like come on cartesi is revolutionizing smart contracts and cardanos new updates is begging for new smart contract technology
undefined says I was just emphazising a partnership with cardano would be cool
undefined says 
undefined says I asked about a month ago, hope it happens with the release of cartesi roll ups
undefined says There is currently no partnership with Cardano, but in case it happens, we'll announce it like we always do when we establish a partnership
undefined says I can always be hopeful üòÖ an announcement like that is worth the wait
undefined says Cardano  isn‚Äôt even a working smart contract crypto currency yet
undefined says Would one of you help me to understand if Cartesi really is a Layer2 solution (optimistic rollups) or if it is a dangerous side-chanin like the following article would describe it:
https://gourmetcrypto.substack.com/p/layer-2-for-beginners

Sorry for the harsh language... ^^
undefined says Haven't read the article yet, but thanks for the link.
The channel you're in right now is about the descartes-rollups, which would - by this table's definition - be a true L2 solution. 

The Cartesi rollups would be similar to the Optimistic Rollups section, everything is secured by L1 and there is a finalization period for things to be withdrawable onchain. Our rollups, like the optimistic one, use fraud proofs instead of validity proofs.

We do have very different design decisions from Optimistic  - they use the OVM, limiting them to running things that can only be ran on the EVM. Further, their fraud proof is not interactive, limiting the intensity of computations to what can be proved on L1. The Cartesi RollUps uses a RISC-V VM that is capable of running linux, so it dramatically increases the kinds of things you can do and we use an interactive fraud proof - which doesnt impose a limit on the size of computation we can withstand (i.e creepts).

Having said that, we also have a Sidechain called Noether...which was designed to deal exactly with the problem highlighted on that table - the "data hungryness" of Rollups. I still haven't read the article, so I'll do that before criticizing it too much - it does seem, however, that it underestimates the importance and tradeoff possibilities of sidechains.
undefined says Thank you very much for the explanation. Indeed, they describe side-chains as it was something evil, but as I unterstood your sidechain is (not only) meant as an oracle to handle data.
undefined says ...and the cartesi rollup seem to have many advantages over other solutions but is actually something different than Noether (the sidechain). üôÇ
Thanks for bringing some light in my confusion. 
... I set up a node today and hope to get some support on the node-runner channel.
Have a nice day Felipe!
undefined says No problem, always here to talk about this stuff. Glad to know that things are a bit more clear! 
I think being skeptical is always a good trait when dealing with blockchain projects, so feel free to always show up and challenge us on our statements/products üôÇ

Have a nice day as well!
undefined says That was very insightful is their somewhere i can learn more about it all im curious how it works
undefined says You can read this Medium article about our approach on optimistic rollups
undefined says https://medium.com/cartesi/scalable-smart-contracts-on-ethereum-built-with-mainstream-software-stacks-8ad6f8f17997
undefined says Thank you
undefined says Anyway cartesi can be applied to banking ?
undefined says Hi @Samson Taylor, can you please elaborate on your question?
undefined says Basically want to know if any of Cartesi applications or products can be applied in the banking sector .
undefined says Basically banking operations
undefined says Applications for banking can be built upon Cartesi. Pretty much "anything" can be built on Cartesi, since it implements a full linux kernel with a filesystem. (I'm just a lurker, not a dev)
undefined says As @jebba said, Descartes enables DApp developers to access a Linux environment to execute DApp logic, so the possibilities are endless. That enables lending products, options, risk analysis and a lot of other banking applications that demand complex computations and/or more advanced libraries and frameworks
undefined says That‚Äôs good to know . Work IT with a bank down in west Africa . If ever you guys come up with any banking solutions I‚Äôd love to talk .
undefined says That's great to know. In case you have some financial DApp idea you'd like to develop, let us know as well.
undefined says Hey @Samson Taylor, can u pls dm me so we can discuss about it? Thanks
undefined says Cardano is working on banking in Africa, could CTSI benefit them by helping their development and prices with optimistic roll ups? Or is this a dumb idea
undefined says Would have to know more about the project's scope and requirements. If there are complicated computations to be performed for lending products, for example, they could sure benefit from Descartes both to allow using existing libraries to program those features on Linux and also to offload most of the computation off-chain.
undefined says guys, when descartes-rollups is released, does that mean I could code a smart contract with Java ( assuming there's some kind of Java SDK for Ethereum ) for example ? I mean basically my question is, once descartes-rollups is released, do we have anything else that needs to be there so that this whole stack of 'mainstream software components' could be available ?
undefined says Descartes rollups allow you to dispute/validate "ongoing" computations. With Descartes 1 you can already code DApp logic in Java, for example, inside the Cartesi Machine, but the disputes are performed on a complete computation (for example, on Creepts, that computation is the simulation of an entire game so you can confirm/rebute the highscore). Creepts itself has the verification engine running inside the Cartesi Machine written in Typescript. With rollups the dispute/validation can happen before the computation has ended, so exemplifying again with Creepts, while the game is still not over.
undefined says Carlo, thank you. It would be great if for each of your products - especially for the roll ups you could write a blog post with some more real example, besides some fancy 'would know only if you get deep inside' blockchain terms. I just think people could appreciate the project much more if you provide them real scenarios.
undefined says We try to provide real scenarios to illustrate our products. One of the things we do is releasing tech demos with each major version of the technology. Creepts was meant to demo the 1st version of the core technology (which is the one used on Descartes 1). When we release Descartes 2, we'll also lunch a demo DApp for it. Soon we'll launch a poker game (using Matic instead of Ethereum for layer 1) to showcase Descartes on a different layer 1 blockchain. In the docs there is a tutorial section so people can get started and understand the involved parts on much simpler setups, but still doing real applications.
undefined says This demo with Polygon, what kind of software stack you would be using to build it ?
undefined says Hello @bai_gosho. The game will be mostly developed in Typescript and C++, besides a couple of smart contracts written in Solidity and deployed to Polygon's Matic network.
undefined says Milton, thanks a lot. Those Typescript and C++ modules ( components ) would be detached from the Solidity main program and just be 'called on demand', while their execution and result will happen on some Cartesi's VMs, is my understanding correct ?
undefined says Just trying to understand better the whole platform, it's not easy üôÇ
undefined says Hello @bai_gosho. Ok, I can share a little more details of how things work:
- The game is based on Mental Poker (https://en.wikipedia.org/wiki/Mental_poker), meaning that players can use cryptography to play against each other without a central server
- The game runs mostly in the browser, and whenever a player makes a move (e.g., places a bet), that information is registered/logged in the blockchain
- The core Mental Poker library is written in C++, and is compiled to WebAssembly for use within the browser (along with front-end logic written in Typescript)
- If anyone tries to cheat or if the players disagree (e.g., both players claim to have won), any player can "appeal to the supreme court", which amounts to calling the smart contracts on the blockchain to enforce the correct result. At this point, the game log stored in the blockchain can be used to trigger a Descartes computation. This will run the very same C++ code inside a Cartesi VM to execute the entire game and find out who actually won.
undefined says Thank you.
undefined says Hi guys. I have a question. I‚Äôm interested in building dapps and I discovered Cartesi. I would like to know if it is only oriented for dapps requiring intensive computation or if it‚Äôs can be also a good choice for a conventional dapps (especially for reducing blockchain fees) ?
Thank you! üòÄ
undefined says Hi! Yeah, can be a good choice for less demanding DApps as well, not only to reduce fees but also to simplify programming the logic by using existing Linux compatible libraries.
undefined says @Carlo Okay! thanks for your response
undefined says Np üôÇ
undefined says When roll ups are announced will cartesi also have new partnerships to implement the roll ups software upon?

Such as ETH, ADA and other projects
undefined says How is progress going? I'm very excited for this update in the far future
undefined says As always partnerships are made public through our public channels (announcements channel here on Discord, twitter, Telegram communities, etc)
undefined says Currently we are on track, as part of a new Descartes release it will be available on Descartes compatible chains
undefined says you can keep track of those on the documentation (https://cartesi.io/en/docs/descartes/supported-networks/)
undefined says Just looked at this, great stuff!
undefined says Thanks for the feedback, we put a lot of effort on the documentation üôÇ
undefined says https://medium.com/cartesi/cartesi-rollups-rollout-testnet-40c90d10c2f1
undefined says Please tell me how to do staking.
undefined says Hey there! Currently there are 2 options and as I said 3rd one is on testnet, but going to be available on Mainnet soon! 

You can stake directly by running your own node and the tutorial is here: https://medium.com/cartesi/running-a-node-and-staking-42523863970e

So the more you stake or the lower the globally staked CTSI is, your chances get higher and you are more likely to produce fast, while the opposite makes it more likely to take longer to produce. 

For current APY, please check: https://explorer.cartesi.io/

You can take a look at the calculator at the Cartesi Explorer ( https://explorer.cartesi.io/calculator ) to simulate some scenarios on a simplified model of the PoS and have a grasp on what to expect (the calculator outputs AVERAGES for nodes in the given condition, since, as I explained, the system is probabilistic). 

The other option available right now is staking through a 3rd party custodian service. They work like centralized pools and have their own set of rules and policies for rewards and conditions on staking. You can check CoinOne and MyContainer as options in that model. 
I strongly suggest you read this FAQ about considerations between staking by yourself or through a 3rd party custodian service: https://github.com/cartesi/noether/wiki/FAQ#is-it-better-to-run-my-own-node-or-to-use-a-3rd-party-custodial-service-to-stake

The 3rd option that is not available on Mainnet yet is stake delegation, which enables decentralized pools: https://medium.com/cartesi/staking-delegation-testnet-guide-user-delegation-and-overview-94ea99dd5cf3
undefined says mycontainer is 404notfound
undefined says mycontainer is 404 Page not found.
undefined says Not for me. Any issues with mycontainer, please contact their support.
undefined says ok
undefined says I believe it's mycointainer and not mycontainer (notice there's no 'i' in the second one). People often get them mixed up. See this medium article just so you can confirm:

https://medium.com/cartesi/mycointainer-will-support-ctsi-reserve-mining-and-custodial-staking-b6441a758a6e
undefined says Do I have to send it to bscchain when I deposit it from Binance to the coin? Or should I send it to ECC20?
undefined says Staking is only supported on Ethereum, atm
undefined says erc20
undefined says ok thanks
undefined says Np üôÇ
undefined says Any news about rollup?
undefined says When mainnet?
undefined says It's under active development, but nothing to be shared atm.
undefined says Our objective as stated on the roadmap is this semester. It should reach mainnet near the end of the year.
undefined says Thanks
undefined says Sure, np üôÇ
undefined says Hello guys, some noob questions about roll ups -
With cartesi, will roll ups be implemented on an l2 network or side chain? If so, how would the average web3 user connect to this network or side chain?
undefined says It's currently being implemented over Ethereum, but like Descartes v1, should become compatible with multiple networks (including L2 like Polygon). We'll release examples and other documentation like we did for Descartes v1 to show how to integrate on DApps.
undefined says 
undefined says This is false right? They mean delegated staking on mainnet? Because RollUps comes in December
undefined says No need to comment a yes or no, I understand no one can comment on future events. But Im positive that Roll Ups on Mainnet are happening at the end of the year, (December)
undefined says False üëç
undefined says Thank you
undefined says Is there any way for the users to get data to the Cartesi VM without sending a message through the blockchain?(I.E the users deposit their funds to a smart contract, and the actual moves of the game are sent as EIP712 signed messages in requests to a Descartes node)
undefined says It seems to me that this is simply a way to outsource smart contract logic/tempstorage and thereby reduce the gas needed to play the game
undefined says In other rollups I've seen that they essentially act as side chains that publish proofs to the main chain in batches and aren't interacted with except for deposits/withdrawals
undefined says Let's say i wanted to make a simple swap application on cartesi. I design a smart contract that allows me to verify ERC20 deposits and send a message to update a balance variable on the shard for my application.
undefined says (wrapping/bridging)
undefined says now I want to swap these tokens by interacting with the liquidity pool contract on my shard. Must I send a message from my Ethereum account to the Cartesi contracts on Ethereum, or can I send a signed message directly to my Descartes node?
undefined says no
undefined says yes
undefined says no
undefined says There are, but you'll have to make sure on your DApp logic that the data source for the computations is available, otherwise you can have problems when trying to validate the computation/open a dispute.
undefined says About the part of saving costs, we'll probably initially launch Cartesi Rollups on Polygon since the costs in there for using the blockchain directly are low enough and, on a second version, we will launch on Ethereum and users will be able to send messages to Cartesi Rollups sequencer(s) (that will enable considerably lowering the costs on Ethereum).
You might want to develop your DApp to run on the initial version on Polygon and then clone it to port it to Ethereum. Or, depending on your development timeline, end up launching your product together with our sequencer.
undefined says If you have something already on your mind and want to discuss it further, we'll be happy to do so üôÇ
undefined says I see, that sounds good. I assume the sequencer would just post the hashes to Ethereum in batches then?
undefined says It also grants the order since on an exchange DApp and many others, the order of the actions have a lot of influence on the outcome.
undefined says Yeah, transaction ordering is important. I'm assuming that the  Cartesi Foundation would run the sequencer and shoulder the gas cost for it, correct?
undefined says That's how I've seen other rollups do it at least
undefined says That is one of the things currently under discussion
undefined says How would the alternative work? I don‚Äôt think I have seen it be used anywhere else.
undefined says Kind of curious idea for rollups: https://twitter.com/epolynya/status/1459047114315468802?t=lxanNADZ4BIjRCsREJzZwA&s=19 (share gas fee paid for contract interaction with smart contract maker)
undefined says Gotta think about it a bit more. All these ideas have a lot of consequences on multiple aspects (economic, usability, centralization/descentralization, security, etc)
undefined says Is the mainnet development schedule progressing without any setbacks?
undefined says With any good news, timing and timing matter. I hope it's not revealed before it's too late.
undefined says Not sure what you mean with this second sentence.
undefined says If you mean Cartesi Rollups mainnet launch, our current estimate is later this year/early 2022. As you said, it's always possible to have some setback and postpone this date (as in any development project) and if that is the case, we'll communicate it.
undefined says https://www.cryptotimes.io/polygon-launches-a-zk-stark-scaling-solution-to-develop-dapp/
undefined says hi guys. what's your comment on the Polygon new initiative? the Maiden VM thing
undefined says Can someone explain to me what the Rollups Aggregator is and how it effects the chains connected?
undefined says Where did you read this term?
undefined says https://coinmarketcal.com/en/event/rollups-aggregator-40172
undefined says So you meant aggregator, that's why I asked for the source üôÇ So the aggregator is generally a service that helps saving costs by aggregating multiple transactions into fewer transactions.
undefined says Different projects have different implementations, details and effects but generally the common ground is the one I just described.
undefined says So the effect for DApps is generally cutting down cost, taking a longer time for their "transactions" to be processed (as they have to wait for the aggregator to finish a "block" of transactions condensed into one to be sent and processed) and for the underlying chain the effect is having less transactions (since it's processing the aggregated transactions instead of multiple individual ones).
undefined says Perfect explanation and easy to understand, thank you!!
undefined says Np üôÇ
undefined says https://vitalik.ca/general/2021/12/06/endgame.html hi @Carlo @tuler.eth  Vitalik just posted a new article about OR on Ethereum. What's your comment on this? üòÜ
undefined says It's been a while since Vitalik is putting his chips on OR/ZK solutions to solve Ethereum scalability problem while preserving the decentralization properties that are the foundation of Ethereum. Time will tell which ones are going to be the champions for some niche (particularly I don't think there is going to be a single champion, probably a champion per use case/set of problems)
undefined says Hello. When will rollups be available?
undefined says https://medium.com/cartesi/developers-can-start-coding-for-cartesi-rollups-end-of-december-1113493ce775
undefined says Interesting. Thank you for the fast response.
undefined says https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f anyone has idea what heck those folks are talking about? üòÜ
undefined says starkware has the CAIRO lang that i've used a bit..I'm guessing they will be talking about recursive Starks on top of L2?!?
I'll have to read it. Starks are hard right now to integrate in a dApp for me Lol
undefined says It seems they make up this concept without clarifying the necessity or advantage of it. According to their logic, if man introduces L4 and L5, wouldn't the transaction costs being reduced to 1/100,000,000,000 of L1 and still maintain the L1 security? Lmao!üòÜ
undefined says L5! üòÖ ...yeah that sounds insane, but who knows?!?
undefined says hi, is Rollups still on track for Dec/Jan?
undefined says Hey @fafi we are on track. Cartesi Rollups is available for coding in December with a fundamentally different approach to rollups and new R&D initiatives. Milestone I (Q4/21): The first release of our rollups solution focuses on offering a shortcut for mainstream developers to enter into the Blockchain world. You can read the most recent article with each of our milestones here: https://bit.ly/3xIxKay
undefined says Awesome, thanks for the info, was just curious :)!
undefined says Can someone help me understand how descartes rollup sequencer works? I understand that on L1 Ethereum, you send Eth to an Descartes smart contract (portal/gateway also on L1). Then descartes confirms and credits you on L2 with equivalent amount. You can now interact with your smart contracts (or others) deployed on L2. When you want to withdraw, it rolls-up to L1.
Question 1 - Since Ethereum network cannot make API calls or interact with external data, in order to preserve determinism, how does  L2 even know that a txs has occured? Using events? how does sequencer send this info from L1 to L2?
Question 2 - who is running these sequencers? Are they centralized? are they staked?
undefined says Discussed on the #üí¨‚îÉgeneral channel
undefined says random note, so, let's say i'm a developer wanting to start using cartesi rollups as i heard it's in alpha from a buddy.. and i go to cartesi.io
undefined says there's no sight of anything about the alpha or docs or anything and i'm lost üôÇ
undefined says might be worth even throwing up a popup or something about how to get started as developer attention is scarce and you've probably lost a potential customer if he's confused for more than 60 seconds unless he -desperately- wants to use it and keeps looking üôÇ
undefined says Agree. Maybe @colinsteil can address it.
undefined says yeah, Cartesi's benefit is their amazing, detailed docs and helpful Discord, would put it front and center üôÇ
undefined says Hey @Carsten | Zippie ! Thank you for suggestion and always valuable contribution. We are working to improve our documentation soon. Stay tuned. üòâ
undefined says cool, looking forward
undefined says ... and one tiny showstopper thing for most:
undefined says from https://github.com/cartesi/rollups-examples/tree/main/echo

    # Clone repo
    git clone --recurse-submodules git@github.com:cartesi/rollups-examples.git

Carstens-MacBook-Pro:cartesi carsten$     git clone --recurse-submodules git@github.com:cartesi/rollups-examples.git
Cloning into 'rollups-examples'...
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
undefined says you probably want to use https:// üôÇ
undefined says ah @jebba already brought this up
undefined says 13
undefined says Hello guys how are you doing today?

I'm running the simple Echo Dapp example with rollups from github and doing some testes with it. I would be glad if anyone can ask me how to check a specific notice from a specific input i did.
For instance, if i do
`sudo docker exec echo_hardhat_1 npx hardhat --network localhost echo:addInput --input "0x636172746573690D0A"`
And this input is added sucessfully, how can i check the notice generated from this specific input?

I'm reading about "current_epoch: [AccumulatingEpoch]!", but it would be nice if i have some command line examples to do it. Can anyone help me on this?

Thanks in advance!
undefined says Fine, thanks! Hope are doing well as well üôÇ I'm asking some colleagues about it and will get back to you as soon as I hear back from them.
undefined says Thank you kindly
undefined says Hey @Marcus Vin√≠cius !
I recommend you to use the GraphQL query GetEpochStatus instead of current_epoch. üòâ
Any other doubt or issue please let us know!
Cheers
undefined says Hello @Marcus Vin√≠cius were you able to get the notices using GetEpochStatus?
undefined says Hello Claudio, how are u doing? I've tried the following command with GraphQL
`query{ GetEpochStatus(query:{session_id: "default_rollups_id", epoch_index:"0"})`
     ` { session_id epoch_index processed_inputs{`
     ` result{`
       ` notices{`
       `payload } } } } }`
and it shows me the notices array. However, this array has only notices about the example string payload ("cartesi"). Then, i'm thinking that if i'm doing right the notice adding process, like this

`app.logger.info("Adding notice") response = requests.post(dispatcher_url + "/notice", json={"payload": body["payload"]})`

Since I've done many other inputs, i believe the new notices aren't being added properly. Moreover, i've acessed the new inputs with

`query{ current_epoch{inputs{ inputs{ } } } }`

and they are there. But the notices generated by the processing of this inputs were not found by GetEpochStatus.

I don't know if it is clear, i believe i've executed the query right.

I've also tried to advance 1 epoch believing it could impact somehow in the processing listing new notices but nothing changed.

And always has the chance i'm not doing the things right so i'm studying more about it üôÇ

Thank you!
undefined says Hello @Marcus Vin√≠cius !

1. Ok, It seems you are running the echo example in host mode, I mean your backend code is running outside the cartesi machine.

2. Did you check the log in the terminal the docker-compose is running to see if your call to /notice was received?

3. According to the [OpenAPI spec](https://github.com/cartesi/openapi-interfaces/blob/master/dispatcher.yaml), /notice "can only be called after the DApp received an advance state request". Is it correct in your code?
undefined says Hello!

I've solved my problem. It was not related with the query commads at all but related with docker. When i was ending sessions, one of the containers (the database one) wasn't going down. To solve it i had to run the 
`docker-compose -f docker-compose-host.yml down -v` with sudo mode and start it again similar to a fresh install. Now when i execute the query commands they give me the notice array as expected, as in the image.

Thank you so much for the suport!
undefined says Fantastic @Marcus Vin√≠cius !
Any other issue or doubt, please call us!
undefined says Hello guys, how are you doing today?

Today i have some questions regarding the usage of cartesi machine in the playground(https://github.com/cartesi/playground), if you guys could answer i would be really glad since i'm starting the process of learning üôÇ . I've followed the example from site (https://cartesi.io/en/docs/machine/target/linux/) for doing an hello.cpp, and it went smooth. But i have some questions when generalizing it.

For instance, if instead of using an cpp file, what if i used directly an python file like hello.py? I would have to generate an ext2 file with 

`genext2fs -b 1024 -d hellopy hellopy.ext2 (Content of hellopy directory is the hello.py file)`
and then use the following

`cartesi-machine \`
    `--flash-drive=label:hellopy,filename:hellopy.ext2 \`
   `-- /mnt/hellopy/hello.py`

Those are the right steps for it? When i did it, i've got an

`/bin/sh: /mnt/hellopy/hello.py: Permission denied`. 

I even try instead of using the "hello.py" using an .sh script to call hello.py but the result were the same.

Did I forget something in the process?
undefined says Is hello.py chmod +x and a #!/something in the top?
undefined says I guess that was the main problem. I have to do the chmod for allfiles (i was trying more than one script and forgot the hello.py permission). Thanks @Carsten | Zippie
undefined says This time it was just a permission problem, but keep in mind that the python interpreter is in the rootfs, but for other interpreted languages you'd either have to include it on a custom rootfs or on your application drive.
undefined says I will keep this in mind, thanks for the warning =). The python interpreter version in the rootfs is the 2.7 right? 
Thank you kindly
undefined says In the latest public release of the rootfs, it's version 3.8.6
undefined says you can always check the exact one you are using with the command ```python --version```
undefined says Since i'm new, i'm using the playground project at github for learning. In the dockerfile the configuration isn't updated like
COPY --from=cartesi/rootfs:0.6.0 /opt/riscv/rootfs/artifacts/rootfs.ext2 /opt/cartesi/share/images/
When the rootfs is the 0.9.0. I guess changing it will solve some questions.  Now that you talked about latest version i figured out the playground isn't updated yes. 

Thansk for the help again üôÇ
undefined says Sure, np. If you have further problems/doubts, just let us know üôÇ
undefined says i sure will
undefined says but i'm glad i can have this kind of help in my learning. Thanks a lot
undefined says Regarding this point, i was investigating the rootfs 0.9.0 downloaded with playground. I thought that the python3 enviroment (and some others) was already in the 0.9.0 rootfs file. But when i run 

`cartesi-machine:/ # cd /usr/bin`
`cd /usr/bin`
`cartesi-machine:/usr/bin # env 4th`
`env 4th``env: can't execute '4th': No such file or directory`
`cartesi-machine:/usr/bin # env php`
`env php`
`env: can't execute 'php': No such file or directory`
`cartesi-machine:/usr/bin # env ruby`
`env ruby`
`env: can't execute 'ruby': No such file or directory`
`cartesi-machine:/usr/bin # env tclsh`
`env tclsh`
`env: can't execute 'tclsh': No such file or directory`
`cartesi-machine:/usr/bin # env python3`
`env python3`
`env: can't execute 'python3': No such file or directory`

they wasn't there. 

I'm initializing the machine like this:

`playground:~$ cartesi-machine -i -- sh`

in interactive mode for run this commands. I also tried with those flags

`playground:~$ cartesi-machine \`
 `   --rom-image="/opt/cartesi/share/images/rom.bin" \`
  `  --ram-length=64Mi \`
   ` --ram-image="/opt/cartesi/share/images/linux.bin" \`
    `--flash-drive="label:root,filename:/opt/cartesi/share/images/rootfs.ext2" \`
    `-- "ls /bin"`

But didn't change the output. There is something else we have to do for setting up these envs?

I'm sorry for the starter questions. Thank you so much for the help guys!
undefined says did you try ```python``` instead of ```python3```?
undefined says Yes. Tried python, Py python2. It don‚Äôt changed the result
undefined says Can you point me to which playground version you are using to start one here and take a look?
undefined says Nevermind. I've figured out what i was doing wrong. 

The problem was intead of using "make run", i was doing 

docker run -it --rm -h playground \
    -e USER=$(id -u -n) \
    -e GROUP=$(id -g -n) \
    -e UID=$(id -u) \
    -e GID=$(id -g) \
    -v `pwd`:/home/$(id -u -n) \
    -w /home/$(id -u -n) \
    cartesi/playground:0.3.0 /bin/bash

Manually (as it is hinted in https://www.cartesi.io/en/docs/machine/host/overview/). With this way those problems related to python and other interpreters happen, but with make run it goes smooth. 

But thanks, i was calling day but for some reason when u asked me to pass those informations i've re-done my steps and tried the make thing as in read-me of github. üôÇ
undefined says Good üôÇ I asked because what's available depends on several things so just wanted to check it on the same environment you were using.
undefined says Now we are cooking! Thanks again üôÇ
undefined says Great! Glad to see it working üôÇ
undefined says [Questions]
Hi guys, I have some questions and really hope that you can explain that to me.

As I read one of the post in medium, system will interact with backend through API ( link : https://medium.com/cartesi/cartesi-dapps-are-here-e07f358207d6). However, in some examples such as "hello world", "calculator" in the Docs of Cartesi, backend run all script data on file where we set up cartesi machine, not through API. 

So my question is , how does the cartesi machine interact with backend in the production enviroment, ? 

The pic attached below demonstrates how the components interact with each other in "hello world" and "echo" examples ( the flow of system). Did I have any misunderstandings?
undefined says Hi @Albert Nguyen !

We have 2 products: Descartes v1 (our first product) and Cartesi Rollups (the new one).

The examples you mentioned are related to the Descartes v1 that is very different from Cartesi Rollups. üòâ 

These 2 products have one thing in common: both have a Cartesi Machine as their heart.

So here comes a simplified diagram that shows how your input when running the rollups-examples/echo reach your backend code.

Let me know any other question you have, ok?
undefined says 
undefined says Thank you. I got it now. I will let you know if having any doubts
undefined says Hello Guys, how are you doing? 

I've created and a simple calculator example in my repository here https://github.com/souzavinny/rollups-examples

Thanks for the support everyone. I will let you know when i put more DApps with Cartesi there üòâ
undefined says Awesome! Very cool seeing your progress!
undefined says Hello folks, how are you doing today?

I enhanced the echo example so that it can now perform text transformations.

I'd like to express my gratitude for your assistance. @Marcus Vin√≠cius and I are working together, and the doubts he posted here were also my doubts. I intend to be more active on Discord interacting with everyone.

Here is the GitHub link: https://github.com/marcusgabrields/rollups-examples
undefined says Great stuff. Eager to see the new cool DApp you'll be developing in the future!
undefined says Hi guys!
this project is awesome.

I had no problem running the tutorial at https://github.com/cartesi/rollups-examples/tree/main/echo, but I have some issues.

1 - When I run docker-compose-host, all containers run in host mode. Then, I start the echo server gunicorn in vsCode. I send the first interaction "...echo:addInput..", and I get the operation's confirmation "Added input..". That's all right. But when I stop the gunicorn, and send the same "...echo:addInput..", I receive the same confirmation "Added input..", but no input was added to the echo, I supose. No containers from the other docker-compose was running, nor the echo gunicorn. I was not sure if gunicorn were running somewere, so I changed the name of "echo.py" to be sure no file was listening in 0.0.0.0:5003 since gunicorn looks for that file. This is the default "Added input.." confirmation's behavior or I'm missing something?

2 - I have started developing a django(python) app to listen on port 5003. Now it only listens. When I do "...echo:addInput..", django just receives the request. When I do it again, django doesn't receive anymore. Then, I restart the containers and I do the "...echo:addInput.." again as the first time, without restarting django. It receives. Only the first time. The containers stop communicating with the Dapp when the Dapp doesn't respond the first time? (Anyway, the "Added input.." message still occurs.)

A friend told me to check all process listening on 5003. I used "sudo lsof -i :5003" and "ss" similar commands, but only the django app was listening, and doesn't send any response yet. When I stop django server, no process is listening on 5003.
undefined says About 1): you get confirmations that the input was received and that doesn't mean it was processed (and you won't if the backend of the DApp is not executing)
undefined says About 2) - can you provide more details? Can you send us the logs? Is the backend application having some error? Is your backend calling the ``` /finish``` endpoint after processing the input?
undefined says The backend won't receive the next input until it signals it has completed processing the current one
undefined says about  (2) is clear to me now. I didn't implement the \finish yet. thanks!

about (1): when django is on, it's process is listening on 5003, when it's off, no process listen on 5003 [annex1]. But hardhat still sends the "Added input.." without no one listening on 5003, let alone processing  [annex2]. I think the only logs that can help in this situation are from containers. I will capture a piece in the time and see whats happening. thanks!
undefined says there is a error message in log:  `rollups_dispatcher_1  | Error: TonicStatusError { source: Status { code: DataLoss, message: "session is tainted", metadata: MetadataMap { headers: {"content-type": "application/grpc", "date": "Mon, 14 Feb 2022 20:49:39 GMT"} }, source: None } }`

is clear to me there is a error because django is not responding. this message refers to that?

"added input" means that hardhat sent the data, wherever django listens or not, receives or not, responds or not. that's the concept?
undefined says @bruno gondim can you provide us with the full log? We need to check details on previous entries
undefined says Hi @Cl√°udio , This is the video explains the issue we discussed in the meeting. If you need anything (logs, input, ...), please let me know. https://drive.google.com/file/d/1om8vQITRtspFx3zkAAhteD_8Z4S-qDno/view?usp=sharing
undefined says Yeah, the full container logs would be much appreciated. Could you also test selecting a single book and tell us how it goes?
undefined says Hello Guys, how are you doing? 

I've managed to mount a new rootfs with some 3rd Party Python libraries that i want to use in a DApp. In the time of "make machine" command, i've got this message bellow:


`Building cartesi-machine calc-dapp instance...`
``
`         .`
`        / \`
`      /    \`
`\---/---\  /----\`
` \       X       \`
`  \----/  \---/---\`
`       \    / CARTESI`
`        \ /   MACHINE`
`         '`
``
`[    0.379726] Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004``
`[    0.379929] CPU: 0 PID: 1 Comm: init Not tainted 5.5.19-ctsi-3 #1`
`[    0.380075] Call Trace:`
`[    0.380183] [<ffffffe000022904>] walk_stackframe+0x0/0x108`
`[    0.380351] [<ffffffe000022d50>] show_stack+0x3c/0x50`
`[    0.380503] [<ffffffe00037e1b4>] dump_stack+0x2c/0x3c`
`[    0.380654] [<ffffffe0000275c8>] panic+0x11c/0x2d0`
`[    0.380800] [<ffffffe000029eb0>] do_exit+0x28c/0x2e0`
`[    0.380951] [<ffffffe000029f8c>] do_group_exit+0x38/0x94`
`[    0.381110] [<ffffffe000034c40>] get_signal+0xcc/0x39c`
`[    0.381270] [<ffffffe000021eec>] do_notify_resume+0x50/0x190`
`[    0.381440] [<ffffffe000021330>] ret_from_exception+0x0/0x10`

Halted
Cycles: 60293048
Storing machine: please wait
machine: OK
make[1]: Leaving directory '/home/marcus/Documents/CartesiGitClean/rollups-examples/calc/server'

Do you guys ever seen this happen? Maybe this message appeared because i've used an local rootfs and theres some sync process with the default archive or did i forgot something in the configuration of buildroot? The machine seems to work well even with this warning message but i want to know what is really happening here. If you guys have some clues, i would be glad to know.

Thanks in advance.
undefined says it's not a good idea to have the roofts or any of the Cartesi Machine drives being modified by external parties at random times since it can cause all kinds of strange things. Are you having this problem consistently or happened once?
undefined says Technically i just added https://pypi.org/project/py-expression-eval/ option in the buildtools options and then created a new rootfs (since this is a dependence of my python back end). Everything remains the same process of echo example.

This happens only in the process of "make machine" command. In the execution all seems normal.
undefined says the machine works, just this warning is the new thing in the process üòâ
undefined says Hi @Marcus Vin√≠cius , could you please list the steps you did to build the new rootfs with py-expression-eval?
undefined says ###Steps for generating rootfs###

*Considering all requiriments for running Buildroot installed.

1 - Download in https://buildroot.org/download.html
2 - Unpack the tar.gz file

### Including py_expression_eval in the build root options###

3 - in the /package folder created a folder called py-exp-eval. inside it included 3 files: Config.in, py-exp-eval.hash and py-exp-eval.mk

Contents of Config.in :

config BR2_PACKAGE_PY_EXP_EVAL
    bool "py_expression_eval"
    help
      Python 3rd party to evaluate string expressions.

Contents of py-exp-eval.mk

PY_EXP_EVAL_VERSION = 0.3.14
PY_EXP_EVAL_SOURCE = py_expression_eval-$(PY_EXP_EVAL_VERSION).tar.gz
PY_EXP_EVAL_SITE = https://files.pythonhosted.org/packages/c0/a0/3b006218f45931f02becaec93d18be203c62f4a30dd7b3c2e019539661b0
PY_EXP_EVAL_LICENSE = Apache License
PY_EXP_EVAL_LICENSE_FILES = LICENSE
PY_EXP_EVAL_DEPENDENCIES:=
PY_EXP_EVAL_SETUP_TYPE:=setuptools

$(eval $(python-package))

Contents of py-exp-eval.hash
md5  fa5ff578c6b5b4be3d8401bfb548f865  py_expression_eval-0.3.14.tar.gz
sha256    ea60f9404a18346d5a63854db21c50666dfb4274ae111000165b31c6f8ab93f1  py_expression_eval-0.3.14.tar.gz

After this, we can use the package inside build root.

4 - Inside buildroot folder, opened the terminal and executed make xconfig.
Target architeture : RISCV
Target Binary Format: ELF
Target Architecture Variant: General purpose
Target Architecture Size: 64-bit
Target ABI: lp64d


Interpreter languages and scripting: 
python3
.py sources and pyc compiled

External python modules:
Flask
py_expression_eval

FileSystem images
ext2/3/4 root filesystem > ext2 (rev1), no compression.

5 - After save configuration, i've run the command make and it generated an rootfs.ext2 with almost the same size of the default rootfs we get in the default run of echo example.

6 - replaced the rootfs inside the server folder. Excluded the rootfs from the dependecies file, which now has this content
https://github.com/cartesi/image-kernel/releases/download/v0.9.0/linux-5.5.19-ctsi-3.bin
https://github.com/cartesi/machine-emulator-rom/releases/download/v0.8.0/rom.bin

7 - run the make machine command. The machine is built normally, but with the warning showed above.

8 - The program also works fine. No problems found yet.

and that sums up what i've done.
undefined says Ok, good that it's working in the final version. Allow us to investigate why you're getting this error during the build
undefined says This is all the logs i can get. 
The file "logs from docker containers.txt" contains all the logs that comes from docker containers.
The file "input.txt" contains the input and result when adding that input.
The file "log from backend.txt" contains logs in my back end running in local. This file will have the notice data i send to /notice api.
The file "response.json" contains data i query the notice in graphql.

And, when i select only a single book, the infra successfully save the notice.

My books info contains just 3 fields:
1. id => integer
2. name => string
3. quantity => integer
undefined says hi @Carlo , these are the full logs. 3 of then are from the docker-compose-host, the command "input..." and the command "sudo lsof -i :5003". the other 3 are the same, except for the "ScriptDjango", which was listening on 5003 and replaced the "ScriptListeners" on the round.
undefined says 
undefined says Thanks, we are investigating. Seems the issue is related to the size of the notice content. We'll let you know when we get to the bottom of it.
undefined says Thanks @bruno gondim, let us analyze those logs üôÇ
undefined says I'll DM you the details not to spam the public channel too much üôÇ
undefined says @Marcus Vin√≠cius some things about the issue you faced:
- The target ABI seems to be wrong and you are not including our programs, like http-dispatcher, yield and init. The kernel problem seems to be related to init.
- We suggest you follow a procedure similar to this one to build a custom rootfs (the link is for doing so on Descartes v1, not Cartesi Rollups): https://cartesi.io/en/docs/tutorials/generic-script/custom-rootfs/ (edited) 
- If you are brave, know what you are doing and want to do from scratch, I suggest you take a look at the image-rootfs repository (https://github.com/cartesi/image-rootfs) where we store the buildroot config and the recipe for building it on the dockerfile so that you can check what you are missing
undefined says Thank you Carlo for the answer! I will try the sugestion and investigate a little more about this.
undefined says Hi guys, hope you are doing well. I have an issue with cartesi machine and i hope that you can show me what's wrong.

We implemented code successfully in host mode. Now we are going to put the back end code into the cartesi machine.

We configure a seperate custom root file system which includes the necessary libraries: flask and sqlite. And we name it poc-sqlite.ext2

When we follow to the docs of cartesi (Link: https://cartesi.io/en/docs/tutorials/generic-script/cartesi-machine/ ), it runs fine. The detail log is bellow:
tienmanh@manhnguyen3:~/Documents/code/cartesi/cartesi-machine$ docker run -it --rm \
>   -e USER=$(id -u -n) \
>   -e GROUP=$(id -g -n) \
>   -e UID=$(id -u) \
>   -e GID=$(id -g) \
>   -v `pwd`:/home/$(id -u -n) \
>   -w /home/$(id -u -n) \
>   cartesi/playground:0.3.0 /bin/bash
tienmanh@1c8fac500904:~$ cartesi-machine \
>   --flash-drive="label:root,filename:poc-sqlite.ext2" \
>   --flash-drive="label:input,length:1<<12,filename:input.py" \
>   -- $'dd status=none if=$(flashdrive input) | lua -e \'print((string.unpack("z",  io.read("a"))))\' | python3'

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

 * Serving Flask app "<stdin>" (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: on
 * Running on http://127.0.0.1:5003/ (Press CTRL+C to quit)
 * Restarting with stat
/usr/bin/python3: can't find '__main__' module in '/'

Halted
Cycles: 1254128609
tienmanh@1c8fac500904:~$
undefined says Then, based on Echo example, I have built the POC Sqlite system by following steps : 

- Copy back end code to echo.py file
- Copy poc-sqlite.ext2 file to server folder
- Edit the echo-dapp.ext2 to poc-sqlite.ext2 in other files

After that, we run the following commands:
1. make clear => To remove the old machine
2. make machine => To build a new machine with the new code and new root file system

In step 2, (run command "make machine"), we got the error module sqlite3 not found. I jump into the machine and check whether the python3 and sqlite3 are installed or not. It turned out that both of them are installed. So, we dont understand why that error occurs. We think, the cartesi machine is missing the sqlite-devel package, but we dont know how to install that package into cartesi machine.
Do you why this happens?
undefined says Full logs:
tienmanh@manhnguyen3:~/Documents/code/cartesi/rollups-examples/echo$ make machine 
make[1]: Entering directory '/home/tienmanh/Documents/code/cartesi/rollups-examples/echo/server'
Building echo-dapp filesystem...
poc-sqlite.ext2: OK
Downloading cartesi-machine rom, kernel and rootfs...
rom.bin: OK
rootfs.ext2: OK
linux-5.5.19-ctsi-3.bin: OK
Building cartesi-machine echo-dapp instance...

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Starting echo-dapp: ...............Traceback (most recent call last):
  File "/usr/bin/gunicorn", line 11, in <module>
    load_entry_point('gunicorn==19.9.0', 'console_scripts', 'gunicorn')()
  File "/usr/lib/python3.8/site-packages/gunicorn/app/wsgiapp.py", line 61, in run
  File "/usr/lib/python3.8/site-packages/gunicorn/app/base.py", line 223, in run
  File "/usr/lib/python3.8/site-packages/gunicorn/app/base.py", line 72, in run
  File "/usr/lib/python3.8/site-packages/gunicorn/arbiter.py", line 60, in __init__
  File "/usr/lib/python3.8/site-packages/gunicorn/arbiter.py", line 120, in setup
  File "/usr/lib/python3.8/site-packages/gunicorn/app/base.py", line 67, in wsgi
  File "/usr/lib/python3.8/site-packages/gunicorn/app/wsgiapp.py", line 52, in load
  File "/usr/lib/python3.8/site-packages/gunicorn/app/wsgiapp.py", line 41, in load_wsgiapp
  File "/usr/lib/python3.8/site-packages/gunicorn/util.py", line 350, in import_app
  File "/mnt/echo-dapp/echo.py", line 17, in <module>
    import sqlite3
ModuleNotFoundError: No module named 'sqlite3'
.....................................................................................echo dapp timed out

Halted
Cycles: 10520611714
Storing machine: please wait
machine: OK
make[1]: Leaving directory '/home/tienmanh/Documents/code/cartesi/rollups-examples/echo/server'
undefined says Did you try to import the sqllite3 module from an interactive session in python3 inside the Cartesi Machine? I'm trying to figure out if you are missing the python3 sqlite3 module or if it's a path issue.
undefined says Also you have an error in the end here before the Cartesi Machine halts: ```/usr/bin/python3: can't find 'main' module in '/'```
undefined says When i enter the interactive session in python3, and i ran command "import sqlite3", it returns "no module named 'sqlite3'". So i guess the problem is we do not configure the module sqlite3 in rootfs file system. But i don't see the relevant package when i configure the rootfs file. (I tried to find the library in Target packages -> Interpreter languages and scripting -> python3 -> External python modules)
undefined says Yes. I'm trying to figure out the answer for that problem.
undefined says **About SQLite in the default rootfs**

Hello @Albert Nguyen !
The SQLite is already installed in our default rootfs (version 0.9.0).

To check that, please run the following commands:
1. Run Cartesi machine in interactive mode:
make console 

2. Inside the cartesi machine, run:
find . -type f -name "*sql*"

3. It expected to have the following result:
./usr/bin/sqlite3
./usr/lib/libsqlite3.so.0.8.6
./usr/lib/lua/5.3/lsqlite3.so

Could you please check if you find the SQLite installation with these instructions and if your PATH environment variable is set correctly?

Any doubt please let us know!
undefined says Strange, that module should be default in Python. Are you running the Cartesi Machine on interactive mode from the rollups make console or from the playground image?
undefined says Hi @Cl√°udio !
I  tried running as your instructions but no result is showing (Please see image)
undefined says And I using echo example (the rollups make console)
undefined says Let me try to reproduce and get back to you üôÇ
undefined says Hello @Albert Nguyen !

The execution of "sqlite3 --version" was successful! So we proved that the sqlite3 is installed. ‚úÖ 

The find command did not work because Discord interpreted the asterisk as a formatting command. üòû  To finish this part of our analysis, please execute (remove backslash):

`find . -type f -name "\*sql\*"`

PS: We are checking the problem while importing the sqlite3 in your Python code, as Carlo said.
undefined says Hi @Cl√°udio ,

I tried the new command and it returns exactly what you expected.
undefined says Great @Albert Nguyen !
We continue analysing the import issue and I will give you a feedback soon.
undefined says Anyone know why I might be getting a "relation \"Notices\" does not exist" response when I request to get notices.
Perhaps I missed an obvious step. Same thing happens when I request epoch status.

On a forked branch:
https://github.com/souzavinny/rollups-examples/tree/main/calc#seeing-results-notices-and-more
undefined says That is a fork from one of the integrators, still under development. I suggest you use one of our stable releases instead (https://github.com/cartesi/rollups-examples). If you have trouble using one of those, share with us and we'll be glad to look into it.
undefined says Up to that point where you are, did you get any error on the logs?
undefined says Hello @glockchain , how are you doing? I will try to reproduce the steps for this error here. It might be something related to the running containers, maybe some cache on docker because if you see the log message it says the relation "Notice" doesn't at all. Let me ask you:
1 - did you give some inputs for the calculation backend?
2 - can you try to turn off all docker containers and restart to see if the problem persists?

I will be trying to reproduce this on my end and i let you know if i find anything.
undefined says Thanks, Carlo. No other errors up to this point. The original branch is fine as well.
undefined says Thanks, Marcus. Restarting my docker container fixed the issue. Thanks.
undefined says Hey everyone! I'm having trouble finding the roadmap/ where this project is at currently. Is there a rollup mainnet already? Or a testnet yet?
undefined says Sometimes other docker containers causes some kind of error of this nature üôÇ I'm glad it's solved. If anything happens be free to ask me üôÇ
undefined says We are progressively deploying and testing our rollups solutions modules. You can read an extensive article about the current development and next steps here: https://bit.ly/34IydQf
undefined says **Importing sqlite3 python module**

Hello @Albert Nguyen !
We already found the cause for the problem and will release a fix asap.
Stay tuned!
undefined says Got it, thanks! Sounds like an alpha version has been released but not yet mainnet. So I'm assuming theres no Cartesi alpha rollup explorer website yet? (like etherscan, arbiscan, etc.)
undefined says No, there isn't one yet. We currently only have an Explorer for Noether PoS (https://explorer.cartesi.io)
undefined says oh awesome, thanks for the help!
undefined says Sure, np üôÇ
undefined says Sure. That's great!
undefined says And, how about the issue related to the size of the notice content. Is there any updates? @Albert Nguyen
undefined says A fix will be deployed on a new version as well.
undefined says Awesome. I am excited for new version
undefined says **Rollups-examples release 0.2.2 was launched!** 

https://discord.com/channels/600597137524391947/615801550501314563/947795623221010472
undefined says Hi @Cl√°udio 

I have another issue related to sqlite3 when i trying to save data to cartesi machine
I implimented the code into the cartesi machine and it works fine.
I add the logic check : "if the table does not exists,  I will create a new table at the beginning of the function to ensure that the table exists"

But when i create new table, it returns the error with logs "database or disk is full". Although I check the free space of the machine (by make console and check), it still has free space.

Do you know why?
undefined says what is the location you are creating the sqlite database file?
undefined says @Albert Nguyen
undefined says https://medium.com/offchainlabs/introducing-anytrust-chains-cheaper-faster-l2-chains-with-minimal-trust-assumptions-31def59eb8d7  it seems Arbitrum is changing the way to take more market share.
undefined says can we interpret this as the Arbitrum way to solve the DA problem?
undefined says For some use cases, yes. The way I see it is more about reducing costs (and speeding up finality) under certain cooperation conditions.
undefined says Hello Guys, how are you doing? 

I've created and a Machine Learning example using Rollups in my repository here https://github.com/souzavinny/rollups-examples/tree/ml . 
In this example, we start with K-Nearest Neighboors solving an classic base (Iris) when we are learning Supervised Learning and the dapp also accept new inputs to make predictions.

Thanks for the support everyone. I will let you know when i put more DApps with Cartesi there üòâ
undefined says **database or disk is full**

Hi @Albert Nguyen !
If you created your SQLite project from our Simple Echo example, you must take a look at your build-dapp-fs.sh file (https://github.com/cartesi/rollups-examples/blob/main/echo/server/build-dapp-fs.sh).

There you will find the following:
``genext2fs -f -i 512 -b 16 -d $DAPP_FS $DAPP_FS_BIN``

The ``-b 16`` option is creating a 16 Bytes drive. Which is off course not enough space for a DApp with a database. üôÇ 

Try a more appropriate value for your DApp, for example: ``-b 1024``

Please let us know about any other problem!
undefined says Thank you. It works. üòÑ
undefined says Great!
undefined says Hello guys, how are you doing today?

I've done some small changes on my calculator example. Hope you guys enjoy it.

Feel free to ask me if anything about this example.

Cheers,
undefined says Hello. Anyone know what might be the cause of this issue?
undefined says Hello, how are you doing? I think this maybe can be some docker problem. Could you send the active docker containers here? just run docker ps -a. Sometimes this happens here when i build diferent projects. Also, cleaning docker, machines, etc could also help i guess.
undefined says 
undefined says Ahh. I see.
undefined says Issue still seems to persist whenever I call the addInput command. Even after rm docker containers. Still investigating.
undefined says could you send me here the full log when you turn on the docker container of the rollups?
undefined says 
undefined says There is something odd in this. This lines:
2022-03-05 15:03:32.829 UTC [178] ERROR:  duplicate key value violates unique constraint "InputResults_pkey"
database_1            | 2022-03-05 15:03:32.829 UTC [178] DETAIL:  Key (session_id, epoch_index, input_index)=(default_rollups_id, 0, 0) already exists.
database_1            | 2022-03-05 15:03:32.829 UTC [178] STATEMENT:  INSERT INTO "InputResults" VALUES ($1, $2, $3, $4, $5, $6, $7, $8);;
Are something related to database. In my DApps this doesn't happen. This also happens in the echo dapp?

I suggest you, maybe trying thins cleanning commands?

Cleans out the DApp folder
sudo make clean (in the folder of the DApp)
Clean existing exited docker containers
docker rm $(docker ps --filter status=exited -q)

Clean all the docker cache.
docker kill $(docker ps -q)
docker_clean_ps
docker rmi $(docker images -a -q)

Thats my cheat cheat for making really sure i'm not getting any cache from anywhere.
undefined says Hope this helps üôÇ
undefined says Still persists. Most likely related to something I have changed. Let me compare my directory to the echo and calc examples. and get back to you once I solved it.
undefined says Hi guys, we just finished our example. This example shows a simple book catalog DApp based on SQLite database running inside the cartesi machine. Here is my repository.
https://github.com/Sotatek-ManhNguyen3/cartesi_sqlite_poc
Thanks for your support. üòÑ
undefined says Whenever I launch my completely custom rollup example and send an input. I get this issue.
I've been reading through the indexer code in the rollups repo  trying to get an understanding as to what could be malforming/removing the session_id
Any clues what might be happening.
undefined says **Session id not found**

Hi @glockchain ! 
1. Did you created your project based on the echo example code?

2. Did you adapt the scripts for machine preparation (``build-dapp-fs.sh`` and ``build-machine.sh``) according your project?

3. Did you build the cartesi machine in the ``/server`` directory running ``make machine``?

Besides that I will check with our dev team any other clue about the error message you sent, ok?

Cheers!
undefined says https://github.com/TheExpandingPolytope/chess/tree/main/chessApp

Yep. Have done those things. Continuing to investigate. Thanks.
undefined says Can you please DM me the full docker compose logs?
undefined says Hello there, how are you doing today?

I've finished another DApp, this time i've replicated an example for predictor using logistic regression in the Titanic database, using Rollups. 
Using the m2gen tool I was able to convert a Python machine learning model with sci-kit, numpy and pandas dependencies into a pure Python function which runs smoothly inside the Cartesi Machine.
More Details about it see the repository bellow.
https://github.com/souzavinny/rollups-examples/tree/lr-titanic/lr

Thanks again for all the support.

Cheers,
undefined says Hi, I'm a full-stack and blockchain developer with rich experience in MERN-stack, Web3.js and Smart Contract. I'd like to take part in such cool crypto project. I do have some experience with NFT marketplaces, DEX and DeFi projects with web3 as well as smart contracts. If you have a role please DM me, Best regards.
undefined says Hi, how are you doing? We have multiple positions open (https://angel.co/company/cartesi/jobs) and also a funding program through Cartesi Labs to support software built with our technology (https://cartesi.io/en/labs/)
undefined says Not urgent, just out of curiousity. In the roadmap medium post, there's a mention about 'As we take our leap to Cartesi Rollups, implementing this arbitration system becomes slightly more complex' -- any insight in what exactly you're hitting of complexity?
undefined says Arbitration starts with two players that agree on the state of the machine at some point and disagree on the state of the machine after it has performed a computation. In the past, that computation was self-contained. Now, this computation is split into a bunch of smaller computations between which there is external input to the machine. Between two inputs, the smaller computation is self-contained like before, so if we know the last input before which the players agree, we can use the old approach to identify the cheater. The new approach therefore adds a stage that identifies that last input before which the players agree. It has this additional stage. Hence it is slightly more complicated. There are also additional concerns involved like the side effects on the blockchain (vouchers + notices).
undefined says yeah ok, makes sense üôÇ
undefined says **Check out our new release, new example, the DApp template script and updated doc**

üòâ üëá 
https://discord.com/channels/600597137524391947/615801550501314563/953293223831408650
undefined says The payload parameter in the inspect state request allows you to retrieve the results of a specific payload, correct?. But how would one request the entire state of the dapp at once?
undefined says The DApp developer decides what the payload of an inspect state means. So you could, for example, split the machine state into a bunch of pages. You can use a specific payload to inspect state that means 'give me the number of pages in the state' and another payload to inspect state that roughly translates to 'give me page <i> in the state'. Then you can use one call to find out the number of pages, followed by a bunch of calls to retrieve all pages or a subset of pages, each in a single report. What each page contains is also up to the DApp.
Generally the max report size should be about a couple of MB, so if your whole DApp state fits in there, you could deliver it on a single report.
undefined says Ok thanks. That makes more sense.
undefined says Np üôÇ
undefined says üëçüëçüëç on 'You can use [Gitpod](https://www.gitpod.io/) to immediately open this repository within a working development environment with all required dependencies', keep on making it easier to develop a dapp w/ Cartesi! This is the way to go.
undefined says We made this for the workshop at ETH Rio. The product team found it very useful to drastically reduce the setup time üôÇ
undefined says Hi. I'm trying to create a hello.py in Cartesi Machine and execute it. 
However, it seems vi editor in Cartesi Machine interactive mode have some unexpected behavior like:
1. when pressing on "i", it won't go into insert mode directly (00:19 in film), I need to hit "i" + "Enter" to go into insert mode (00:34 in film)
2. when pressing on "esc", it won't leave insert mode directly (01:13 in film), I need to hit "esc" + "Enter" to leave
3. Pressing on arrow keys will show some unexpected characters(something like ^[[A^[[B) and won't switch to other lines

Is there anything that I might missed out or done wrong? Thanks.
undefined says Hey @max.aetheras , well take a look at it and get back to you
undefined says @max.aetheras hey, you are using the playground image there, right? The version of the Cartesi Machine in there is not updated and does have a know issue related to this. If you use the ```make console``` command on the rollups-examples repository to start an interactive session with the Cartesi Machine, you should not have this issue.
undefined says @Carlo Thanks for your support!
The vi editor works fine in the the new Cartesi Machine in example repo.
undefined says Great! Let us know if run into additional issues üôÇ
undefined says Hi @Cl√°udio , I'm having some trouble with installing new package in the root file system. 

I'm currently building the trusted trip example, and i decided to use the `shapely` library of python to draw zone from list of points, with that library we can know whether a point is in the zone. I implemented that library and it works well in the backend code running in local. Now i want to push the code into the cartesi machine so i need to install the `shapely` library by create a new root file system. But i can not find that library.

How could i install that library for this example? Thanks.
undefined says when cartesi rollup chain launch?
undefined says If the shapely code is pure python and dont depend on other libraries i guess you have to do a pip install of it while building the build-dapp-fs.sh, move the library to the server folder and use it. But if it has more dependecies to it you have to check all those dependecies like this.
undefined says **Adding dependencies**

Hello @Albert Nguyen !
As @Marcus Vin√≠cius said, we recommend that you:
- add your dependency in `requirements.txt` file
- add a `pip install` in `build-dapp-fs.sh` file
- move the installation to the folder that will be used to create the drive for your DApp

Let us know in case you have other problems!
undefined says Thanks a lot, @Cl√°udio  and @Marcus Vin√≠cius . I'll try your suggestion.
undefined says btw you can probably relatively free get WASM compatibility with wasm3, i had that working on a cartesi machine a while back
undefined says **New examples are available**

Hello community!
Checkout our new examples on rollups-examples repo (https://github.com/cartesi/rollups-examples) !
A first one in C++ and two exploring the machine learning topic.
We would love to know your thoughts and comments about it!

https://discord.com/channels/600597137524391947/615801550501314563/958637914819026964
undefined says **WASM compatibility**

Hello @Carsten | Zippie !
I did not get your point. Are you just sharing that is possible to run WASM inside the Cartesi machine or had another goal?
undefined says yes, that you can run WASM files inside cartesi machine by porting wasm3 üôÇ
undefined says another one was to add Rust as a supported language, https://gist.github.com/stskeeps/c5ce732d17d02a9f99885e676131ba74
undefined says Great @Carsten | Zippie !
Thanks a lot for your gist! üòç 
Dully noted!
undefined says Hi @Cl√°udio , I follow your guide but still get errors when try to install the `shapely` library.

I using the m2cgen example to try to install shapely library (Just check if i can install the library or not). I added the line `shapely==1.8.1` into the requirements.txt in model file. Then i ran the command `make machine`. It seems to be fine. I can see the log that it successfully collect the `shapely` library.
undefined says 
undefined says I jump into the cartesi machine to check whether i can import that library (by `make console`, i can see the log `Requirement already satisfied` of the `shapely` library.
undefined says But when i try to inport that library, it throws error `Module not found`.
undefined says I think that you want to use the virtual environments (venv) to install library and to run the project inside the cartesi machine, is that right? I tried to use the virtual environments in the local and it works fine.

I go to `/mnt/m2cgen-dapp` folder in the machine, and i do not see .env folder (the folder that we install all necessary libraries). So I try to add that folder by add this command to build-dapp-fs.sh file: `cp -r ./.env $DAPP_FS` . And then, i run `make clean` and `make machine` to recreate the machine. It throws error.
undefined says I hope that you can show me what's wrong. Thanks!
undefined says ** Geofencing - Importing Shapely**

Hi @Albert Nguyen !

First of all, I checked the `Shapely` repo and I noticed that it depends on a C++ library called `GEOS`. When you install `Shapely` locally you are using a x86 binary for `GEOS` but you need a RISC-V binary to run inside the Cartesi machine. That said, just copying `Shapely` installation for the Cartesi machine drive will not work.

If you really want to use `Shapely` you will need to cross-complie `GEOS` for the Cartesi machine. Another solution is to find a another pure Python library that does the same. Ok?
undefined says Thank you. I will try to find another libraries.
undefined says **Geofencing - Picket**

Hi @Albert Nguyen ! I did a quick search and found Picket. Take a look and check if it do what you need. üòâ
https://github.com/sam-drew/picket
undefined says Hi! I'm experimenting with a simple 2-player turn based game, running in prod mode on localhost, but I'm having problems when testing frontend. It works fine most of the time (get _input_index from InputImpl.InputAdded event logs -> query GraphQL for notices produced for this input -> advance local state based on notices), but... every so many turns inputs get stuck until I f.ex. start new game in a separate terminal just to produce additional input - then GraphQL promptly gets notices for both the old missing input and the newer one. Simply waiting doesn't seem to work

Every time this happens, docker logs show lots of activity from <app>-rollup-dispatcher-1 related to main_loop:react offchain::logic::rollups_logic querying about closed and currents epochs. Any ideas what's going on? Is this some known issue with current version?
undefined says **Inputs get stuck**

Hi @sloPi !

1. Does the problem also occur when running in host mode? This mode make it easier to debug. üòâ 

2. My first hint would be to check if your logic is calling the `/finish` endpoint correctly (https://github.com/cartesi/openapi-interfaces/blob/master/dispatcher.yaml).

Please try this and call us if the problem persists!

Cheers!
undefined says It looks like a problem with rollups itself, not sure how host mode could help with that. The problem is not that some inputs never produce expected output -  the problem is that identical sequence of inputs sometimes work fine and sometimes get interrupted. To me it looks like whatever the dispatcher is doing interrupts processing of enqueued inputs (ones that were received by InputImpl contract but not yet propagated to the Cartesi machine) and they don't get processed until another input triggers the correct procedure
undefined says can you DM me your full docker logs so we can take a look?
undefined says Hey there, has anyone having issues with their Ledger Wallets logging into Cartesi Wallet for Staking?
undefined says What issue are you having?
undefined says I don't have this issue. All you have to do is keep clicking the metamask "connect" button. Metamask sometimes is not integrating well with Ledger and has some issues
undefined says Or maybe you need to upgrade your "ledger live" to the latest version.
undefined says **Inputs get stuck**

Hello @sloPi !

The suggestion about running in host mode was to enable you to debug in step-by-step way in your IDE so you can check the logic flow and etc.

Please send to Carlo by DM your full docker logs and we will take a look, ok?
undefined says Sure, already sent
undefined says **Inputs get stuck**

Hi @sloPi !
We reproduced the problem!
As soon as we have any news we will let you know, ok?
undefined says Hello,

I'm experimenting with a Cartesi rollups project similar to the "echo" Dapp from Cartesi examples.
It works against Hardhat on localhost as described in documentation and I'm sending notices with:
$ npx hardhat --network localhost echo:addInput --input 'Hello there!'
I see that the notices are received from account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" which is the default Hardhat account.
I found there is a list of additional Hardhat accounts (I can list them with "npx hardhat accounts" from another directory).
Is there an option to instruct Hardhat to use different account from the available ones when sending a notice to the Dapp?
Maybe some Hardhat argument passed on the command line or in the config file? I couldn't find a way to do this.
Can anyone advise?
undefined says I know it creates a certain number of test accounts. Not sure if selecting those is possible through arguments without changes  on some script. Will ask around and get back to you
undefined says Try passing `--account-index 1`, or `--help` for the options
undefined says Yes, it works with  `--account-index 1` , Thanks üôÇ
undefined says A conceptual question. Let me know if I am missing vital information. Any time you want to retrieve the state of your Cartesi Rollup instance you have to call a QueryInputs or InspectState transaction correct? Each of these calls are made to the L1 with potentially hefty transaction fees. As a dapp dev, what is the most optimal way to avoid making these base layer calls and query the state of your cartesi machine in real time. (Make a 3rd party server that calls InspectState intermittently, and have your dapp query from it? Have the cartesi machine itself make http calls to update a 3rd party server each time AdvanceState is called?)
undefined says You can query results of the computations in the graphql server embedded on the DApp node (and that has no costs nor transactions involved) and you can also use the inspect calls to query your app state (which comes inside the corresponding reports). Inspect calls also don't go through transactions (and also have no cost) but they have to be made directly to the server manager of the node (unlike regular inputs that go through the blockchain and other services before reaching the server manager).
undefined says About your last question, we have no plans on having such a hook, but we may think about something similar if there is demand for it (probably wouldn't be in the Cartesi Machine, but a new feature on the server manager).
undefined says Let me know if that explanation was enough, if you still have any doubts or if you want to go deeper on some point üôÇ
undefined says Ok perfect. Thanks alot for the answer. Makes sense
undefined says Np, feel free to ask any further doubts or discuss some other topic. Really nice seeing you experimenting with our rollups solution üôÇ
undefined says ‚ÑπÔ∏è  **Cartesi Improvement Proposals (CIPs)**

Hello!
Do you know that you can contribute to the improvement of Cartesi Rollups through our governance forum? üòâ

https://github.com/cartesi/cips/discussions

Please visit the page, check out the existing CIPs (Cartesi Improvement Proposals), participate in the discussion, and/or propose new ones.

Welcome!
undefined says **‚ÑπÔ∏è  New Cartesi Rollups release**

Hey everybody!
Cartesi Rollups release 0.2.0 is coming soon. üéâ 

Want to know what is coming? Take a look at our last Development Recap report on Medium (https://medium.com/cartesi/april-2022-development-recap-for-the-blockchain-os-d025f8bdf2d4).

Stay tuned! üòâ
undefined says Hi guys!

I want to use the `switch ... case ...` statements in python, and that statement is available from python 3.10. The default version of python in Cartesi Machine is 3.8. So, how could I change the version of python? Thanks a lot.
undefined says **change the version of python inside the Cartesi Machine**

Hello @Albert Nguyen !
You need to create a custom rootfs with the newer version.
Take a look at our documentation about it: https://cartesi.io/en/docs/tutorials/generic-script/custom-rootfs/

Cheers!
undefined says üöÄ ** Cartesi Rollups 0.2.0 and Cartesi Rollups Examples 0.5.0 are live now!**
undefined says For those who are testing right now: There is a new update which fixes the problem of docker and  .yalc files. (0.5.1) üöÄ
undefined says **‚ùì Upgrade to Cartesi Rollups 0.2.0**

Hello community!
Please react on how was it to upgrade your code to Cartesi Rollups 0.2.0?

üòç  - It was easy!

üèÉ‚Äç‚ôÇÔ∏è  - I am still on it

üòê  - I got stuck
undefined says I've only lost some good time in the yalc update actually (I was focused on code and didn't saw the update on time). The rest were well explained and straightforward. Nice job everyone.
undefined says What is the process of deploying a rollup instance to polygon mumbai. If possible yet.
undefined says It is but we don't have the instructions written down yet (under progress), so soon you can give it a try without having to do much guessing.
undefined says Yep. Did it earlier. Asked before trying.
undefined says Cool! Great to hear you were able to make it even without explicit instructions üôÇ If you have any trouble or feedback, let us know!
undefined says ‚ÑπÔ∏è  **Rust example**

Hello community!
A Rust example is coming.
Stay tuned! üòâ
undefined says Hi guys. I'm developing a DApp using python3. And I need to get the current time by this code `datetime.datetime.now()` But, it seems like it always returns the first day of 1970. Does anyone know how to fix this? Thank you.
undefined says You‚Äôd have to include the date in the input, as the machine is incapable of syncing time itself
undefined says (The computation would not be repeatable if so)
undefined says @Albert Nguyen as @dyed says there is no reliable wallclock time inside the Cartesi Machine as it's something that wouldn't make it deterministic. You should use the time coming from an input as @dyed suggested, but in a different way. When you receive an input, there is some metadata that comes along with it (like the sender address) and the blockchain timestamp of that input is one of them. The blockchain timestamp is reliable, if a user would provide the timestamp/datetime as part of the input payload, it could introduce a vulnerability on your DApp as the user has the power to manipulate it, unlike the blockchain timestamp.
undefined says Oh, I see. Thank you. I'll use the timestamp in the metadata instead.
undefined says hey guys. i am wondering how tied are we to python? how easily can we exchange "modules"? (by module i mean the frontend/backend parts mentioned in dapps architecture)

I am wondering about using react as frontend, node as data processor (instead of python we are using)

I am just starting to wrap my head around cartesi examples from https://github.com/cartesi/rollups-examples/tree/main/echo 

has anyone tried or thought about doing something similar?
undefined says **how tied are we to python?**

Hello @Aleksander ! Welcome!
Cartesi Rollups is not tied up to Python. You can develop your DApps using:
- C++ (https://github.com/cartesi/rollups-examples/blob/main/echo-cpp)
- Lua
- Rust (we will provide an example in the next release)
- JavaScript

Python was used for the first examples because is one of the top used programming languages, is portable to RISC-V architecture and has good performance running inside the Cartesi Machine. üòâ
undefined says **how easily can we exchange "modules"?**

@Aleksander , you can develop your React frontend and have a Python/C++/Javascript backend.

After the launch of Cartesi Rollups 0.2 you don't need a http server (provided by NodeJS for example) to run you Javascript backend code anymore. It became simpler to run JavaScript code in the backend.

Take a look at QuickJS (https://bellard.org/quickjs/) which is the JavaScript runtime environment that is provided inside the Cartesi Machine.
`QuickJS is a small and embeddable Javascript engine. It supports the ES2020 specification including modules, asynchronous generators, proxies and BigInt.`
undefined says We have dived a bit into quickjs and it seems like it doesn't support http client out of the box. I believe, we would need HTTP post to `/finish` to get desired result: 
https://github.com/cartesi/rollups-examples/blob/1c039fe195ad099e0e6ae50a44698880453f8f03/echo/server/echo.py#L47

Guessing the answer to this would be to use http client like axios or similar. Is that the desired approach?
undefined says Hey! Yeah, it doesn't. It has a urlGet method that wraps curl to fetch, but no POST support AFAIK (https://bellard.org/quickjs/quickjs.html, search for urlGet). This guy made something similar to that to support other methods (like POST): https://www.youtube.com/watch?v=kSl1tf95284
You might want to go the same route or try using some other library.
undefined says So, yeah! I was also looking at this guy and wanted to know, because axios seems like something that might just do it (and it's kinda popular in JS). https://www.youtube.com/watch?v=XVKR-Bur1v8 
I think we'll try to give it a spin and let you guys know. We've done a rewrite in RUST to play with 2.0, but didn't manage to build in `--production` mode. Doing it under private repos. Should we add those to the official examples as PRs, or this would just blur the repo?
We can have them in private, or make a public under our org (wchfs). 
Any guidance if we develop new examples?
undefined says making a PR on the public rollups-examples repo is fine üôÇ (https://github.com/cartesi/rollups-examples)
undefined says so a cartesi smart contract is directly connected too the front end (javascript react etc) and completely takes the place of a traditional server backend?
undefined says so would the front end be SSR?
undefined says Hi, I've look through the 0.2 version of https://github.com/cartesi/rollups-examples/blob/main/echo/server/build-machine.sh.
What is the "rollup-init" in the last line of the script?
Is it still needed if I want to run Rust binary instead of python file?
undefined says ‚ùì **What is the "rollup-init"**

Hello @max.aetheras !
This script runs the HTTP API, waits until it is ready, and only then runs your application.
So it is necessary independently of the chosen language for your DApp's backend code. üòâ
undefined says ‚ùì **Frontend, Backend and smart contracts**

Hello @SeventhWard76 !
Here comes a diagram that shows the typical architecture of a Cartesi Rollups DApp.

Please let me know if this help you understand the relation between the components or any other doubt or comment that you have. üòâ
undefined says The dapp front-end from this diagram can be setup anywhere on the `traditional` hosting, correct? S3, digitalocean etc or even locally on the regular computer.
undefined says Yep, the front end can be exactly this way üôÇ
undefined says So would HTML code be rendered ‚Äúserverside‚Äù on the cartesi machine and delivered that way. Would that mean that with every interaction on the frontend you‚Äôd need to interact with the blockchain
undefined says No, not everything on a DApp needs to be executed on a trusted environment. Generally speaking, user interface is something that can be dealt with without interference of the part of the DApp running inside the Cartesi Machine. Just to give you an example: on our tower defense game, Creepts, the whole game would execute on the user browser and the difference from a "regular" implementation is that all the player interactions were logged and submitted to the blockchain along with the claimed score. When that happened, nodes interested on that result would retrieve the movements log and feed it to the Cartesi Machine, where the game simulation logic would replay the game and check the claims were correct, triggering a dispute in case they weren't.
undefined says So rendering the game, navigating through the game menus, etc were all things that didn't need intervention from the Cartesi Machine, the point that demanded verifying the correctness of the execution was just the game simulation itself.
undefined says The part of the logic that demands verification or not varies from DApp to DApp and also on the DApp requirements
undefined says (certain parts of a DApp can be moved inside or outside of the Cartesi Machine depending on the trust model and other requirements)
undefined says Hello!
I am developing an DApp using the Cartesi Rollups and it everything was working fine until I decided to make an update to Cartesi Rollups version 0.2.
The problem is that after the update the back-end receives an empty payload, even though I am sending data. I managed to talk with a Cartesi member in private (Thanks for your time Carlo!), and as suggested, I am now using the localhost.json file that is generated when the Hardhat container is started, this should prevent any problem related to address and ABI of the contracts. But, even after this change the error persists.

So, I decided to do an test, I made an simple program that uses the Web3.js to send an input to the Cartesi Rollups and because I was afraid that the problem could be my application I tested it with the echo example too. The result was that I got the same error/behaviour in both applications. While running this test I could observe some things:
undefined says 1) After calling the addInput method from the InputFacet contract I get the following error.

Error: Returned error: Error: VM Exception while processing transaction: reverted with reason string 'input len: [0,driveSize]'
    at Object.ErrorResponse (/home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/web3-core-helpers/lib/errors.js:28:19)
    at /home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/web3-core-requestmanager/lib/index.js:302:36
    at XMLHttpRequest.request.onreadystatechange (/home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/web3-providers-http/lib/index.js:98:13)
    at XMLHttpRequestEventTarget.dispatchEvent (/home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/xhr2-cookies/dist/xml-http-request-event-target.js:34:22)
    at XMLHttpRequest._setReadyState (/home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/xhr2-cookies/dist/xml-http-request.js:208:14)
    at XMLHttpRequest._onHttpResponseEnd (/home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/xhr2-cookies/dist/xml-http-request.js:318:14)
    at IncomingMessage.<anonymous> (/home/arthur/Documents/cartesi/iot_rollups_dapp/front_end/node_modules/xhr2-cookies/dist/xml-http-request.js:289:61)
    at IncomingMessage.emit (events.js:412:35)
    at endReadableNT (internal/streams/readable.js:1333:12)
    at processTicksAndRejections (internal/process/task_queues.js:82:21) {
  data: {
    txHash: '0x8148d38141c451849a5a59a07fee98d8960790dfff2b2ee01e08c5c12551a58e'
  }
}

Looks like this error is the cause of the empty payload, but I don't know what is causing it.
undefined says 2) I was able to call the method getCurrentEpoch from the RollupsFacet contract without any problem.
undefined says 3) I noticed that the field "msg_sender" of the data that gets to the back-end is different from the one that called the addInput method, is this behaviour expected? I remember that in the previous version the "msg_sender" was the same.
undefined says If there is anything that I can provide that could help understand this error, just let me know. I can post the program that I used to test if needed too.
undefined says Got the same error this morning.
Adding an override option to the contract function call to specify gas fixed this for me.
addInput(input, overrides)
undefined says let overrides = {
            gasLimit: 23000,     
            gasPrice: ethers.utils.parseUnits('9.0', 'gwei'),   
            nonce: 123,     
        };
undefined says I will try it as soon as I can.
Thank you üôÇ
undefined says Hi @Cl√°udio , there are some docs need your confirmation so please check out our slack group chat.
undefined says Hi, @Cl√°udio is somewhere available some "public rollup" or "public address" where I can check the communication between my simple frontend UI and Rollup? It would be really great stuff for me to see a simple example of communication between frontend and rollup without having to make my own backend
undefined says Hey @Arthur Vianna @glockchain In the recent Rollups version 0.2 Cartesi introduced a diamond pattern that changes the way you interact with on-chain contracts. Now you've to connect to a diamond contract called "CartesiDApp" that acts like a proxy to other contracts(facets to the diamond). The facets contain the actual implementation.
Can you share the code in which you're trying to connect with the contracts? That way I can assist you better.
undefined says If you're interested on how diamond pattern works check out this article https://dev.to/mudgen/understanding-diamonds-on-ethereum-1fb
undefined says When you are running your DApp on a private local node (hardhat) you can check the hardhat logs for the transactions that are submitted (in case you want to understand if the transaction went through). We'll soon release an example of a simple web front-end but we have had a CLI one available for a while: https://github.com/cartesi/rollups-examples/tree/main/echo/frontend-console
undefined says Not sure if that is what you wanted, please let me know if it was something else.
undefined says Thank you for your answer, I will wait for this web example. CLI from my perspective isn't close enough to what I looking for. Please, let me know when you publish this web frontend example
undefined says Sure, will do üôÇ
undefined says Thanks for the help Shaheen, I didn't knew this pattern. After reading the article I manage to make my little test work. But I will post the code anyway, so if you have any observations about it, let me know.

```
const Web3 = require('web3');

const provider = "http://localhost:8545" // node running Hardhat
const web3 = new Web3(Web3.givenProvider || provider);


const hardhat = require("./public/ABI/localhost.json")
const rollups_contract = new web3.eth.Contract(hardhat.contracts.RollupsFacet.abi, hardhat.contracts.CartesiDApp.address)
const input_contract = new web3.eth.Contract(hardhat.contracts.InputFacet.abi, hardhat.contracts.CartesiDApp.address)

// web3.eth.defaultAccount = ... // to set a default "from" parameter
web3.eth.getAccounts()
.then(function(result) {
    accounts = result

    console.log("Account:", accounts[0])
    rollups_contract.methods.getCurrentEpoch().send({ from: accounts[0] })
    .then(function(result) {
        console.log("Current Epoch:", result)
    })
    .catch(function(error) {
        console.log(error)
    })

    // Echo DApp input
    const input_hex = "0x63617274657369"

    input_contract.methods.addInput(input_hex).send({ from: accounts[0] })
    .then(function(result) {
        console.log("addInput:", result)
    })
    .catch(function(error) {
        console.log("AddInput", error)
    })
    
})
.catch(function(error) {
    console.log("Error: Couldn't get accounts list!")
});

```
undefined says From what I understood I should instantiate the contract that I want to use (in this case the InputFacet and RollupsFacet), using it's ABI but the CartesiDApp contract address istead of the address of the contract that I want to use. Is my understanding correct?
undefined says You got it right! The code seems to be making the right connection as well.
undefined says Hi, in the previous version of the Cartesi rollup, we can send reject status to trigger a roll back, 
how can we do so in 0.2 version?
undefined says Same thing, when you call the /finish endpoint you provide either an "accept" or "reject" to it and in case of providing a "reject" the input is discarded and the Cartesi Machine rolls back. The difference is that the /finish endpoint now also returns the next input to process when it's available.
undefined says Oh I got it, if the case need to rollback, we'll call /finish with a reject status next time
undefined says Yes, exactly üôÇ
undefined says Thanks for the response
undefined says Hi, I've migrated my dapp to Cartesi Rollup 0.2, and tested it successfully on host mode.
However, I cannot start it up properly on prod mode.
rollups_indexer will keep restarting and fail.

Below is some error log:
```
2022/05/25 09:45:16 Waiting for: file:///opt/cartesi/share/blockchain/localhost.json

2022/05/25 09:45:17 File file:///opt/cartesi/share/blockchain/localhost.json had been generated

2022/05/25 09:45:17 Waiting for: tcp://state_server:50051

2022/05/25 09:45:17 Waiting for: tcp://server_manager:5001

2022/05/25 09:45:17 Connected to tcp://server_manager:5001

2022/05/25 09:45:17 Connected to tcp://state_server:50051

2022/05/25 09:45:17 Waiting for: tcp://database:5432

2022/05/25 09:45:17 Connected to tcp://database:5432

Error: TonicStatusError { source: Status { code: Aborted, message: "concurrent call in session", metadata: MetadataMap { headers: {"content-type": "application/grpc"} } } } 
```

```
cartesi-dapp-server_manager-1      |   Getting initial config
cartesi-dapp-server_manager-1      |   Checking tx buffer buffer config
cartesi-dapp-server_manager-1      |   Checking rx buffer buffer config
cartesi-dapp-server_manager-1      |   Checking input metadata buffer config
cartesi-dapp-server_manager-1      |   Checking voucher hashes buffer config
cartesi-dapp-server_manager-1      |   Checking notice hashes buffer config
cartesi-dapp-server_manager-1      |   Reading machine current mcycle
cartesi-dapp-server_manager-1      |   Checking machine is yielded
cartesi-dapp-server_manager-1      | Throwing from server-manager.cpp:1411 at uint64_t check_is_yielded(async_context&)
cartesi-dapp-server_manager-1      | Caught finish_error_yield_none expected manual yield
cartesi-dapp-rollups_dispatcher-1  | Error: TonicStatusError { source: Status { code: InvalidArgument, message: "expected manual yield", metadata: MetadataMap { headers: {"content-type": "application/grpc"} }, source: None } }
```
undefined says Hi, I've a problem with compiling rust program to cartesi risc-v binary.
Program compiled by `cross` (`cross build --target riscv64gc-unknown-linux-gnu --release`) throw me a problem:
 ```
./rust-executable: line 1: ELFÔøΩxÔøΩ: not found
./rust-executable: line 2: @ÔøΩÔøΩ@8: not found
./rust-executable: line 3: syntax error: unexpected "("
```
AFAIK kerner don't recognize this file as binary but as usual text shell script file.
Am I compiling rust program in proper way?
undefined says Sorry, my mistake - I executed file in wrong way üò´ 

But I still have a question:
> Am I compiling rust program in proper way?
undefined says Another question: Why shell throw me `not found` problem?
```
cartesi-machine:/mnt/echo-dapp # ls -al
total 13202
drwxr-xr-x    3 root     root          1024 Jan  1 00:00 .
drwxr-xr-x    3 root     root          1024 Jan  1 00:00 ..
-rwxr-xr-x    1 root     root      13444336 Jan  1  2022 echo-server
drwx------    2 root     root         16384 Jan  1 00:00 lost+found
cartesi-machine:/mnt/echo-dapp # ./echo-server 
/bin/sh: ./echo-server: not found
cartesi-machine:/mnt/echo-dapp # 
```
undefined says run a 'file' on it, chances are you'll find it points to a ld-linux that's not the right architecture/path
undefined says Can you DM me the full docker-compose logs?
undefined says @wch-karol-p | webchefs as @Carsten | Zippie pointed, that's probably because the target architecture is incorrect. Let me check internally about a Rust DApp example and provide it to you guys so you can check if the used architecture matches.
undefined says also i don't think cartesi machines do riscv64**gc**-unknown-linux-gnu yet
undefined says Are inspect state calls currently supported?
undefined says Also. Will dapp developers have to poll the graphql server or will websockets be supported.
undefined says For the moment, polling is necessary. That might change in the future.
undefined says Yes, but they are somewhat cumbersome to use atm. They're undergoing changes so that they are easier to use and also usable on the regular flow of a DApp instead of being focused only on debugging during development
undefined says Are there any chances to include `curl` into cartesi machine?
We want to make `HTTP POST` request using Quick JS to send data  with `fetch` quickjs polyfill by using curl under the mask
undefined says **‚ùì Include `curl`  in the rootfs**

Hello @wch-karol-p | webchefs !
The root file-system (rootfs) contains all data files and programs that make up an embedded Linux distro. We focus on keep it as light weight as possible.

Specific needs about other programs can be solved by creating a custom rootfs or an extra file-system for your DApp's needs. We used the second option on our examples. Taking the Simple Echo example as reference, you can check its script for creating a file system for this DApp: https://github.com/cartesi/rollups-examples/blob/main/echo/server/build-dapp-fs.sh

Creating a custom rootfs or a DApp file system, you will need to cross-compile `curl` for the RISC-V architecture to run inside the Cartesi Machine. The following article can bring useful information about this: https://medium.com/cartesi/guest-post-how-opencv-cross-compiles-in-the-blockchain-os-79a9eba6108b

Cheers!
undefined says Hey Claudio. We were thinking of lowering entry barriers for javascript devs, and to do that. QuickJS should allow making post request to endpoints like `/finish` etc. We have qjs available in the machine, but in order to actually use it with RF you need to make the http request. You CANNOT do it, because this is not supported by quickjs by default, effectively we think that adding `curl` + implementing axios (https://www.youtube.com/watch?v=XVKR-Bur1v8) is vital for javascript to run. Without `curl` quickJS is not really usefull (yet included). Unless we are missing something and there is a way to do it.
undefined says hey guys! 

I am during my onboarding period and have some questions regarding this https://docs.google.com/document/d/1kxNqqHTCkRgv8ouRxWp-e8Bxih8gOHqpKcXdSasK5EQ/edit# instructions:

1. Simple Echo Rollups Example / a. / ii.  - I was wondering about correct localhost/notice call to test shape (data, headers, etc). I did something like you can see in *1 attachment*. I could confirm from console feedback that the endpoint gets some request. *Was there something else I should do at this point?* (mostly wondering about mimicking adding input or whatever was placed in echo example instructions)

2. As much as instructions before were pretty clear for me to follow I got lost on Cartesi Machine's checkpoint. For now I just search for keywords from docs like 'site: www.cartesi.io interactive mode' through Google. I am following this https://cartesi.io/en/docs/machine/host/overview/ for this 2nd point. Though this makes it a lot more confusing as I do guess-working. From instruction point I was wondering if I should get my own Linux OS on some VM software or do it some other way (since running preperation script on anything other than Linux shouldn't work if I understand Cartesi Machine correctly). So question here is: *is what I am following from the link above is what doc author had in mind? *

Also general question for checkpoints 3,4,5 - *should I follow the same logic as in point 2. to get through this checklist?*


It all seems a little bit harder than it should. I am asking the other guys who went through that onboarding - what do you think?
undefined says **‚ùì Include `curl` in the rootfs**

Hi @wch-kamil-z | webchefs !
I got your point. Let me check with our team.
undefined says I've built my own `rootfs` with `curl` using `emulator-sdk` and  now I receive that `rollup-init`  is not found
```
cartesi-machine:/ # rollup-init
/bin/sh: rollup-init: not found
```
undefined says ‚ùì **Include `curl` in the rootfs**
Hi @wch-karol-p | webchefs !
What was the proceeding you followed to build your custom `rootfs`?
undefined says https://cartesi.io/en/docs/machine/host/overview/
`It can be built in the fs/ directory in the Emulator SDK`
Then I cloned and setup this repo https://github.com/cartesi/machine-emulator-sdk
Then I go to `fs` dir and run `make config`  - like a couple months ago. 
But when I read more carefully `Makefile` I spotted that I should not execute this command but `make fs` instead.
Thanks for fast answer and for remind me about the procedures üôÇ
I'm making a lot of experiments üôÇ
undefined says Hey @wch-karol-p | webchefs! I suggest you follow this tutorial for making a custom rootfs from Descartes (just need for you to make a change, and use the updated images on the step-by-step instructions): https://cartesi.io/en/docs/tutorials/generic-script/custom-rootfs/#building-a-custom-root-file-system
undefined says Mark curl under the buildroot tool when you do the ```make config```
undefined says with the updated images, the rollups infrastructure will be included on the rootfs and you won't experience this issue
undefined says Hi! Cannot access the url you provided (unauthorized)  but assuming it'sour onboarding document for the Cartesi Rollups and that **you are using version 0.1 of the cartesi rollups** :

1) So the test should be performed in host mode (that is, the "backend" code is not running inside the Cartesi Machine, but locally on your host. When you do that, you'll have the application service exposed to your host and you can use insomnia, postman or any other HTTP client to test it directly. About the shape of the request, the rollups framework puts some headers that are useful for the application since it doesn't have access to the external world when running inside the Cartesi Machine, you can inspect those by making a call to add an input through the blockchain. When running locally with hardhat as the blockchain, you can use one the helper scripts included in echo like described on the README-https://github.com/cartesi-corp/rollups-examples/tree/feature/chess/echo#interacting-with-the-application: ```$ npx hardhat --network localhost echo:addInput --input "0x63617274657369"```
undefined says Those headers include things like the timestamp of the input (as there is no reliable wallclock inside the Cartesi Machine since it has to be reproducible) and also the address of the sender of the input
undefined says About the payload, the rollups framework treats all data as "binary" and the only requirement is that it's hex encoded, which is the common format used in Ethereum transactions. Once again you can take a look at the Echo example on how to decode/encode data from that format. Inside this "binary" payload you can set your own conventions about what the data represents: you can encode your data in JSON or whatever custom format you'd like that makes sense for your application. The calculator example, for instance, uses JSON, so you might want to take a look at it.
undefined says About point 2:
Those tasks are meant for you to get acquainted with the Cartesi Machine. You don't have to install Linux on your computer, create a VM or anything, but you do need Docker. The Cartesi Machine is a VM itself and runs Linux inside of it. Following our documentation, the way you'll run the Cartesi Machine in interactive mode is inside a Docker container, so that you don't need to worry about installing the correct environment with all the dependencies and getting the compilation of the Cartesi Machine right.
undefined says When your DApp code runs inside the Cartesi Machine it's pretty much isolated, a bit like when you run code inside an embedded device, so it's hard to figure out what's going on, if you are missing a file needed for your program to run correctly, you are missing some dependency or something else. That's why we have the interactive mode, so that you can get inside the Cartesi Machine and inspect/test whatever you want and figure out things much faster.
undefined says About the onboarding in general (including points 3,4 and 5 of the checklist), the objective is for you to understand what are the interfaces of the Rollups framework, the parts of it, how they interact with the parts of the DApp that you write as a DApp developer, what's the information flow and how do you check the data going through the framework. Also as the Cartesi Machine is the runtime environment for the trusted computing part of your DApp, the onboarding process has a lot of focus on getting familiar with it and how to port things to it (cross-compiling code, porting dependencies, etc) and also on how to figure out what's going on inside of it and debugging your code.
undefined says Whenever you have some doubt (practical or conceptual), just write it here and we'll do our best to get it sorted out üôÇ
undefined says Also, one important thing: the current version of the Rollups framework (0.2) has important changes, the main one is that the code you write to execute inside the Cartesi Machine is no longer a server (handling requests to /advance and /inspect) and a client (making requests to /finish, /notice, /report). Now it's just a client: when you call /finish it does 2 things: accepts/rejects the last processed input and yields until a new request was made to your DApp, returning in the response the new input/inspect details for your DApp to process.
undefined says @wch-karol-p | webchefs DMed you a preview of the rust echo example so you can take a look at the target when cross-compiling the app
undefined says @max.aetheras from the logs you DMed me seems like the Cartesi Machine has not yielded when it was created. Can you check the outputs of creating the machine?
undefined says Here is the log for creating our machine:
```
‚îóÔÅî make machine                                                                                
Building cartesi-machine dinder-cartesi-dapp-dapp instance...

Cycles: 0
0: a0a0028157f03239da0681b6230402ccf09394b0f6b8e6f862b5804cfd00c437
Storing machine: please wait
machine: OK
```
undefined says @Carlo 
And below is our build-machine.sh: 
```
MACHINE_DIR=/opt/cartesi/dinder-cartesi-dapp-machine
ROLLUP_HTTP_SERVER_PORT=5004
DAPP_PORT=5003

cartesi-machine \
    --ram-length=128Mi \
    --rollup \
    --flash-drive=label:dinder-cartesi-dapp-dapp,filename:dinder-cartesi-dapp-dapp.ext2 \
    --flash-drive=label:root,filename:rootfs.ext2 \
    --ram-image=linux-5.5.19-ctsi-5.bin \
    --rom-image=rom.bin \
    --max-mcycle=0 \
    --final-hash \
    --store=$MACHINE_DIR \
    -- "cd /mnt/dinder-cartesi-dapp-dapp; \
        ROLLUP_HTTP_SERVER_URL=\"http://127.0.0.1:$ROLLUP_HTTP_SERVER_PORT\" \
        rollup-init ./dinder-cartesi-dapp mono &"
```
undefined says I'm not sure if ```max-mcycle=0``` the reason that the Cartesi Machine has not yielded when it was created?
undefined says wondering if someone had problem building frontend-console from echo
undefined says the above is related to
undefined says I think - I have recent git pull, even cleared the ^ from package.json to be sure I am running the correct packages setup
undefined says Probably. The machine should be stored when yielding during creation. If you set the machine cycle to 0, it's stored even before starting to boot Linux
undefined says which version are you building?
undefined says Hi, I have some questions.
How do I run a Cartesi Node and participate in the execution of an application? Is this already possible today?
Is it as described here: https://medium.com/cartesi/running-a-node-and-staking-42523863970e ?
Is a Noether Node a Cartesi Node from Cartesi Rollups?
undefined says Hi @Aswage . No currently they are different nodes. ATM we have a node per Cartesi DApp (so validators just validate the DApps they wish to - they do not download Cartesi Machines of DApps they are not concerned with, etc). We might unify those in the future, but it's something actively under discussion.
undefined says @Carlo 
I've removed max-cycle=0 from build-machine.sh,  below is the log we re-run ```make machine```:
```
‚îóÔÅî make machine                                                                                   ÓÇ≤ ÔÄå ÓÇ≤ 227 ÓÇ≤ 6.73G ÔÉ§ ÓÇ≤ 10.44 ÔÇÄ  ÓÇ≤ 11:24:25 ÔÄó 
Building dinder-cartesi-dapp-dapp filesystem...
Running as root
copying from tar archive /opt/cartesi/dinder-cartesi-dapp-dapp-fs/dinder-cartesi-dapp-dapp.tar
dinder-cartesi-dapp-dapp.ext2: OK
Building cartesi-machine dinder-cartesi-dapp-dapp instance...

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '


Halted
Cycles: 85632801
85632801: b176d40d307fa597352eab19ab7b0e6bddb070a130c9732c9af67e7a8c4692d9
Storing machine: please wait
machine: OK
```
undefined says Does the ```Halted``` means that the machine has yielded in the creation process?
undefined says Besides, we still get "finish_error_yield_none" error when we starting dapp on Cartesi rollup in production mode:
```
cartesi-dapp-server_manager-1      | Throwing from server-manager.cpp:889 at new_GetSessionStatus_handler(handler_context&)::<lambda(boost::coroutines2::coroutine<side_effect>::push_type&)>
cartesi-dapp-server_manager-1      | Caught finish_error_yield_none concurrent call in session
cartesi-dapp-rollups_indexer-1     | Error: TonicStatusError { source: Status { code: Aborted, message: "concurrent call in session", metadata: MetadataMap { headers: {"content-type": "application/grpc"} } } }
```
undefined says no, means it halted
undefined says it will yield when you call the /finish endpoint (for version 0.2 of the Cartesi Rollups)
undefined says @Carlo I think I found out why...I removed the "&" from the last line of build-machine.sh and it yielded
```
‚îóÔÅî make machine                                                                                   ÓÇ≤ ÔÄå ÓÇ≤ 232 ÓÇ≤ 4.43G ÔÉ§ ÓÇ≤ 78.96 ÔÇÄ  ÓÇ≤ 11:57:04 ÔÄó 
Building dinder-cartesi-dapp-dapp filesystem...
Running as root
copying from tar archive /opt/cartesi/dinder-cartesi-dapp-dapp-fs/dinder-cartesi-dapp-dapp.tar
dinder-cartesi-dapp-dapp.ext2: OK
Building cartesi-machine dinder-cartesi-dapp-dapp instance...

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Starting rollup-http-server: 
.[1970-01-01T00:00:00Z INFO  rollup_http_server] starting http dispatcher service...
[1970-01-01T00:00:00Z INFO  rollup_http_server::http_service] starting http dispatcher http service!
[1970-01-01T00:00:00Z INFO  actix_server::builder] Starting 1 workers
[1970-01-01T00:00:00Z INFO  actix_server::server] Actix runtime found; starting in Actix runtime
Rollup http server started

Starting dapp:  ./dinder-cartesi-dapp mono[DBG] 1970-01-01 00:00:01 rollup_server url is : http://127.0.0.1:5004
  cartesi::mono::service|bin/cartesi/src/mono/service.rs:394
[DBG] 1970-01-01 00:00:01 Sending finish
  cartesi::mono::service|bin/cartesi/src/mono/service.rs:395
[DBG] 1970-01-01 00:00:01 Call to Http Dispatcher: Finishing
  cartesi::mono::http_dispatcher|bin/cartesi/src/mono/http_dispatcher.rs:71
[DBG] 1970-01-01 00:00:01 status_value: accept
  cartesi::mono::http_dispatcher|bin/cartesi/src/mono/http_dispatcher.rs:75
Manual yield rx-accepted (0x100000000 data)
Cycles: 192741867
192741867: 80388ef43aa0802025b8c0156176f2ee56bf3397353b47ed5d5b76bf7acac160
Storing machine: please wait
machine: OK

```
undefined says Great üôÇ This looks like a properly initialized Cartesi Machine output
undefined says Thanks. seems the "&" makes it runs in background and makes trouble in 0.2 version.
I'll continue on trying production mode
undefined says It works well on production mode now:
```
cartesi-dapp-hardhat-1             | eth_getBlockByNumber (2)
cartesi-dapp-hardhat-1             | eth_blockNumber
cartesi-dapp-server_manager-1      | Received GetVersion
cartesi-dapp-server_manager-1      | Received GetStatus
cartesi-dapp-server_manager-1      |   default_rollups_id
cartesi-dapp-server_manager-1      | Received GetSessionStatus for session default_rollups_id
cartesi-dapp-server_manager-1      |   0
cartesi-dapp-server_manager-1      | Received GetEpochStatus for session default_rollups_id epoch 0
cartesi-dapp-state_server-1        | Got a request from Some(192.168.0.8:33646), initial state: ["0x0","0xc3e53f4d16ae77db1c982e75a937b9f60fe63690"]
```
undefined says I've just created PR with Javascript version of python echo. 
It requires a curl in `rootfs` (which I've included to custom one using tutorial mentioned by @Carlo)
https://github.com/cartesi/rollups-examples/pull/13
undefined says Hi guys, I just finished another DApp using Rollups. This is the simple version of a voting system. The system will receive the voting request, validate and increase or decrease the number of votes following the requests. Each person can only vote for 1 candidate, and can vote only 1 time. If the user sends another vote request, that request will be denied. (The candidates will be fixed)
We updated the rollups version in the code to 0.2.0 and using sqlite to store the voting data.

The detail of the code will be in the repository bellow.
https://github.com/Sotatek-ManhNguyen3/cartesi_voting_system

If you have any feedbacks, feel free to let me know.

Cheers.
undefined says When cartesi Dex?
undefined says You guys are launching a Dex?
undefined says @android fixer @GoofyNinja as we said a couple of times, our focus is on building the Cartesi platform and developing the environment, not building/maintaining products like a DEX, game or some other final user application. If you are interested on developing a DEX or some other interesting DApp using Cartesi, we encourage you to apply on Cartesi Labs so we can provide you technical and/or financial support üôÇ
undefined says Kk if you want common  users and them to talk about the project make it well known  to show the potential of scalability , easability  Dex is a good start
undefined says Hi, I've tried to run Cartesi Rollup on local node, and call the ```addInput``` function of InputFacet contract to send inputdata through Metamask.

However, the transaction failed with message: Error: VM Exception while processing transaction: reverted with reason string 'input len: [0,driveSize]'

I've looked through https://github.com/cartesi/descartes-v2/blob/d0ba2c459d9484a1e0240f286d55ce42f28c3572/contracts/InputImpl.sol#L48 (not sure if it is the right place to look)
and found that there is a limit that input data length must smaller than size of input flashdrive.

Any suggestion for solving this error?
undefined says Hey Max, it seems like a familiar issue. Could you share the code snippet where you're trying to make connection with the `InputFacet` contract?!
undefined says **üßê  Simple voting system review**

Hello @Albert Nguyen ! Thanks a lot for your contribution!

I liked a lot the way you structured your code: having two services to keep the responsibilities clear. The dataservice can allow you to change the database easily with no need to refactor the other components of the system. These services can also easily be used in another Cartesi DApp projects. üëè 

I missed a practical example of usage where you show a vote and some queries. This can be very useful for those interested in give a try and run your DApp. What do you think about it?

Congrats!
undefined says ‚ÑπÔ∏è **Javascript version of python echo**

Hello @wch-karol-p | webchefs ! That was great! üòç 
We will work soon to make things easier for the JavaScript developers from the experience you shared.
Thanks a lot. üôè
undefined says Thanks üôÇ I'm currently developing some useful features in Cartesi javascript world üòâ
undefined says Hi, this is how I do so:
```
      const abi = [
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "_input",
              "type": "bytes"
            }
          ],
          "name": "addInput",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
      ];

    const web3 = new Web3(window.ethereum);
    const contract = new web3.eth.Contract(abi, contract_address);
    
    const addInput = contract.methods.addInput(data);
    
    addInput.send({ from: sign_account, gasLimit: 30000})
        .then( function(result) {
          console.log("SendCartesiInput result: " + result);
        })
        .catch(function(error){
          console.log(error.toString());
        });
```
undefined says Hi Max, I'd suggest you to check up on `abi` and `contract_address` 

**1. ABI** - Try using `localhost.json` for abi. That'd be the correct interface for all the contracts deployed on local node. Once you spin up the hardhat docker container, the localhost.json file gets generated at `/opt/cartesi/share/blockchain/localhost.json` inside the container. 

**2. Contract Address** -  As per the diamond pattern in new Rollups version 0.2.0, please make sure the contract_address points to the `CartesiDApp` contract which acts as a proxy to all other facet contracts including `InputFacet`. 

Let me know if this helps! Go on! üöÄ
undefined says Thanks for the response!
The error solved after I changed the contract address to CartesiDApp contract!
undefined says ‚ÑπÔ∏è  **Rollups 0.3**

Hello community!

We are working hard and with love to bring to you our Cartesi Rollups 0.3 soon! üõ†Ô∏è  ‚ù§Ô∏è
Eager to see the ideas and DApps that you will bring with the new Cartesi Rollups features. 

Stay tuned next week! üòâ
undefined says Nice. excited for portals and the inspect req.
undefined says ‚ÑπÔ∏è  **Enabling DApp tokenomics**

Hello @glockchain !
Yeah! The Portal will enable devs like you start building the tokenomics of your Cartesi Rollups DApps! üòâ 

It will:
- Allow DApp usage only for users that have assets deposited into the DApp portal and then make it sel-sustainable;
- Enable certain DApp features according the volume of assets the user have deposited into the Portal. Imagine a game where certain doors only open if you have certain amount of assets or a voting DApp that considers the volume deposited by users to give weigh for their vote;
- and much more... üòç 

The dev's creativity will be the limit.

Cheers!
undefined says Hello there, how is everyone doing?

I've finished another DApp, this time i've used C++ Cross Compiled OpenCV and Python to solve a Biometric Classification problem with Cartesi Rollups, using everything I've learned in my previous DApps (See my repo ;)) to bring this here. Feel free to take a look üöÄ .
https://github.com/souzavinny/rollups-examples/tree/main/biometrics

Thanks again for all the support.

Cheers,
undefined says It's been some time that i have a question in my mind , if you guys don't mind answering i will be glad. Is it possible to implement a modularity strategy for complex Cartesi Rollups DApps where we have the main logic program (the one responsible for the input loop) depending on one or more HTTP services running separately? The diagram here illustrates the architecture I have in mind.
undefined says i love what i've been learning about cartesi. quick question, are yall planning to make evm compatible zk rollups?
undefined says We are currently focusing on optimistic rollups and unlike Arbitrum or Optimism, we are using a different ISA for our VM, which is not EVM compliant but allows us to support Linux and it's rich enviroment to enable more sophisticated DApps.
undefined says very cool! i'll look more into it
undefined says Great! In case you have any doubts or want to discuss some part of our tech, feel encouraged to do so üôÇ
undefined says Hi guys, I updated the guideline in the readme file for those who want to interact with the voting DApp we developed. Hope it helps. Feel free to give us any feedback on the DApp. Thank you.

Simple version:
https://github.com/Sotatek-ManhNguyen3/cartesi_voting_system

Complex version: 
https://github.com/Sotatek-ManhNguyen3/cartesi_voting_system/tree/master_complex_version
undefined says ‚ùì **Cartesi Rollups DApp modularity**

Hello @Marcus Vin√≠cius !
Given that we were experimenting with stackoverflow when your question arrived, we reposted it there and answered. Please check it: https://stackoverflow.com/a/72537975/4043926

Please let us know if the answer is clear to you, ok?

Cheers!
undefined says Thank you so much! The answer is clear for me
undefined says There we go
undefined says üëã  **Welcome**
Hello @I AM HIM !
Feel free to ask any question you have when learning about our solution, ok?
Cheers!
undefined says Thanks
undefined says hi guys, very cool Cartesi projects that use machine learning. Is it possible somehow to train the model inside the Cartesi machine? I believe, if models are trained outside Cartesi, its not possible to audit the results integrity, if its is biased or not. If everything is within Cartesi, I think this would be possible.
undefined says I believe it's inside Cartesi VM
undefined says @bruno gondim It's possible to do both. If your DApp doesn't benefit from proving the model itself, you can port just the model to the Cartesi Machine. If allowing others to replicate the training to obtain exactly the same model is important to your DApp, you can have the training set available along with the Cartesi Machine to train it so others can reproduce it.
undefined says hey guys - any tips on hooking python debugger with host mode in vscode?

1. installed microsoft extension for python in vscode
2.  created simple launch.json file for debugged file
3.  ran rollups-example in host mode
4. ran python file with debugger 

got this error from attachment. I followed the pre-run steps that included downloading this library. not sure though why it crashes
undefined says Hey @Aleksander ! I suggest you use virtualenv to manage your python environment (so that you don't break anything on your system in case you update/downgrade some module used somewhere else). Once you do that and install the dependencies inside the virtualenv for your DApp, you'll have to configure Visual Studio to use the same environment: you can press CTRL+SHIFT+P and call the "Python: Select Interpreter" command, and then "Enter interpreter path.." to select the .env venv directory of the DApp.
undefined says 
undefined says @Carlo is this what you were aiming for in the end ?
undefined says @Carlo  I think I progressed but now checking out the below:
undefined says @Aleksander you need the rest of the launch.json file. You can see this env variable is defined here.
undefined says @Carlo I just realized you have this full file ooo, is it present somewhere in other projects? or do you mind sharing the file :)?
undefined says it's available on the public repo
undefined says https://github.com/cartesi/rollups-examples/blob/main/.vscode/launch.json
undefined says @Aleksander
undefined says ‚ÑπÔ∏è  **Cartesi Rollups 0.3 is live!!!**

Hello community!

Cartesi Rollups 0.3 is now live! ü•≥ 

Me, @Carlo , @Shaheen, @lyno and all our dev team will be here to answer questions about the new features, solve doubts when using the new release, help on migration from Rollups 0.2 and discuss ideas! üë¨üë≠ 

Tips:
1. Explore our examples to see how the structure of Cartesi Rollups dApps changed;
2. Run the simple echo deployed on Cartesi Testnet Alpha Infrastructure (https://github.com/cartesi/rollups-examples#interacting-with-deployed-dapps)
3. Deploy your own dApp on Testnet following (https://github.com/cartesi/rollups-examples#deploying-dapps).

We are very excited to see what you will be able to do with Cartesi Rollups 0.3! üòç 

Cheers!

PS: Remember! We are here. üòâ
undefined says https://github.com/cartesi/rollups/commit/b2d628fa3af9d6205d228f5a6f39c9e74b311eb2
Once portal withdrawals are implemented, what would they look like from a dapp backend perspective.
undefined says It'll have a more strict payload syntax but, will be a HTTP API call like the notices
undefined says so will look similar to a notice creation call (on echo python example: https://github.com/cartesi/rollups-examples/blob/main/echo-python/echo.py#L27)
undefined says @Carlo can cartesi machines receive any evm compatible tokens as payment?
undefined says Also, a more general question. If i were to host a MERN stack type database solution on a cartesi node, would there be any effects on its performance?
undefined says Is there any projects similar to this. I‚Äôm building a Semi Decentralized Project using public keys since data hosting on the ethererum is expensive
undefined says Hi @Cl√°udio , At the portal section, in Cartesi Rollups => Components, The link to Ether (ETH) contract and ERC-20 contract is wrong. The github return message `The 'cartesi/rollups' repository doesn't contain the 'contracts/EtherPortalImpl.sol' path in 'main'.` Hope your team can fix that soon.
undefined says Currently it can receive the tokens compatible with the portal implementation to be ported inside the rollups, which are ETH, ERC20 tokens and, soon, ERC721 NFTs (those could be used for payments inside your DApp)
undefined says About payment for computations, CTSI will be used to pay validators
undefined says The Cartesi Machine is an emulator an it has different overheads depending on the RISC-V instruction being emulated. We have not tested that particular stack, but you should expect lower than native performance.
undefined says We can discuss your project in more details if you want to, analyse your requirements and possible solutions/DApp architectures. We have some projects using SQLite inside the Cartesi Machine to store application data.
undefined says Hey @Albert Nguyen thanks for reporting the broken links, they should be working now üôÇ
undefined says Yes that would be wonderful, do you mind if I PM you ?
undefined says sure you can!
undefined says @Carlo 
I am looking for a new job now.
I am a Senior Full Stack|Blockchain developer.
Do you have any roles for me?
undefined says There are a some open positions (like blockchain engineer) that might interest you. You can check them and apply for them here: https://cartesi.bamboohr.com/jobs/
undefined says Conceptual question. Let say a turn-based dApp on cartesi wanted to allow its users to deploy their own customly built AIs to interact with its state. How viable would it be to have users compile their AIs to wasm locally (seems like a universal compilation target), upload these wasm files to some immutable storage solution (Arweave for example), and have the rollup machine fetch and run these files (using wasm_time or something) upon state advance calls. Im certain this is possible. Just not sure how optimal.
undefined says The general idea is feasible (have some AI code written to interact inside the DApp) but the way we generally discuss this, especially for games, is different. Currently, due to data availability constraints, the data must be available on-chain so that the dispute protocol can validate the initial state of a computation to later arbitrate the winner in case of a dispute. About the AI itself, we generally think about having a dynamic language, like lua, to program the AI. Have not tested if using WASM as a target is viable, but I suspect it would impose a pretty high overhead on top of the already existing RISC-V emulation overhead. Do you have a more concrete case/application on your mind?
undefined says Yep. For example, chess (go, shogi, etc). Running an instance of `https://github.com/lichess-org/stockfish.wasm` using wasm-time like so: https://docs.wasmtime.dev/lang-python.html
undefined says During disputes. Steps that make https requests could potentially yield different results right?(Based on what that server decides to return)
undefined says The dispute protocol has the assumption that both parties agree on the initial state of the cartesi machine for the given computation and, since the Cartesi Machine is deterministic, at least one party did something different than they should at least once. If the parties don't agree on the initial state of the computation and the dispute smart contracts of the dispute protocol don¬¥t have a way to verify what is the correct initial state for the computation, there is no way to arbitrate the dispute and that is the case if you have potentially unavailable/mutable input data.
undefined says So in that case. If the wasm file is on chain. It would be dispute friendly. https://blog.polygon.technology/polygon-adds-permanent-data-storage-with-arweave-integration/
undefined says I have the impression you cannot access data from a polygon smart contract, the integration is only about using MATIC to pay for storage.
undefined says So from the dispute protocol smart contracts point-of-view, they still cannot verify that the data is there. If they create some integration that allows you to query arweave data from a Polygon smart-contract, than it would be possible.
undefined says So what do you think the dispute friendly solution to users uploading large files to a cartesi rollup might look like.
undefined says In the current state of these technologies.
undefined says Currently you should built on your DApp your own dispute resolution for when there is a data availability problem (suitable for your DApp requirements and data source) and use Cartesi's dispute resolution only when the divergence is in the computation itself. We can have a meeting to discuss this deeper if you want üôÇ
undefined says Interesting. A custom dispute solution. A meeting would be very nice to understand this a bit more. Thanks alot.
undefined says Hi, I'm trying to pulling data from Cartesi Rollup through GraphQL api, is there a way to query the latest notice?
undefined says ‚ùì **Upgrade to Cartesi Rollups 0.3.0**

Hello community!
Please react on how was it to upgrade your code to Cartesi Rollups 0.3.0?

üòç  - It was easy!

üïê  - I will do it soon.

üèÉ‚Äç‚ôÇÔ∏è  - I am still on it.

üòê  - I got stuck and need help.

Count on us!
undefined says Hey, Max! Unfortunately, there is no "latest" filter on the default GraphQL spec. For the time being you should query with a filter specifying the current epoch and, if nothing new comes up, filter using the following epoch number. We know this is a pain point and the next version of the API will have improvements on this part.
undefined says Hi @Cl√°udio , I'm testing the deposit function to see what'll happen in the backend. And it works fine. But, i have a question is can user withdraw money? and if they can, what is the format of the payload send to the backend?
undefined says ‚ùì **Deposit and withdraw**

Hello @Albert Nguyen !

> I'm testing the deposit function to see what'll happen in the backend. And it works fine.

Great! When you have time, please set your question at Stackoverflow as answered (https://stackoverflow.com/q/72655241/4043926).

> But, i have a question is can user withdraw money? and if they can, what is the format of the payload send to the backend?

Withdraw is not possible yet but we are currently working on it. Stay tuned! üòâ 

Cheers!

PS: Could you please react in a our upgrade poll? https://discord.com/channels/600597137524391947/813381014104571904/988410226736791572
undefined says Hey there everyone! How it it going? 

I'm still on the updating process, and I have a question. I've created the skel of the project with the create-dapp.sh inside of custom DApps. It creates the folder with the name and the files needed for building. But, when I try to build it I receive the error below:
`marcus@cartesiVM:~/Documents/Cartesi0.5.0/rollups-examples/new-echo$ sudo docker buildx bake --load
[sudo] password for marcus: 
[+] Building 0.0s (0/0)                                                         
error: service "server_manager" has neither an image nor a build context specified: invalid compose project`
In the example, I just tried to create a new dapp, don't changed anything, and moved to the root cartesi folder with all the other dapps. Any hint on what I'm doing wrong?
Cheers!
undefined says Seems something is off. Let me check it here and get back to you
undefined says My suggestion is to create any dapp with the custom dapps script and try to run the docker bake command. If it works maybe it is something with my env (i'm also investigating here), but the echo-python example builds fine, is just the dapps created by the script.
undefined says I've found what i was doing wrong here: i was using just the "docker buildx bake --load"
But for dapps created by the script it worked with "docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl --load"
undefined says Thanks for the help @Carlo üôÇ
undefined says Yeah, we should reference this (https://github.com/cartesi/rollups-examples/tree/main/custom-dapps/template#building) on the parent directory README as well
undefined says Hey there again @Carlo @Cl√°udio üôÇ .

I've got another thing to ask if you don't mind. Considering that i already have a custom rootfs.ext2, what are the procedures to change the main rootfs.ext2 for my version of it?

I was trying to go to the docker folder, removing the rootfs.ext2 file from dependencies and put my file there (in the older versions i was doing something like that), but it seems it don't download the file in that folder (in this case my file being already there it wasn't necessary to be downloaded, so that is why I've removed from the dependencies file).

In the building process, it fails like the image below (i removed it from the dependencies file so the build-machine.sh script fails). If i don't change it, it will build the machine but probably my dapp won't work considering the default rootfs doesn't have all my dependencies. What can i do in this scenario? 

Cheers!
undefined says 
undefined says The best path generally is putting your dependencies in the DApp specific fs as the rootfs is used for any Cartesi Rollups DApp and should contain only the common base of tools/libraries. If you generate a custom rootfs, you'll have to add your "patch" to any new version we release since there might be changes on newer rootfs versions that are not backwards compatible (like from cartesi rollups 0.1 -> 0.2 when the HTTP dispatcher had changes to reflect the new HTTP API). In that example, if you just replaced the rootfs with your previously patched version, your DApp would be broken as you'd have part of the Cartesi Node compliant with the new interface and the old HTTP Dispatcher inside your modified rootfs compliant with the old interface.
undefined says The "DApp specific fs" here is the same directory of the main files of my dapp? 
Thanks @Carlo again üôÇ
undefined says Generally you'll have things coming from there, but not necessarily. On the Python echo, for instance, the files to be copied for the DApp fs are specified on this json file: https://github.com/cartesi/rollups-examples/blob/main/echo-python/dapp.json
undefined says I will be doing like this, since this way fits better my example.
Thanks Carlo!
undefined says Np üôÇ
undefined says Hey there @Carlo how is it going?
I've tried this approach with OpenCV, but it seems is has some constraints in copying all the dependencies. See image below. It skips the .so files when building. Any idea how to solve this?
Cheers!
undefined says what are you specifying on the dapp.json file? @Marcus Vin√≠cius
undefined says `{
  "fs": {
    "files": ["biometrics.py","model.py", "entrypoint.sh", "fexrvv", "opencv"],
    "size": 128000
  }
}`
Here is what is doing in the dapp.json üòâ
undefined says Ok, let me check here and get back to you
undefined says Are those "files" being skipped symlinks?
undefined says you can use the file command to check that
undefined says ```file /path/to/file```
undefined says in case they are, the rsync command used on the build-dapp-fs.sh script doesn't have the flag set to copy symlinks
undefined says Hello @Carlo . Where can i find the `riscv64-cartesi-linux-gnu-gcc` linker from the ctsi playground to run locally on my machine.
undefined says Yes they are. So i just need to add the flag like this right?
`rsync -r -l --files-from=$FILES . $FS_DIR`
Thank you üôÇ
undefined says Yeah, either that or -L if you want to convert those to files
undefined says Np üôÇ
undefined says They come from our docker toolchain image:
```$ docker run -it --rm cartesi/toolchain:0.9.0 bash```
undefined says ```
root@fbcf0b36a5a2:/opt/riscv# which riscv64-cartesi-linux-gnu-gcc
/opt/riscv/riscv64-cartesi-linux-gnu/bin/riscv64-cartesi-linux-gnu-gcc
```
undefined says you can use the toolchain image to cross-compile things as already have the enviroment set with all the dependencies
undefined says Just one more question: the copy command copies all the files in the dapp.json file to /opt/cartesi/dapp/ right?
undefined says this one? https://github.com/cartesi/rollups-examples/blob/main/echo-cpp/Dockerfile#L5
undefined says if so, yes
undefined says Mine is custom generated from the createdapp.sh, is like this:
`# syntax=docker.io/docker/dockerfile:1.4
FROM cartesi/toolchain:0.9.0 as dapp-build

WORKDIR /opt/cartesi/dapp
COPY . .`
But when i enter in the container image like this:
`marcus@cartesiVM:~$ sudo docker exec -it rollups-examples-server_manager-1 /bin/bash
root@f85f9d7c4ed8:/opt# cd cartesi/
root@f85f9d7c4ed8:/opt/cartesi# ls
bin  dapp  include  lib  share
root@f85f9d7c4ed8:/opt/cartesi# cd dapp
root@f85f9d7c4ed8:/opt/cartesi/dapp# ls
dapp.ext2  dependencies  linux-5.5.19-ctsi-5.bin  rom.bin  rootfs.ext2  shasumfile`

I don't find the opencv folder anywhere. Is it inside dapp.ext2?
undefined says yeah, should be
undefined says you can use e2tools to easily check the ext2 fs file contents
undefined says there is a command e2ls from it to list the contents
undefined says yeah, i found it there with
`e2ls dapp.ext2 
biometrics.py   entrypoint.sh   fexrvv          lost+found      model.py        
opencv       `   
Thanks Carlo üôÇ
undefined says Great! Np üôÇ
undefined says Hello, I'm still testing on Cartesi Rollup v0.2. 
How can client side check if its input is rejected by Cartesi-dapp(but accepted by contract and get epoch_number & input_index) since there will have no corresponding notice written?
undefined says Hey there @Carlo @lyno @Cl√°udio  , how is it going?
How can i run the machine of a DApp in console mode? In version 0.2 we had a make command to be ran inside the DApp folder( sudo make console).
But in version 0.3 i see we have a console flag inside the bake file (target "console" {
  context = "./docker"...) but i don't figured out how to execute it.
Cheers!
undefined says I believe it depends how the cartesi dapp treats the input in the back end. The reason it rejects can also throw some kind of notice if the backend is waiting for this kind of behavior.
undefined says Seems we missed this update on the README, thanks
undefined says there is a new docker image generated to use the console, it's entrypoint is the cartesi machine consile itself
undefined says ```docker run -it cartesi/dapp:<DAPP_NAME>-devel-console```
undefined says don¬¥t forget to replace <DAPP_NAME> with the appropriate name of your DApp
undefined says Now we're cooking! Thanks Carlo üôÇ
undefined says Probably next month, we'll have a version with a new API to handle this appropriately (you'll be able to reject inputs and emit reports with the data about it for the front-end to handle the reason/inform the user appropriately). For the time being, I suggest you accept the input and emit a notice letting the frontend know the provided input was invalid or some other error.
undefined says Hello there everyone.

Here (https://github.com/souzavinny/rollups-examples/tree/main/biometrics) is the updated version (0.3 üöÄ) of the biometrics DApp. The new Cartesi update has a lot of major changes, is cleaner and better. Feel free to take a look!

Thanks for all the support.

Cheers,
undefined says Thanks for the advice!üëç
undefined says I'm trying to migrate to Cartesi Rollup v0.3 now but I get the following errors when sending input to proxy contract (through the way that worked in v0.2):
```
index.js:49 Uncaught (in promise) Error: Internal JSON-RPC error.
{
  "code": -32603,
  "message": "Error: Transaction reverted: function selector was not recognized and there's no fallback function",
  "data": {
    "message": "Error: Transaction reverted: function selector was not recognized and there's no fallback function",
    "data": "0x"
  }
}
```

I found that the proxy contract name has changed from `CartesiDApp` to `CartesiDAppFactory`  in v0.3 but the address and the abi of the `InputFacet` contract look unchanged.
undefined says rollup > webpack
undefined says :Think:
undefined says Hi @max.aetheras ! 
To access the input contract you should refer to the InputFacet abi, but you should use the main Diamond contract address. In this rollups examples version, when the rollups contracts are deployed in the local hardhat, the contracts' abis are copied to deployments/localhost/ and the main contract address is copied to deployments/localhost/dapp.address.
As an example, to access the input contract deployed in the local hardhat in python you could do:

```
import json
from web3 import Web3

web3 = Web3(Web3.HTTPProvider("http://localhost:8545"))

adress_file = open("deployments/localhost/dapp.address",'r')
rollups_address = adress_file.read()
    
input_abi_file = open("deployments/localhost/InputFacet.json",'r')
input_abi_json = json.load(input_abi_file)
input_abi = input_abi_json["abi"]

input_contract = web3.eth.contract(abi=input_abi, address=rollups_address)
```
undefined says Thanks! It worked after I changed to use dapp.address.
The new feature that automatically copy contract abis and addresses to local is very useful!
undefined says Hi guys ‚ô•Ô∏è. I need some help. I have a problem when I try to run the project. I cloned the repo: https://github.com/cartesi/rollups-examples and ran the command `docker buildx bake --load` in `erc20deposit` but it fails like the image below. What can I do? I am using Windows 10
undefined says Hello üëã This seems odd. Could you run `docker buildx bake --print` inside **erc20deposit** directory and share the result here. It will just print the default targets to build without building. Let's see if anything missing there.
undefined says @Shaheen Yes, this is the result. (My docker version is 20.10.16)
undefined says Hi guys,
I'm trying to upgrade from Rollups 2.0 to Rollups 3.0, and having this error. Do you know about this issue?
undefined says Hey @Albert Nguyen Could you share more details on this! Are you running in host mode or prod? Your environment? And maybe share full logs to assist you better!
undefined says Ok, it seems you might end up with unknown issues like this when running it on purely Windows. If you‚Äôre on Windows, using WSL is a recommended way to go. We have not tested it with mingw, just WSL.
undefined says Hello,
I'm trying to run the echo-python example, I had no problems running it in production mode, but in host mode I'm getting an empty notice. What can it be? I'm sending the docker log, when I do the input and notice request.
undefined says There are different reasons that could cause that:
1 - The input was not processed yet, so there is no notice available because of that
2 - The input processing incurred into some error, so, once again no notice 
3 - There is a know issue with hardhat network getting stuck and only returning to process things as expected with a new transaction being issued

To determine which one is the case, you should look at the server manager logs and see it the inputs were processed or not. If they were and there are notices being produced, you'll see on the query indexer logs when it collects those and writes to the database. If you don't see activity on the server manager logs, might be the issue described on (3). Also as you are in host mode, should be easy to take a look at how your backend code is handling inputs (when they arrive, how they are processed, the outcome, etc) so make sure things are going as expected in there.
undefined says Does the hardhat network stuck issue happen very often?

I think I've run through (3) too , sometimes the input data was accepted(return epoch_index & input_index), and the expected notice has not been written for a long time. 
When I try to resend the same input, the previous input and the new input will then both handled by our dapp backend.
undefined says It's intermittent, sometimes happens frequently and other times not so often. One solution is using a different Ethereum node like ganache and the workaround is just issuing a new transaction to force it to process pending things
undefined says Thanks for the response.
Since the stuck issue happened on hardhat network (layer1), we should theoretically avoid it when we test our dapp on testnet right?
undefined says @Shaheen Yeah, it works. Thanks for the help üòã
undefined says Sure. Here is my logs when running the dapp.
undefined says Hi guys, 
I'm following the guideline to build the DApp's back-end machine for testnet, however I got the error message: `error: service "server_manager" has neither an image nor a build context specified: invalid compose project` when running `docker buildx bake machine --load` under my dapp folder.

Any idea how to solve this?
undefined says Oh...I changed my command to ```docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl machine --load``` and it worked.
undefined says Yeah, shouldn¬¥t happen.
undefined says Yeah, we'll improve the readme to make it more explicit that custom DApps have a different command since they are self-contained on their directory (unlike the provided examples).
undefined says Hi guys, I've deployed my dapp contract on Polygon-mumbai, and try to send some input through addInput calls.
However,  it seems that Polygon-mumbai is very busy, and the transactions have a high possibility keep pending for a long time. (I've set my gas limit up to 20,000,000)

Are other people having this issue?
undefined says Ok, after I set `gasLimit` amount by `estimateGas()` and set `gasPrice` amount by `web3.eth.getGasPrice()`
the issue has solved
undefined says Hello, a theoretical and practical question.
In rollups-examples, when it occurs according to the image, am I sending a notice to the blockchain, or just making the notice available for the frontend consultation? The notice is added to the blockchain only when the epoch is finished, right? So, in my first question, would we have the second option as an answer?
undefined says Keep in mind that sometimes Mumbai gets unstable as well. We had issues with it today and it seems like we weren't the only ones. This is from Polygon's Discord:
undefined says Notices don't go to the blockchain, they are available off-chain through the graphql interface. Notices can be checked when provided with proofs produced by the Cartesi Machine and they can be taken as facts after the epoch is finished (including dispute period over).
undefined says Seems you are running starting from a dirty state. My suggestion is starting from a clean state by deleting volumes when shutting down docker compose (using the -v option)
undefined says Would using lxc in ctsi machines be a lightweight and optimal solution to restricting computational resources and enabling safe execution of user submitted binaries?
undefined says Thanks, I'll go to Polygon's discord as well to see if there has some new info
undefined says And some other questions for testing on testnet:
1. If we have some update for dapp, do we need to deploy a new contract to testnet?
2. What is the proper way to stop/restart our local Cartesi validator node? Is it ok for us to shutdown using ```docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.override.yml down```?
3. How do dapp-contract pair with our Cartesi validator node? Is it using the DAPP_NAME?
undefined says HI guys, here is another question when testing on Polygon-mumbai:

I'v successfully send addInput tx to dapp-contract and make sure it is confirmed.
However, after some inputs have been handled by dapp and write corresponding notices, my following new inputs are confirmed by dapp-contract but not received by dapp.

Any idea about this issue?
undefined says We havent't tested LXC containers inside the Cartesi Machine, but you'll probably need to rebuild the kernel (since the one we use is not set to support containers). Not sure how much you'll be able to sandbox another user binary using that approach, might be the case that a criteria to win your chess bot game could be hacking the other party (either your bot is superior and bets the competitor on chess or it wins by hacking the other party - you may think of it as a digital equivalent of chess boxing replacing boxing for hacking (for reference: https://en.wikipedia.org/wiki/Chess_boxing)
undefined says 1. Yes, since the template hash of the Cartesi Machine is hardcoded onchain.
2. Will get back to you about this one.
3. Yeah, you should use your own dapp name in there. As you are building a custom DApp based on the DApp template, the procedure defined here should work https://github.com/cartesi/rollups-examples/tree/main/custom-dapps/template#deploying-to-a-testnet
undefined says If you can send us the complete docker compose log we can take a look to figure it out. Even better would be sharing instructions for us to try to reproduce your issue üôÇ
undefined says Hi guys, I'm researching the `frontend-console` example and finding out how it sends data to the backend. I saw this is a console application. When I run a command, the `builder function` will runs and receives the first data to connect to the provider and roll-up. So if I want to send data directly from the UI (reactjs, etc), is there any difference how to connect to the backend and what should the data look like? I am looking to develop a UI for DApp voting.
undefined says Hi guys, I'm trying to start up a Cartesi validator node in host mode that can work with dapp contract on Polygon mumbai, is the command below the right one to launch?
```
DAPP_NAME=${DAPP_NAME} docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.override.yml -f ./docker-compose-host.yml up
```
undefined says @max.aetheras About point 2, should work, but we have not stressed it enough. If you use testnet and use the -v to destroy volumes when shutting down the node, when you start it again it'll load everything from the blockchain and replay, achieving the current state of the DApp.
undefined says Conceptually, it‚Äôs more or less the same. Both use a Web3 library(like ethers.js) to establish connection but UI has Metamask to support account management and signing transactions.
On web UI, when passing an input/data to a smart contract, you just sign these transactions through Metamask. Let me know if you need more detail on something.
undefined says Hey Max, the `docker-compose-host.yml` in the command is tailored for Hardhat only. A testnet-host configured file will be released soon. Will keep you updated on this.
undefined says Yep. ill build a kernel with all the dependencies i need and play around with it. Also "digital chess boxing" sounds incredibly interesting. Different computers compromising each other within the same sandbox could be a cool meta.
undefined says @Shaheen Ok. Thank you. I got it. And I am connecting to Metamask. Could you tell me on which network I need to do it and give me `contract voting` for DAPP?
undefined says To test it on your local machine, you‚Äôll have to connect Metamask to locally running hardhat node. Note when you run backend with docker compose command, it spins up a hardhat node for us. You‚Äôll need RPC URL = `http://localhost:8545` and chain_id = `31337` to add this network. Remember, Metamask can only detect this network if it is running in the background.
If connected successfully, you can then import dummy Hardhat accounts to Metamask and use them to sign transactions. 
Not sure if I can understand your second question! Could you elaborate?!
undefined says chain id 31337 :bananadance_lsd:
undefined says I have successfully added this network on Metamark. In my second question, I need contract and Abi for DApp. Can you provide them to me?
undefined says @Sonny FE this answer from Lyno can help. Contract address and abi remains same irrespective of console or, UI based DApp. Let me know if you're stuck with something else.
undefined says Ok. Thanks for the help. I will try and will callback if there is a problem  üòã
undefined says Hey @max.aetheras go ahead, check the latest rollups-examples release 0.7.0 for running node in host mode for DApps deployed on testnet. You can find the command in the readme. 
Let us know how it goes! üöÄ  https://github.com/cartesi/rollups-examples
undefined says Hi, I'm constantly having this error. Can you help me to solve it?
undefined says Seems the Cartesi Machine of your DApp is not yielding when it should. This can happen if there is untreated error that kills your application, for instance. Do you have any additional error happening before that one?
undefined says It really was a problem running the application. Was solved. Thanks.
undefined says Great üôÇ Let us know if you hit further issues!
undefined says Hi @Shaheen, how can I import a dummy Hardhat account to Metamask? Could you give me the private key?
undefined says Hey, after you run the back-end of your DApp, the hardhat dummy accounts(address + private keys) can be seen in the logs(check attached image).
undefined says Yeah. I have seen them. Thanks a lot ‚ù§Ô∏è
undefined says Which config value do I change to set the rollup timeout duration?
undefined says Not sure what you mean by timeout. Perhaps you meant the time an epoch lasts? Also, can you elaborate on what you want to achieve by changing this parameter?
undefined says Running 50 bot games in one advance state call leads to a "rollup timed out skipping input" message. Seeing if I can extend this timeout value.
undefined says How long is an advanced state request allowed to run before a forced skip?
undefined says Seems like you are hitting the processing time limit for an advance state call on the Cartesi Machine
undefined says https://github.com/cartesi-corp/rollups/blob/develop/offchain/offchain/src/machine/rollup_server.rs#L79
undefined says The default value is 3mins for processing an input
undefined says are you getting this timeout at about that time?
undefined says Yep. But just solved it. Was just an error that left my logic hanging whenever I called readline() on a binary's blank output. reaching that 3min threshold
undefined says yeah, that happens when your application dies as there is no one to yield and let the rollups know the input was processed
undefined says great to hear you figured it out üôÇ
undefined says Cartesi machines are 100% deterministic?. But if I wanted to create some sort've superficial non-determinism within a machine such that a bot (called bot1) processes a given input ( bot1(input) ) and yields a different result each time without the user being made aware of a secondary secret parameter (example. bot1(input, secret) ). Basically an extra key value that only an advance state instance has access to that cannot be produced by any 3rd party. This sort've key would allow for more diverse bot interactions and also third parties to bet on bot outcomes without being able to compute/predict outcomes on their own end. (looking like oracles?)
https://www.reddit.com/r/chess/comments/7nvqh1/what_prevents_computers_from_replaying_the_same/
undefined says https://blog.chain.link/random-number-generation-solidity/
undefined says A voucher call to a Chainlink VRF everytime at the start of every advance state should do it, correct?
undefined says @glockchain we can discuss this in more details as it's not a simple subject, but generally a strategy we use is combining seeds generated by all parties. In order for no party to be able to "mine" a seed that would benefit itself, we do that in 2 stages: first all the parties commit to a value submitting either a signature/hash or even the encrypted value and, after all parties committed to a value there is a revealing phase in which all the parties submit the actual value/the encryption key.
undefined says Sure. Also, an rng oracle wouldn't suffice?  Because the betting phase itself happens before this random number is fetched. So a malicious party will only be able to predict machine results after the betting phase is over.  Another question, how does the cartesi machine manage and reproduce thread scheduling.Because Most chess engines seem to rely on multi threading for non determinism.
undefined says When I run dapp in Production Mode, I can see the backend logs in the dapp-server_manager-1 container logs. When I run in Host Mode, where do I find the backend logs?
undefined says The Cartesi Machine has no direct access to an RNG oracle, so you wouldn't really have "run time" access to Chainlink's VRF, for instance. You could code a smart contract to build an application level protocol on top of the rollups to request a random number and then feed it to the rollups inputs smart contract, which would later be forwarded to the Cartesi Machine. That way you could avoid players generating numbers until they get one they like and feed it to the rollups inputs. I do think this would be harder to implement than this commit/reveal strategy I described to you on my previous message. As I said before, we can schedule a call to discuss this in more details if you wish.
undefined says When you run your backend in host mode, the backend is running on your own computer so you can directly check the logs of the backend. If you follow the instructions to run the echo-python on host mode, for instance, you will see the logs in the terminal where you started the echo.py backend (https://github.com/cartesi/rollups-examples/tree/main/echo-python#running-the-back-end-in-host-mode)
undefined says Example of that on my terminal
undefined says 
undefined says If you want, you can also start the backend on an IDE to take advantage of break points for debugging and other resources
undefined says just make sure to have the reference to the rollup http server correctly defined (on the previous screen it's the value defined in the ROLLUP_HTTP_SERVER_URL env variable)
undefined says Thanks. A call would be nice to discuss this further.
undefined says I've just updated PR with JS version of python DApp üòâ
https://github.com/cartesi/rollups-examples/pull/13
undefined says Hey! I'm happy to introduce that I've finally rewrite above JS example to Typescript!
Here is PR üôÇ
https://github.com/cartesi/rollups-examples/pull/14
undefined says Hi guys, I've migrate my dapp to align with rollups-examples v0.7.1, and try to cross-build for riscv using cartesi/toolchain:0.10.0, however it shows the error below(the same way worked in cartesi/toolchain:0.9.0),
 is there anything I did wrong?

```
Digest: sha256:3de3385eaa5d24851737ed2234aab0e8c11fd09f6793cba6b41cb663b9154f24
Status: Downloaded newer image for cartesi/toolchain:0.10.0
Running as root
source ./environment.sh ;\
cargo +nightly build -Z build-std=std,core,alloc,panic_abort,proc_macro --target riscv64ima-cartesi-linux-gnu.json --release -p cartesi
error: toolchain 'nightly-x86_64-unknown-linux-gnu' is not installed
make: *** [Makefile:128: build-in-riscv] Error 1
make: *** [build-cartesi] Error 2
```
undefined says Hi guys, I'm testing on Polygon mumbai (using echo-rust example of v0.6), and found that the dapp's advance_state will be triggered after the rollups_dispatcher received the new block.

1. Does that means `advance_state` api will be triggered whenever the rollups_dispatcher receiving a new block(from Polygon? )? What's the connection between them?

2. What's a reasonable waiting time for the dapp to receive the sent input on Polygon mumbai?
I've tested sending 2 inputs to the echo-rust dapp contract I deployed (0x8f42Fb4ee1962aacA3e3E3B1a501Cc11D3037dE6), the transactions are confirmed very fast(within 30 secs),
but the cartesi-dapp received them after more than 8 mins and more than 11mins.
Just wondering if this is normal.
undefined says Do you need the nightly build of rust for some reason? Give it a try without the `+nightly` part in the cargo command
undefined says About 1: the backend code of the DApp Cartesi Machine is only triggered when there is a new request for it to process (either a new input, in which case the `request_type` header is `advance_state` or an inspect one, in which the header has the value  `inspect_state`). The rollups dispatcher is the component that monitors the blockchain state for things that interests your DApp and triggers an appropriate reaction (like telling the server manager component that there is an input available for the Cartesi Machine to process)
undefined says > build-std=std
undefined says why
undefined says wen no_std
undefined says About 2: No, should be much faster. Can you share us the steps to reproduce your issue?
undefined says If you check here, https://doc.rust-lang.org/cargo/reference/unstable.html#build-std, you'll see that this is to force compiling the standard library. That's needed since you are cross-compiling to the modified RISC-V Cartesi Machine target. If you are compiling Rust on your machine (say x64 based) and meant to run in it, you shouldn't need this as the pre-build binary should work fine.
undefined says i mean, why using std
undefined says Inside the Cartesi Machine, it's running on top of Linux
undefined says aahhhh i love quickjs and duktape
undefined says ok that makes sense ofc üòÑ
undefined says as a total beinner
undefined says with a dedicated
undefined says i start where
undefined says no docker, all from source, rust experienceed
undefined says to be honest, i am kinda being again and again confused, with cartesi - i see that its rust with the RISC-V CartesiM Machine/Emu having some posix kind of runtime (?) - but then i scroll up, and read rollups and polygon // EVM terms
undefined says if i do hear rollups, i associate that with layer2 / offchain / evm solutions
undefined says i hope that i was able to describe my point precise enough
undefined says ( like, its a "naming" thing / confusion maybe - but the EVM / polygon part i do not really yet see thru. 
maybe because ive just recently catched up on cartesi. been aware of cartesi thru Serguei Popov already long time tho
undefined says Well, we have a rollups solution but it's not a usual one so people generally get confused about it. The first point is that we are not compliant to the underlying Blockchain execution environment. When you use Optimism or some other Optimistic Rollups solution you basically deploy your Ethereum DApp as is since the DApp still runs over the EVM on L2. That's not the case with us. We use the underlying Blockchain for data availability and consensus using our dispute resolution protocol, but DApps built with Cartesi run on top of the Cartesi Machine, which provides a RISC-V based ISA with a Linux OS on top.
undefined says Because of that DApps on Cartesi are not built in Solidity or some low level Blockchain language, they are built with any language and framework that you port to the Cartesi Machine, which has Linux inside.
undefined says So you are able to use all this libraries, languages, frameworks and tools that have been developed in the past decades.
undefined says We have teams using openCV inside the Cartesi Machine to perform feature extraction of fingerprints.
undefined says We have teams using an SQLite database inside the Cartesi Machine.
undefined says We have people developing in Python, C++, Rust, JavaScript, Typescript, etc
undefined says So as a developer you get a trustless execution environment like the EVM and other Blockchain VMs provide but with a much higher level of abstraction and all the mature software stacks developers are used to as your DApp runs in a Linux environment instead of a bare-metal new architecture like the EVM.
undefined says Besides that you have multiple orders of magnitude more computational power than what you would get on L1
undefined says Another side effect of not using the underlying Blockchain VM is that we are Blockchain agnostic
undefined says As long as our dispute protocols are implemented on a Blockchain, a Cartesi DApp can be deployed on it
undefined says Currently our stack supports any EVM based Blockchain
undefined says So you can develop a Cartesi DApp on top of Ethereum, BSC, Avalanche, Polygon, etc
undefined says Hi Carlo, the steps below are how we setup the whole echo-rust example on Polygon-mumbai:

1. Clone the cartesi/rollups-examples v0.6.0
2. cd echo-rust
3. docker buildx bake machine --load

# Deploy dapp-contract
4. export NETWORK=polygon_mumbai
5. export MNEMONIC=<user sequence of twelve words>
6. export RPC_URL=<https://your.rpc.gateway>
7. DAPP_NAME="echo-rust" docker compose -f ../deploy-testnet.yml up
8. DAPP_NAME="echo-rust" docker compose -f ../deploy-testnet.yml down -v

# Start up Cartesi node
9. export WSS_URL=<wss://your.rpc.gateway>
10. export CHAIN_ID=80001
11. docker compose -f ../docker-compose-testnet.yml -f ./docker-compose.override.yml up
undefined says @Carlo 
And we're using a simple React project to send addInput contract call through Metamask:
```
  useEffect(() => {
    const test_contract = async () => {
      console.log("test_contract")
      const provider = window.ethereum
      await provider.enable()
      const web3 = new Web3(provider)

      // Copy from deployments/polygon_mumbai/echo-rust.address
      const proxy_address = "0x8f42Fb4ee1962aacA3e3E3B1a501Cc11D3037dE6";
      // Copy from deployments/localhost/InputFacet.json
      const input_abi = InputFacet.abi;
      const contract = new web3.eth.Contract(input_abi, proxy_address)
      const sign_account = provider.selectedAddress
      console.log("sign_account: " + sign_account)

      const json = JSON.stringify(test_data)
      console.log("json: " + json)

      const hexData = web3.utils.stringToHex(json)
      console.log("hexData: " + hexData)
      const addInput = contract.methods.addInput(hexData)

      try {
        const gas_limit = await addInput.estimateGas({ from: sign_account })
        const gas_price = await web3.eth.getGasPrice()
        const result = await addInput.send({ from: sign_account, gas: gas_limit, gasPrice: gas_price })
        console.log("SendCartesiInput result: " + JSON.stringify(result))
      } catch (e) {
        console.log(JSON.stringify(e))
      }

    }

    test_contract()
  }, [])
```
undefined says @Carlo Hi, I'm trying to connect to backend code through api /inspect, but it returns not found errors. Do I need to configure anything to call that api? 
Here is the running containers (running in host mode):
undefined says My backend code is running as well
undefined says When i tried to call, it returns error not found (It seens that the request reached the server, but there is no api with endpoint /inspect running inside the server)
undefined says I follow the rule of the url is: `<host_manager_domain>:port/inspect` Is that correct?
undefined says Hi @Albert Nguyen 

Currently, to work with the inspect_state you need to expose the 5002 port in docker-compose-host.yml.
Then, you can send HTTP requests to http://localhosts:5002/inspect/<hex payload> to use it.
As the inspect_state was initially developed to be used as a debug tool, it is only available in host mode. The inspect_state in production mode will soon be available.
undefined says Thank you. It works üòÑ
undefined says The inspect_state only support `report`, is that right? Because when sending `notice`, the response code of `notice` api is 400, but with `report`, it works fine.
undefined says Hi guys, I have a question. When I  send HTTP requests to http://127.0.0.1:5002/inspect/<hex payload> with port 3000 and it shows error like this. What I need to do?
undefined says Hi guys, I'm trying to migrate my Rust project(using v0.6.0 now) to align rollup-examples v0.7.1, however my project structure is different from the echo-rust example.

I'm having a separate Rust folder and a dapp folder(see the attached files) that contains all the building config and scripts for building machine.

In v0.6.0 version, I can first cross-build the Rust binary in my Rust folder, and then copy the binary to the dapp folder to build up the machine.

I tried the same way in v0.7.1, and running the dapp in host mode, the dapp can receive the input and write the new notice normally, but the strange thing is that I can't query out the written notice from graphQL.

Besides, I've seen the error logs below:

```
cartesi-dapp-rollups_indexer-1     | note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
cartesi-dapp-rollups_indexer-1     | Starting indexer with config `IndexerConfig { dapp_contract_address: 0xa37ae2b259d35af4abdde122ec90b204323ed304, state_server_endpoint: "http://state_server:50051", initial_epoch: 0, interval: 10, mm_endpoint: "http://server_manager:5001", postgres_endpoint: "postgres://postgres:password@database/postgres", session_id: "default_rollups_id" }`
cartesi-dapp-rollups_indexer-1     | thread 'main' panicked at 'processed_oneof is None', indexer/src/machine_manager/db.rs:624:33
cartesi-dapp-rollups_indexer-1     | note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
cartesi-dapp-rollups_indexer-1 exited with code 101
```

Any suggestion to migrate to v0.7.1 without changing my project structure?
undefined says Yes, that's right. **inspect_state** is just a developer-friendly tool to give us a snapshot of our back-end server. This snapshot is ephemeral and probably would change with next inspect call. While `notices` are permanent and provable in nature. Hence, we've a separate **advance_state** call to create them.
undefined says Hi Sonny, not sure if you updated the `docker-compose-host.yml` file with 5002 port as Lyno mentioned to Albert. Let us know if this is not the case.
undefined says The indexer that crashed on your logs is the process responsible for feeding the database queried by the graphql interface, so it makes sense that you are not able to retrieve the notices. Have to analyze on the complete docker logs if there is some tip to why this process crashed.
undefined says I was trying the `echo-lua` example from the `rollups-examples`, and I was unable run in production mode with Docker because the `echo-lua/Dockerfile` points to a broken link for the toolchain. After changing the image link from `cartesicorp/toolchain:0.10.0` to `cartesi/toolchain:0.10.0` it worked, just reporting.
undefined says This is a known issue, the next version will serve the appropriate header for CORS. As a workaround right now you can setup an nginx as a proxy and use it to add the header allowing CORS from all origins. 
The setup to use nginx as a proxy to the server manager is something like this: https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/#passing-a-request-to-a-proxied-server 
And to make it add the CORS header is something like this: https://serverfault.com/questions/162429/how-do-i-add-access-control-allow-origin-in-nginx
undefined says Thanks for reporting. We'll get it fixed
undefined says Thanks for the response, I'll take a further look and try to gather the complete log.
undefined says @Carlo @Shaheen Thanks a lot. It worked ‚ù§Ô∏è
undefined says @Carlo any updates?
undefined says It's not published yet. @lyno has posted on the #üü®‚îÉjs-ts channel a simpler example you can take a look for the moment.
undefined says Hi guys, is it possible for dapp to get the block_number and timestamp from the input (like how we get msg_sender from metadata)?
undefined says If in python.
undefined says Hi guys, I'm trying to deploy my dapp to testnet, I get an error (at the step submit a deploy transaction to the Cartesi DApp Factory contract) that is `invalid mnemonic`.  I can see there are three variables need to be config: NETWORK, MNEMONIC and RPC_URL.

1. The MNEMONIC there are space between words, should i convert it to other string or just keep the blank space. (Example: `export MNEMONIC=this is mnemonic example`)?
2. The RPC_URL need a USER_KEY => Is that the address of the account?
undefined says ```tienmanh@manhnguyen3:~/Documents/code/cartesi/cartesi_voting_system/voting$ DAPP_NAME=erc20deposit docker compose -f ../deploy-testnet.yml up
[+] Running 2/0
 ‚†ø Container cartesi_voting_system-machine-1   Created                                                                                                                                                                             0.0s
 ‚†ø Container cartesi_voting_system-deployer-1  Recreated                                                                                                                                                                           0.1s
Attaching to cartesi_voting_system-deployer-1, cartesi_voting_system-machine-1
cartesi_voting_system-machine-1   | 60002d8125062972f132d2202203b29c1d66e1d14bab228897a2da1681912da2
cartesi_voting_system-machine-1 exited with code 0
cartesi_voting_system-deployer-1  | connecting to https://eth-goerli.alchemyapi.io/v2/0x1F5BC6C2A6259d00e5447CeBb3b2bC0BB7b03996
cartesi_voting_system-deployer-1  | invalid mnemonic
cartesi_voting_system-deployer-1 exited with code 1```
undefined says Thanks!
undefined says The mnemonic you should export=‚Äúmnemonic with quotes‚Äù
undefined says for testing, ok, but avoid this practice in production
undefined says export bla=X makes that mnemoric visible in bash history
undefined says The rpc_url key appears when you create the configuration in the node account like recommended in the readme
undefined says Thank you. I deployed the dapp successfully
undefined says I'm trying to interact with my dapp (that is deployed to the testnet) by the following command:
`yarn start erc20 deposit --amount 10 --address <my_contract_address>` and it returns the error: 
`Error: cannot estimate gas; transaction may fail or may require manual gas limit`
undefined says I dont understand this, could you explain this error and give me some instructions to fix this?
undefined says could you check if the deployments/goerli/ folder was created in the process? I'm having issues in this part as well üôÇ
undefined says Yes, that folder was created, and in that folder there is a file, that contains the smart contract address
undefined says Oh, your deployment is better than mine so =), i'm still stuck in something similar related about gas limits. About this part i can't help you yet
undefined says No worries. I will try it again. Thanks for answer.
undefined says Before sending a transaction, you generally ask the Ethereum node you are connected to estimate the amount of gas needed to execute it. The error you are getting is telling you the Ethereum node is failing at doing gas cost estimation. One thing you can try is using a different node (if you are using Alchemy, for instance, you can give Infura a try). If you still get this error, you can just manually define the max gas amount on the transaction manually.
undefined says I've tried the yesterdays error (Similar to this one) in alchemy and infura, both gave me the same output. But in my case this happens in the moment of the deploy.
undefined says Hi,

any chance for you to remember what was the solution? I got the same error for my dapp.
undefined says i got this error too. Any chance you remember what was the solution if any?
undefined says rollup-indexer keeps restarting most of the errors are `concurrent call in session ` and a few `session id not found!` 

any help appreciated
undefined says Are you sure the account being used to issue the transaction has the tokens you are trying to deposit on your DApp?
undefined says The error was lack of funds in the account used to deploy, in case anyone else runs into a similar problem
undefined says Can you DM your full docker compose logs to take a look?
undefined says I didn't notice that. Before the transaction, my account had 0.2458 GoerliETH. And then I went to the faucet.polygon.technology, and got free token of `Test ERC20 Plasma` and `Test ERC20 PoS`.
undefined says In the docs of frontend-console example, it mentioned that `If the erc20 address is unspecified, the appropriate address for the CTSI token will be used for the target blockchain being specified` , So I guess my command `yarn start erc20 deposit --amount 10 --address <my_contract_address>` is trying to send 10 CTSI to the DApp, is that right?
undefined says Yes, but then you should check if you have Goerli CTSI or the CTSI version of the other testnet you are using
undefined says I dont have any Goerli CTSI. I can't even find the address of that token to import to the Goerli Network. How can I get the Goerli CTSI token to test?
undefined says We have this goerli CTSI faucet, the address is available on the footer of the Cartesi Explorer when you choose Goerli: https://goerli.etherscan.io/address/0xc3779fE5E6246fF6dBFEd09904788abC9063037E#writeContract
undefined says Just connect your metamast and call the "requestTokens"function
undefined says it will give you some Goerli CTSI @Albert Nguyen
undefined says If you have any issues/doubts/need more details, just let us know
undefined says üôÇ
undefined says Thank you. I just got the CTSI token. I'll let you know if i have any issues.
undefined says Awesome! üöÄ
undefined says yes, one moment
undefined says Hello,
I'm integrating Metamask on the frontend of my DApp. When I try to send a transaction using Metamask, it sends a wrong nonce and I have to manually change it for the transaction to succeed. It looks like Metamask and my Hardhat blockchain are not "in sync". So I don't know if it's a problem in Metamask and how I did the integration or, in my local blockchain. Do you have any suggestions?
undefined says Is it out-of-synch from the start or it eventually loses the synch?
undefined says From the start. But I already identified the problem. Thanks.
undefined says @Carlo @lyno When i call the deposit function, it converts the user address to lower case, Right? I thought the address is case sensitive so we shouldn't convert it to lower case?
undefined says Another question: I don't really understand the `status` when call the apis (like notices, report, finish). It has two values is `accept` and `reject`. When someone send invalid input to my dapp, i send a notice with status is `reject`, but it seems the notices didn't save to graphQL, but when I try send a notice with status is `accept`, it works fine. Did you know why?
undefined says The case in the address is actually used as a verification mechanism to check if the address is correct (a bit like a "checksum"). The all lower case address is equivalent to the one mixing high/low case, it just loses this verification mechanism.
undefined says Great, if you care to share what the problem was, others might benefit from it in the future üôÇ
undefined says When you reject an input it's "erased" from the DApp state. As notices are meant to be a way to broadcast valid statements from your DApp, they are only consolidated from accepted inputs. When you have an error you should use the reports to give the user some feedback of why the input was rejected.
undefined says Understood! Thank you. I will update my code.
undefined says I updated my code, and I tested it (using command line), I saw my backend code called the report api and it returned status code 200, and the response of that command is `input 5 added to epoch 0` , so How can I get that message? In graphQL, there is no function called GetReport (Just GetNotice and GetVoucher)
undefined says 
undefined says Lol rust in phpstorm
undefined says Hi, I‚Äôm trying to use my app in the production mode instead of host mode and I have problem with missing file - does anyone has idea why this might happened?
undefined says It works fine just fine, to be honest üôÇ
undefined says Got rust anqluzer?
undefined says analyzer? Yeah, some plugins did installed after I openned rust project
undefined says fixed üòÑ
undefined says 
undefined says Hey @wch-dawid-m | webchefs 
Make sure to include the missing file in the dapp.json
Then you can rebuild the project. 
After building the cartesi machine, you can run it in console mode to check the files.
To run in console mode (used echo as example) you can use:  `docker run -it cartesi/dapp:echo-devel-console run-machine-console.sh`
Then, to check the files you can: `ls /mnt/dapp/`
undefined says Hello everyone.
I have a question, returning a "reject" in the handle_advance prevents the machine state to change, similarly to what happens in the Inspect? In the docs it only says that it discards "vouchers" and "notices".
undefined says What is the difference in returning "accept" or "reject" in the handle_inspect? After all the machine is going to rollback anyway.
undefined says Because I imagine that when the machine do the rollback it would lost (discard) its "vouchers" and "notices", like it would do when it returns a "reject".
undefined says Hi guys, just curious about the `inspect` api:
1. When we call `http://localhosts:5002/inspect/<hex payload>`, does that means we are directly interacting with the dapp or the Cartesi node?
2. Does the hex payload finally handled by `handle_inspect` function in dapp?
3. Is there any structure limit for the hex payload?
undefined says 2. That's right.
3. I faced one issue with inspect is that if the hex payload is too long, the URL will be automatically cut.

Another thing when you call inspect api, is that the body passed to your code will be like this:
`{'request_type': 'inspect_state', 'data': {'payload': '0x7b20226d65746164617461223a207b20226d73675f73656e646572223a2022'}}`

Above structure is a litte bit different when you call by command line, and it will throw a Key error when you tried to get `metadata` from rollup_request (this line in while function will throw the error: `metadata = rollup_request["data"]["metadata"]`). So, you need to change the code in `while function` a little (I assume you use the example code from rollups-example).
undefined says what was the solution if you don't mind?
undefined says Hello, is inspect state available in the frontend console to test handle_inspect?
undefined says I haven't found a way to automatically sync Metamask with the blockchain. De-synchronization occurs when you restart the blockchain having already performed some transaction on the previous startup. Thus, the nonce advances on Metamask, but is restarted on the blockchain. What I'm doing is using Metamask's Reset Account option when I restart the blockchain, so they are in sync again.
undefined says Hey Dawid! At the moment, it's only available in host mode. You can use curl to make the inspect call. 
Try this: `curl http://localhost:5002/inspect/0x$(xxd -pu <<< "test")`
undefined says And make sure to expose port 5002 as Lyno mentioned here.
undefined says Hey @Arthur Vianna, you're right it does require a finish schema but status is ignored in the inspect_state request. Read here https://github.com/cartesi/openapi-interfaces/blob/master/rollup.yaml#L82
undefined says @colinsteil
undefined says @colinsteil roadmap from Optimism. They note their testnet c. 2 years before mainnet launched.

For Cartesi, are we expecting the same timeline? From testnet, how many milestones until mainnet (e.g. Optimism have 4). Think the community is keen to understand what's left after testnet towards mainnet. Thank you
undefined says We have shifted to a different roadmap model for a while, and are frequently updating the community about the direction we are moving. The last development update is this one: https://medium.com/cartesi/july-2022-development-recap-for-the-blockchain-os-d4a59b3d3fec
undefined says You can check our development updates have a diagram with advances on our different initiatives on the roadmap.
undefined says One of those is road to mainnet, which we had an article released explaining the path we set
undefined says https://medium.com/cartesi/developers-can-start-coding-for-cartesi-rollups-end-of-december-1113493ce775
undefined says Thanks @colinsteil
undefined says Just as with the stake delegation feature, testnet is meant to iterate over our current product:  get feedback from the community, detect any problems/rough edges and deal with them. Once we are happy with it, it'll be the time for final audits and a limited beta mainnet release (as there are differences from testnet to mainnet, especially on things involving economy).
undefined says Hi @Carlo, is rollups version 0.5.0 available?
undefined says We are ironing the last details to release it. Soon!
undefined says Hi Guys, I'm looking at the erc20 example and the ERC20/ERC721 Portal of the Cartesi Rollups.
Since the dapp will decode the input and get the amount of the transfer, is it possible for dapp to get the owned balance of the depositor for ERC20 or the ownership mapping for ERC721 from the Portal?
undefined says Hi @max.aetheras, the current portals' implementation sends inputs to the backend with only the current deposit information. The deposit information includes:
- For ERC20Portal: (header, depositor, token address, amount, general data) <- (['bytes32', 'address', 'address', 'uint256', 'bytes'])
- For ERC721Portal: (header, depositor, nft address, id, general data) <- (['bytes32', 'address', 'address', 'uint256', 'bytes'])
- For EtherPortal: (header, depositor, amount, general data) <- (['bytes32', 'address', 'uint256', 'bytes'])
The DApp should define how to store the information, whether to create maps or tables of assets and account balances, or even not store anything and only emit vouchers from all received deposits.
undefined says Thanks for the details, is very helpful.
undefined says Hi @Carlo , I can see that you updated the rollups to version 0.5.0. I migrated my code and it works well. But, I have a doubt when using report.

When I send an invalid input to the dapp (using frontend console), it rejects that input and the code calls the report api, the response of that command is:

```tienmanh@manhnguyen3:~/Documents/code/cartesi/cartesi_voting_system/frontend-console$ yarn start input send --payload '{"action": "DEPOSIT_INF"}'
yarn run v1.22.11
$ ts-node src/index.ts input send --payload '{"action": "DEPOSIT_INF"}'
connecting to http://localhost:8545
connected to chain 31337
using account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
sending "{"action": "DEPOSIT_INF"}"
transaction: 0x8349b44ec28f5bc9f60d26f71f5fb070415ec941df556fb475378b6ae199f7b8
waiting for confirmation...
input 8 added to epoch 0
Done in 11.37s.
```

The response looks exactly like when calling the notice api, so I can not know should I call the notice or report to get the response. Is there any sign I can use to distinguish between calling the report or calling the notice?
undefined says Hi guys, another questions about the erc20 portal:
Can users directly withdraw from the portal or users need to addInput to dapp and make the dapp to send a voucher to do so?
undefined says Hey Max, no users cannot directly withdraw from the portal! The DApp logic should emit vouchers as it deems fit. Some scenarios may include :  
1. reacting to the inputs specifying withdrawal,
2. a result of a game giving rewards or,
3. reacting on the deposit of unwanted asset. You may see erc20 example in rollups-examples. https://github.com/cartesi/rollups-examples/tree/main/erc20
undefined says Hi @Albert Nguyen, when sending inputs, you are interacting with contracts on the blockchain, so the response will be same. The frontend-console doesn't do anything special for the rejected inputs. 
The key difference is when the DApp rejects an input, the notices and vouchers are discarded and the state of the Cartesi Machine is rolled back to the previous state. 

On the the other hand, reports are not discarded and you can query them in the graphql server. Querying reports is very similar as querying notices. 
From the frontend-console you can query them with:
```
yarn start report list
yarn start report list --epoch 0 --input 1
```
Let us know you could check the reports for the rejected inputs!
undefined says Yes, I could get the reports for the rejected inputs. As you say, if the front end call to the DAPP and get rejected, the FE will receive an input and epoch, and because the FE doesn't know if that request is accepted or rejected, so it has to call the notice to get message first, if there is no notice, it will call the report, is that right?
undefined says Yes, this is a good approach! 
Just remember that it is possible that notices and reports are still pending because the backend didn't finish processing the input.
undefined says Thank you. I get it now.
undefined says Just a quick note, as you using Graphql, you can include both notices and reports in the same Graphql request. So you could use a single request to get the notice result and get the report containing in case of error.
undefined says I have a question about the deployment structure: why is a cloud based infrastructure managed by the team needed? Will we use Descartes as the next step?
undefined says Great idea! We will try that.
undefined says Descartes is a different product than Cartesi Rollups. They are both built on top of our core technology which includes the Cartesi Machine. We didn't enforce nor suggested any particular DApp deployment topology for Descartes and that was something that developers struggled with. Cartesi Rollups have no limitation about different topologies as well, but to make it easier for both developers and users, we are making it easy to run a committee based topology where the committee nodes run on a cloud infrastructure easy to manage. That way DApp developers are able to deploy their DApps to this infrastructure and not worry about having enough well maintained validator nodes to have the DApp working. We are also making it as easy as possible to publish a DApp on this infrastructure to lower the entry barrier for new developers.
undefined says Hi guys, here are more questions about the EtherPortal:
1. Is it possible to use web3.js with dapp.address + the abi in EtherPortalFacet.json to call the `etherDeposit` function of EtherPortal? If yes, It would be nice to have an example for this.
2. Is there any limitation for the `_data` field of `etherDeposit` function? 
3. Where can I decide the deposit amount? or we just need to pass the amount as the value of the Payable function?
undefined says Hey @max.aetheras 
1. Yes, it should be possible.
2. No, there is no limitation. But this data is sent to the blockchain, so it gets expensive if you send too much data.
3. Yes, you just need to pass the amount as the value of the payable function.

A small example of how to deposit ether using ethers library. 
Note: You will have to use the correct provider, address, ...

```
import { ethers } from "ethers";

import { EtherPortalFacet__factory } from "./generated/rollups";

const depositEtherToPortal = async (amount: number) => {

    const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");

    const address = "0xa37aE2b259D35aF4aBdde122eC90B204323ED304"; 
    
    const etherPortalContract = EtherPortalFacet__factory.connect(
        address,
        provider.getSigner()
    );

    if (etherPortalContract) {
        const data = ethers.utils.toUtf8Bytes(`Deposited (${amount}) ether.`);
        const txOverrides = {value: ethers.utils.parseEther(`${amount}`)}

        // const tx = await ...
        etherPortalContract.etherDeposit(data,txOverrides);
    }
};
```
Let me know if this helps
undefined says I have question, if I want to create an DApp with Cartesi, say like a game with fair tournaments, should I follow "Build DApps" or "Descartes Tutorials - Hello World DApp" in the documentation? From a new user perspective I am kinda confused what is the ideal path to create a Cartesi DApp, if I should use Descartes SDK or not. At first looks like for me that Descartes is an old solution and will maybe be deprecated in the future? But I am not sure. I just need some clarification when Descartes is needed and if I should use it with Cartesi for my use cases.
undefined says Thanks, I'll give it a try.
undefined says Hey @edubart! Go for Cartesi Rollups - Build DApps path! Our Rollups framework extends the capabilities of Descartes. Both the products use our core tech - Cartesi Machine  - at their heart but Rollups solution allows us to create a higher-level framework to ease building and deploying complex DApps like a game in your case. You won‚Äôt have to write solidity smart contracts and all the necessary generic contracts(related to inputs, outputs, assets etc.) will be deployed by the framework itself. All you have to care about is writing game‚Äôs logic using the language of your choice.
undefined says Hi, is there an upgrade guide for the 0.5.0 version?
undefined says I tried to do the same thing as in the "Bump to rollups 0.5.0" commit from rollups-examples but this error occurred:
undefined says how did you do the "bump"? rebase?
undefined says I just change the version numbers in the files and tried to build an app. I didn't find a proper way to do it
undefined says The suggested way is for you to use git rebase so that your commits are reapplied on top of the latest repo version
undefined says And then, in case of breaking changes, make the appropriate changes
undefined says For this version some metadata (headers) of the inspect API were changed
undefined says And you should also point to the inspect server (new component) to interact with the inspect API
undefined says But besides that, there aren't breaking changes
undefined says Hi @lyno , could you explain more about the voucher? As my understanding, when user want to withdraw token, the backend will issue a voucher (using voucher api), after that, the token will be given back to user wallet automatically, Is that right?
undefined says Hi guys, I've look through the announcement for the new version of rollups:
```
A proof of concept for a new endpoint in our HTTP query API allows Inspect State calls that will make it possible for developers to query the state of their DApp‚Äôs backend code without sending a conventional input to the blockchain, which costs money.
```
How can the user query through the new endpoint? Is there any example for this?
undefined says You can see the example of calling inspect api in here: https://github.com/cartesi/rollups-examples/blob/main/frontend-console/src/commands/inspect.ts
undefined says Thanks, I'll take a look at this.
undefined says Hi everyone, i was updating to rollups version 0.5 and looks like the GraphQL had some changes, the queries that I was using don't seems to work anymore.

My graphQL  queries were:
1) To get the last epoch
```
query processed {GetProcessedInput (query: {input_index: "0"}) {epoch_index} }
```

2) To get the notices of the desired epoch
```
query getNotice { GetNotice( query: { epoch_index: "${epoch}" } ) { session_id epoch_index input_index notice_index payload } }
```
undefined says I would like to know if it is still possible to get those informations using different queries
undefined says You don't have to know epoch index to get payload by `getNotice`
undefined says GetNotice has also param like `input_index`
undefined says I know, I get the information per epoch in case the database has too many notices.
undefined says In this new version looks like we don't have the "GetNotice" anymore.
undefined says Regarding to this: https://github.com/cartesi/rollups/blob/main/offchain/data/graphql/typeDefs.graphql structure of GraphQL was a little changed üôÇ
undefined says Hey Albert! Vouchers are a way for the DApp to interact with Layer 1. They are smart contract calls that are provable in nature. So, whenever the DApp issues a voucher, the user has to wait for the validity proofs to be generated after the epoch finishes. Then, the user can submit the voucher(a smart contract call) to the output facet contract. Check this part for the user executing the vouchers: https://github.com/cartesi/rollups-examples/blob/bd762a0400367b7ff19abc0222632de0885e26c8/frontend-console/src/commands/voucher_commands/execute.ts#L95
undefined says Hey ArtV! Check this updated GraphQL query for notices by epoch. https://github.com/cartesi/rollups-examples/blob/bd762a0400367b7ff19abc0222632de0885e26c8/frontend-console/graphql/queries.graphql#L62
undefined says It works,  Thanks üôÇ
undefined says So, vouchers are like a gift, but users have to claim them, otherwise, they will lose that voucher, is that right?
undefined says I'm testing the voucher in host mode. The DApp issued a voucher, it has an id 1. And then, i try to execute the voucher by command `yarn start voucher execute --id 1` , but I received this message:

```tienmanh@manhnguyen3:~/Documents/code/cartesi/cartesi_voting_system/frontend-console$ yarn start voucher execute --id 1
yarn run v1.22.11
$ ts-node src/index.ts voucher execute --id 1
retrieving voucher "1" along with proof
querying http://localhost:4000/graphql for voucher "1"...
voucher "1" has no associated proof yet
Done in 2.32s.```

As you said, the user has to wait for the validity proofs to be generated, then how long will it take to generate that proof?
undefined says Hi guys, I'm trying to deploy my DApp to testnet, and facing this error

```DAPP_NAME=erc20 docker compose -f ../docker-compose-testnet.yml -f ./docker-compose.override.yml up
[+] Running 0/1
 ‚†ø rollups_inspect_server Error                                                                                                                                                                                                    5.0s
Error response from daemon: pull access denied for cartesicorp/rollups-inspect-server, repository does not exist or may require 'docker login': denied: requested access to the resource is denied```

It seems there is an issue with permission. How can I fix this?
undefined says Yeah! Like rewards earned in a game! You'll not necessarily lose them but they'll lie in the game unless you claim/execute it!
undefined says Validity proof will generate once the voucher-associated epoch gets finished. To test in host mode, you can simply advance time. Try this command here: https://github.com/cartesi/rollups-examples/blob/main/README.md#advancing-time
undefined says I tried that command, the voucher now could be executed. But, I'm facing another error.

```tienmanh@manhnguyen3:~/Documents/code/cartesi/cartesi_voting_system/frontend-console$ curl --data '{"id":1,"jsonrpc":"2.0","method":"evm_increaseTime","params":[864010]}' http://localhost:8545
{"jsonrpc":"2.0","id":1,"result":"864033"}
tienmanh@manhnguyen3:~/Documents/code/cartesi/cartesi_voting_system/frontend-console$ yarn start voucher execute --id 1
yarn run v1.22.11
$ ts-node src/index.ts voucher execute --id 1
retrieving voucher "1" along with proof
querying http://localhost:4000/graphql for voucher "1"...
connecting to http://localhost:8545
connected to chain 31337
using account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
executing voucher "1"
COULD NOT EXECUTE VOUCHER: {"reason":"incorrect data length","code":"INVALID_ARGUMENT","argument":"machineStateHash","value":"0x"}
Done in 2.39s.``` 

Do you know why?
undefined says Here is the log from backend code when call api `/voucher`
```return amount 10000000000000000000
INFO:__main__:Issuing voucher {'address': '0x610178da211fef7d417bc0e6fed39f05609ad788', 'payload': '0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000008ac7230489e80000'}
INFO:__main__:Received voucher status 200 body b'{"index":0}'```
undefined says It seems that we can use the following query to query a certain notice:
```
query Query() {
  notice(id: 1) {
    id
    payload
  }
}
```

Does the `id` means the `input_index` ? Do we still need `epoch_number` for query?
undefined says Another question for the new schema, if the `id` is not `input_index`, can user still get its value from the result of calling `addInput`?
undefined says thank you for came back to GraphQL Playground instead of Apollo üôÇ
undefined says In `frontend-console` from examples you can find smth that looks like answer 
```
query noticesByEpochAndInput($epoch_index: Int!, $input_index: Int!) {
    epoch: epochI(index: $epoch_index) {
        input(index: $input_index) {
            notices {
                nodes {
                    id
                    index
                    payload
                    input {
                        index
                        epoch {
                            index
                        }
                    }
                }
            }
        }
    }
}
```
undefined says Hey Albert! It seems that the image is pointing to the internal path. You can change it to `cartesi/rollups-inspect-server:0.5.0` inside **docker-compose-testnet.yml**
undefined says I see the machineStateHash is not being generated. You might wanna try this in production mode to get the machine hash and proofs correctly. Probably we should mention this in readme. Let us know if this works!
undefined says Hey Max! No the `id` here doesn't represent `input_index`. It is the **notice id**. You can query notices with id or epoch or any other formats as specified in schema file. 

The `addInput` gives the same result as before - the epoch and the input_index.
undefined says Since `addInput` still provides `epoch` and `input_index`, the recommended way for user client to query certain notice would be somehow like @wch-karol-p | webchefs mentioned above right?
undefined says Yes, this should be the best way to query the notices generated from a specific input.
undefined says @Shaheen @lyno Thanks for the responses.
undefined says Yeah, It worked. I have the following doubts:
- As you said, `Validity proof will generate once the voucher-associated epoch gets finished`, is there any specified time or range of time it takes to let user know? I mean, when users want to withdraw the token, DApp will issue the voucher, and users have to wait before execute it, I want to let users know how much time they have to wait, is that posible?
- After successfully executing the voucher, then i run the command get list voucher, it still have the executed voucher in the list, and it has no field for us to know if that voucher is executed or not. Is there any way to know if that voucher is executed or not?
undefined says - Yes, it is transparent and you can let users know. The deployer service sets the variables `inputDuration` and `challengePeriod` related to the epoch. Currently, it is being set as 1 day and 1 week respectively. The next epoch will start after the ***inputDuration*** finishes. So, you can have the proofs generated after 1 day. Note that this is the case when we don't have any disputes to account for as you're the sole validator. We'll take ***challengePeriod*** in account as well when we have multiple nodes submitting their proofs.
A user can view the vouchers as soon as they are issued but yeah to execute them, one has to wait for proofs on-chain.

- Let me check if we have an indicator for this but yeah if you re-execute a successfully executed voucher, you should get an error.
undefined says For the reference in first question.
undefined says Thanks. Another question is can I know the amount of token I added to the voucher?
undefined says The amount can be decoded from the payload. If you know how it was encoded, you can always decode it. You can refer the encoded payload in erc20 example. And to decode it you can use this ethers library function `abiCoder.decode([ "address", "uint256" ], payload);` Let us know if this works!
 https://docs.ethers.io/v5/api/utils/abi/coder/#AbiCoder-decode
undefined says Regarding "executed voucher", it is stored on-chain and can't be queried from the graphql server. You can decide on how you're gonna handle it. From front-end, one way is to simply disable the execute button once the voucher gets executed.
undefined says How composable are ctsi dapp instances. Can each dapp seamlessly communicate with one another and to what extent. Someone discussed this before. Just trying to revive the conversation.
undefined says Got it. Thank you.
undefined says Hi Shaheen, I use this ethers library function `new ethers.utils.AbiCoder().decode(["address", "uint256"], payload)`  to decode in my frontend code (Javascript). But it does not seem to work. Do you know why?
undefined says Did you try this: `ethers.utils.toUtf8String('0x....')` ?
undefined says I am facing this error when I try your command. My payload data: `0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000000027`
undefined says Can You share a code snippet ?
undefined says ```
import { ethers } from "ethers";

const decode = new ethers.utils.AbiCoder().decode(["address", "uint256"], "0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000000027")
```
Sure, here is my code.
undefined says try this:
```
const decoded = ethers.utils.defaultAbiCoder.decode(["uint256", "uint256"], payload);

decoded.forEach((element) => {
  console.log(element.toString());
});
```
undefined says Thank u. I will try it!
undefined says Hey, they way that you are decoding the vouchers should work, but Just a note on that.
The vouchers payload include the 4-byte function signature at the beginning of the byte string. So, to decode the erc20 voucher you should drop the first 4 bytes and decode with ["address", "uint256"]. An example:
```
import { ethers } from "ethers";

payload = ethers.utils.hexDataSlice(payload,4);  
const decode = new ethers.utils.AbiCoder().decode(["address", "uint256"], payload)
```

From the ERC20 example:
```
        # Encode a transfer function call that returns the amount back to the depositor
        transfer_payload = TRANSFER_FUNCTION_SELECTOR + encode_abi(['address','uint256'], [depositor, amount])
        # Post voucher executing the transfer on the ERC-20 contract: "I don't want your money"!
        voucher = {"address": erc20, "payload": "0x" + transfer_payload.hex()}
```
Let me know if this helps!
undefined says Thank you. I have successfully decoded. I added 32 bytes but it doesn't work. So I tried another way by deleting  the first 4 bytes.
undefined says Edited the response for correctness.
Indeed, bytes32 wasn't working (I meant bytes4, and even that wasn't working). So I would say to stick with the 4-bytes drop approach. 
Remember that this decoding is specific for the erc20 transfer voucher, and for any other voucher you should decode accordingly.
undefined says Hi guys, I'm trying to create new DApp using custom-dapps example. I put my code to folder `template`, update the `dapp.json` file, and then, run the command to generate code:
`./create-dapp.sh voting`

This command run successfully, and the new folder voting with all the BE file and some extra files. And then, i run the command to build the application:
```cd voting
docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl --load```

This command failed. Here is the log:
undefined says 
undefined says Does anyone know how to fix this? Thanks.
undefined says Hey @Albert Nguyen, it seems that the .env directory is missing. As you are using an environment similar to the erc20 example, you should change the Dockerfile to build the .env, but this will require further file editions (docker-bake.override.hcl, and entrypoint.sh)
Also, I wouldn't advise changing the template folder, as this will affect any dapp that you build. Instead, you could copy the files after you create the custom dapp.
To summarize, the 'update' procedure should be:
- Create the custom dapp `./create-dapp.sh voting`
- Copy the source files from the old version to the new `voting` version (as you are using python, include all .py files and requirements.txt).
- Copy (or edit accordingly) the aux files dapp.json, Dockerfile, docker-bake.override.hcl, and entrypoint.sh to the new `voting` version.
undefined says Thank you. It worked.
undefined says Hi guys, here are some questions about the Rollup settings:
1. It seems that there is a 10 blocks confirmation period in current version, can we modify the "--confirmations" in docker-compose-testnet.yml to change this behaviour? 

2. I've seen `inputDuration` and `challengePeriod` settings in <dapp-name>/docker/default.json, is this the right place for us to modify the settings?
    
3. Is there any concern for shortening the `blocks confirmation period`, `inputDuration`, and `challengePeriod` ?
undefined says Maybe anyone @here implemented payments? "Pay now" button or something
https://discord.com/channels/600597137524391947/1001119663947780278/1014569611620003880
undefined says Hey @max.aetheras , refer below answers:
1. Block confirmation time is not something that can be modified by the developer, rather used by the Cartesi Machine. Refer ans. 3 also.

2. No, if the configuration exists in **dapp.json** file, it will override the /docker/default.json. You should modify the **dapp.json** to set `inputDuration` and `challengePeriod` or any other parameter in the `default.json` file.

3. For the development, you can modify either of them but when deployed in the production  `block confirmation period` will be defined by the Node infrastructure. The `inputDuration` and `challengePeriod` will be used as per your `dapp.json` configuration.
undefined says Thanks for the response!
And Is there any concern if we try to shorten `inputDuration`, and `challengePeriod`?  
ex: Will this increase the cost because of more frequent transactions? Will this cause any security issue?
undefined says It's not a concern when you have just one validator node running but yeah shortening this time period would mean more frequent claims by the validators on L1, hence more the costs involved. 
When you have multiple validator nodes involved, one should be mindful of giving enough time for inputs+challenge phase. There is no fixed magical number, it depends on the inputs your dapp is expecting and validators' attributes. Say, all of the validator nodes are healthy with near zero downtime then, it makes sense to shorten the inputDuration and challengePeriod phase.
undefined says Hi, does the `inputDuration` define the time duration of `AccumulationSlot`, and the `challengePeriod` define the time duration of `Settlement Period` that mentioned in https://cartesi.io/en/docs/cartesi-rollups/components/ ?

Is it possible for us to calculate the remaining waiting time for voucher to be finalized by  `inputDuration` , `challengePeriod` and current epoch number ? or we just can give out the estimation time that users need to wait for about 1 day or 1 week according to the number of the validator nodes?
undefined says Hey Max! Yes, you got it right but the estimation of how long it will take for a voucher to be finalized, however, depends on expectations of disputes! 

For a voucher to be finalized, its input has to go through the entire accumulation phase. After that, the epoch that contains the input that contains that voucher will be sealed. Then it depends on disputes, either the validators react promptly (beginning of the challenge period) and it gets finalized quickly Or, the validators wait till the end of the challenge period and then that gets added to the estimation. The worst case scenario is if there is a dispute during the challenge period, then it becomes a bit more unpredictable. So, we can only estimate this for users.
undefined says hi, I was curious before deploying my project here, what is the finality for transactions?
undefined says Hey! Could you elaborate a bit? Is this project build on Cartesi Rollups framework?
undefined says Hello, I'm studying about benchmarking and this question came to me:
Are blockchain benchmark tools useful for evaluating my Cartesi DApp? Can I integrate Cartesi's Rollups framework with Hyperledger Caliper, for example?
undefined says Hi, is it possible to get some information from OutputFacet to check whether a voucher is executed?
ex: Get `voucherPosition` by calling `getBitMaskPosition()` and check whether voucher is executed by `voucherPosition` result?
undefined says Yes, it should be possible. Btw we're adding a way to filter the executed vouchers with a graphql query.
undefined says Nice! For the current version of the Cartesi rollup, can you give us some hint how to do so?
undefined says It should work the way you mentioned by fetching the `voucherPosition` and further using it to filter the emitted event `VoucherExecuted(voucherPosition)`, will have to test it though. https://github.com/cartesi/rollups/blob/a149633482b9fa859d6550d4d4c29b748d380dc7/onchain/rollups/contracts/facets/OutputFacet.sol#L97
undefined says Not familiar with that testing framework but I assume it wouldn't be very useful. These frameworks generally test transactions per second (TPS) and in our case it makes sense to benchmark the speed of the processing of your DApp. In order to do that the best approach is including some script that performs the task you wish to benchmark inside your DApp build. Once you did it, you can use the docker image generated during the DApp build (called cartesi/dapp:<YOUR_DAPP_NAME_HERE>-devel-console) which has this script as default command - https://github.com/cartesi/rollups-examples/blob/main/docker/run-machine-console.sh :
```
cartesi-machine \
    --ram-length=128Mi \
    --rollup \
    --flash-drive=label:dapp,filename:dapp.ext2 \
    --flash-drive=label:root,filename:rootfs.ext2 \
    --ram-image=linux-5.5.19-ctsi-5.bin \
    --rom-image=rom.bin \
    -i \
    -- "/bin/sh"
```and overwrite the command to bash:
```
docker run -it --rm cartesi/dapp:<YOUR_DAPP_NAME_HERE>-devel-console bash
```
Once inside this docker container, you can use a similar command to the entrypoint script, but replacing it with your benchmark script and using the `time` tool to measure how long it takes (as the time should be measured from outside of the Cartesi Machine, time inside the Cartesi Machine passes at an arbitrary pace, depending on the overhead to emulate each instruction executed):

```
time cartesi-machine \
    --ram-length=128Mi \
    --rollup \
    --flash-drive=label:dapp,filename:dapp.ext2 \
    --flash-drive=label:root,filename:rootfs.ext2 \
    --ram-image=linux-5.5.19-ctsi-5.bin \
    --rom-image=rom.bin \
    -i \
    -- "<PATH_TO_YOUR_BENCHMARK_SCRIPT_HERE>"
```
undefined says @Aswage
undefined says Thanks! I will try to do it this way.
undefined says is there way to create background task in dapp with cartesi?
undefined says It could be a possibility. If you could share your scenario briefly, we can suggest some solution.
undefined says Hi guys, is it possible to query vouchers through graphQL by using a list of `epoch_number` + i`nput_index` pairs?
undefined says Hi @max.aetheras can you answer my private messages?
undefined says You might wanna try this query here https://github.com/cartesi/rollups-examples/blob/d2fd438325c0242a4920c797b3827a334c05a7a2/frontend-console/graphql/queries.graphql#L127
undefined says Imagine i fire crosschain tx to bitcoin blockchain. And my background task keep watching for those 100 of fired tx and once it confirm i should update some state in L1.
undefined says We have working bitcoin based sport betting project. We want to crosschain fire betting from eth L1 to sport betting blockchain and get result back to eth l1 state once crosschain complete or result update of betting win/loss.
undefined says Any interactions of a Cartesi Rollups DApp with underlying chain(L1 or any other EVM compatible L2) can be tracked in form of *vouchers* and *notices*. This is something that the rollups infrastructure provides for you and as a developer it is upto you to define the logic when these *vouchers or notices* are created. Your DApp can query all these transactions made with simple graphql queries and you can define what to do on these emitted outputs(like updating state on L1 as you mentioned). To read more on how Cartesi Rollups DApp interact with underlying chain, read this https://cartesi.io/en/docs/cartesi-rollups/dapp-architecture/
If you want we can setup a call to discuss more on your project and understand it better, feel free to DM me or @Carlo
undefined says Hi guys, we've migrated our dapp to match with Cartesi Rollups Alpha v0.6 and have some tests on it.

However,  we met some issues:
1. It is highly possible to meet the error message like this:
```
Received GetEpochStatus for session default_rollups_id epoch 0
Received InspectState for session default_rollups_id
Throwing from server-manager.cpp:2748 at new_InspectState_handler(handler_context&)::<lambda(boost::coroutines2::coroutine<side_effect>::push_type&)>
Caught finish_error_yield_none 'session is tainted'
Received Health Check for service 
Received GetSessionStatus for session default_rollups_id
```

Once we met this error, the inspect api will remain broken.
undefined says 2.  Sometimes the dapp has successfully handled advance_state() request and added a new notice but the corresponding notice cannot be reached by GraphQL query.
```
cartesi::mono::http_dispatcher|bin/cartesi/src/mono/http_dispatcher.rs:33
    Reading notice 0
      Reading notice length
      Reading notice payload of length 4013
[INFO  actix_web::middleware::logger] 127.0.0.1 "POST /notice HTTP/1.1" 201 11 "-" "-" 0.009055
  Running advance/inspect state increment 0
[DBG] 1970-01-01 00:00:00 Received notice status 201 Created body IndexResponse { index: 0 }
  cartesi::mono::http_dispatcher|bin/cartesi/src/mono/http_dispatcher.rs:55
[DBG] 1970-01-01 00:00:00 Call to Http Dispatcher: Finishing
  cartesi::mono::http_dispatcher|bin/cartesi/src/mono/http_dispatcher.rs:68
[DBG] 1970-01-01 00:00:00 status_value: accept
  cartesi::mono::http_dispatcher|bin/cartesi/src/mono/http_dispatcher.rs:72
    Input accepted
    Getting voucher hashes memory range proof
Received GetSessionStatus for session default_rollups_id
  0
Received GetEpochStatus for session default_rollups_id epoch 0
Received GetSessionStatus for session default_rollups_id
  0
Received GetEpochStatus for session default_rollups_id epoch 0
Received Health Check for service 
Throwing from server-manager.cpp:2018 at proof_type get_proof(async_context&, uint64_t, uint64_t)
Caught taint_status Deadline Exceeded
Received GetSessionStatus for session default_rollups_id
```
undefined says Is this happening on production mode? Could you share full logs so that I can also share with team?
undefined says Hi guys, I'm working on voting dapp and having some troubles that need to go to inside the machine to check the code and data. As I understand, the code will be copied to folder `/mnt/dapp/` inside the machine, but is that the folder that will run the code? Because with my DApp, in the folder that starts the server, there will be a database of sqlite3 inside that. But, when I jump into machine and go to `/mnt/dapp/` folder, I only see the code files, it doesn't contain the database file.
undefined says I can see command start my server in `build-machine.sh` is

```cd /mnt/dapp; \
        ROLLUP_HTTP_SERVER_URL=\"http://127.0.0.1:$ROLLUP_HTTP_SERVER_PORT\" \
        ./entrypoint.sh```

So, I thought the database file must be in `/mnt/dapp` folder, but it's not.
undefined says Yes, I tested it on production mode.
I'll send the full log through PM.
undefined says No need to worry about this question. I know what is the problem. Sometime I can not save data to database in production mode, that's because the DApp return the reject status, so the state of the Cartesi Machine is rolled back to the previous state, that's why my data is lost in production mode but running well in host mode.
undefined says Keep in mind that SQLite database files are usually created the 1st time you connect to it, so if you just run a Cartesi Machine container using the console image, that didn't happen (hence there is no db file)
undefined says Yes planning on, so would like to know what the fastest finality is and what the slowest one is
undefined says @Carlo answered your question here üôÇ  https://discord.com/channels/600597137524391947/821540265738764299/1019236506042380309
undefined says Hi guys, just curious that what would happen if I run up 2 Cartesi nodes with the same Cartesi machine and connect to the same dapp-contract on Goerli?

Will they all received same inputs from dapp-contract and make their state synchronous?
undefined says Yes, you can run two validator nodes but currently, only one would be able to send claims when the epoch finishes. You won't be able to run dispute resolution protocol at the moment.
undefined says Hi guys, I am implementing a function that allows users to deposit tokens (DOGE, SOL, ...) besides CTSI. To make this functionality, I need their token addresses to be on Local and Testnet. Is this really possible? If possible, please tell me how to get their token addresses.
undefined says Hey Sonny! The Rollups framework supports Eth, ERC20 and ERC721 token standards. So, the token you wish to deposit must be either of them. Note that the CartesiToken is automatically deployed when we run local environment. For testing other tokens, either on local dev or testnet, you can create and deploy your own custom erc20 tokens inside hardhat container and use their address. You can worry about the verified token addresses when deploying on mainnet.
undefined says These hardhat tutorials should help https://hardhat.org/tutorial/writing-and-compiling-contracts
undefined says Thank you ‚ù§Ô∏è . I will learn more
undefined says Hi guys, I'm trying to find a library that can allow me to create and deploy my own custom erc20 token on Local and Testnet. Does anyone have an idea about this or suggest me a solution? Thanks. Also, I found a website called Bunzz (https://app.bunzz.dev/). This is a platform to build the on-chain side of DApp but it seems to only be able to create and deploy tokens on Testnet without including Local.
undefined says Use openzeppelin https://docs.openzeppelin.com/contracts/4.x/erc20
undefined says Thank you. I will try it!
undefined says Hello everyone, I get the following error when I try to deploy my dapp to goerli testnet.
undefined says `
$ DAPP_NAME=iot_rollups_dapp docker compose -f deploy-testnet.yml up
[+] Running 2/0
 ‚†ø Container iot_rollups_dapp-machine-1   Created                                                                                                                                                                              0.0s
 ‚†ø Container iot_rollups_dapp-deployer-1  Created                                                                                                                                                                              0.0s
Attaching to iot_rollups_dapp-deployer-1, iot_rollups_dapp-machine-1
iot_rollups_dapp-machine-1   | e0318d1b0cae7d299132d413cd9325cd7659e0f0d6f5c6a0d6a4fb7bc56573a5
iot_rollups_dapp-machine-1 exited with code 0
iot_rollups_dapp-deployer-1  | connecting to https://rpc.ankr.com/eth_goerli
iot_rollups_dapp-deployer-1  | using account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
iot_rollups_dapp-deployer-1  | {
iot_rollups_dapp-deployer-1  |   diamondOwner: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
iot_rollups_dapp-deployer-1  |   templateHash: '0xe0318d1b0cae7d299132d413cd9325cd7659e0f0d6f5c6a0d6a4fb7bc56573a5',
iot_rollups_dapp-deployer-1  |   inputDuration: 86400,
iot_rollups_dapp-deployer-1  |   challengePeriod: 604800,
iot_rollups_dapp-deployer-1  |   inputLog2Size: 25,
iot_rollups_dapp-deployer-1  |   feePerClaim: '10000000000000000000',
iot_rollups_dapp-deployer-1  |   feeManagerOwner: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
iot_rollups_dapp-deployer-1  |   validators: [ '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266' ]
iot_rollups_dapp-deployer-1  | }
iot_rollups_dapp-deployer-1  | cannot estimate gas; transaction may fail or may require manual gas limit
...
undefined says According to the error It couldn't estimate the transaction cost, but why? Anyone else came across this problem?
undefined says This error usually happens when you don't actually have currency in the wallet you're trying to deploy the DApp. If you are using the mnemonic from the metamask, you are using the first account from the wallet. If this account doesn't have currency (goerliEth, in this case) it gives this error.
undefined says Thank you, my friend!
I was using the wrong mnemonic!
undefined says You're welcome. Feel Free to use this place to ask if you're in trouble üôÇ
undefined says Hello, is anybody implementing Vouchers for Ether in the dApp? I'm looking for information on how the payload should look while I'm sending requests to the /voucher endpoint.
undefined says All Cartesi verfier node verify the computation, right? But how can we process singular task that doesnt need verification. Just fetch some value from api and save it to L1?
undefined says you want to fetch some value from inside the Cartesi Machine and save it to L1?
undefined says @Albert Nguyen has done it and you can also find an example on the erc20 project on the rollups examples repo:  https://github.com/cartesi/rollups-examples/blob/main/erc20/erc20.py#L79
undefined says Hey @wch-dawid-m | webchefs 
The voucher will call the etherWithdrawal function in EtherPortalFacet, which receives encoded data. So the payload will be double encoded.
Here's a simple example in python to generate a Ether Voucher
```
from os import environ
import requests
from eth_abi import encode_abi

rollup_server = environ["ROLLUP_HTTP_SERVER_URL"]

# Web3.keccak(b"etherWithdrawal(bytes)") -> will be called as [rollups_address].etherWithdrawal(bytes) where bytes is ([address receiver],[uint256 value])
ETHER_WITHDRAWAL_HEADER = b't\x95k\x94\x10\x92\x96h\x8b \xfe\xd5b\xda\x90\xd9N\r\x81\xbe4\x95\x1a\xf8t\xb5\x13\x0bO\x85\xbd\xbb'

# own DApp address
rollup_address = '0x...'

def send_voucher(receiver,value):
        withdraw_header = ETHER_WITHDRAWAL_HEADER[0:4]
        # data consumed by etherWithdrawal function
        ew_data = encode_abi(['address', 'uint256'], [receiver,value])
        # etherWithdrawal function call from OutputFacet
        data = encode_abi(['bytes'],[ew_data])
        
        payload = f"0x{(withdraw_header+data).hex()}"
        voucher = {"address": rollup_address , "payload": payload}
        
        response = requests.post(rollup_server + "/voucher", json=voucher)
        return response
```

As a reference, the OutputFacet and EtherPortalFacet
https://github.com/cartesi/rollups/blob/main/onchain/rollups/contracts/facets/OutputFacet.sol
https://github.com/cartesi/rollups/blob/main/onchain/rollups/contracts/facets/EtherPortalFacet.sol
undefined says Yes, call some thirdparty api and get the result with python and save it to l1.
undefined says Any plan to support zkEVM? I found their current coverage: https://github.com/0xpolygonhermez
undefined says If the underlying chain is EVM-equivalent, it is easier to support it. We're testing how things work when Cartesi rollups infrastructure is integrated with layer-2s. At the moment, Ethereum is the underlying chain for settlement and data availability.
undefined says Hi guys, I can see that each account in localhost will have 10000 ETH. How can I get the address and abi of that ETH token?
undefined says Hello Albert! That is Ether funded to these sample accounts. It's native to the hardhat node and doesn't have a specific address in contrast to the ERC-20 tokens(that are user deployed smart contracts). If you're performing any deposit or withdraw with ETH, you only need the receiver's address and amount. Hope that answers your question!
undefined says I see. Thank you.
undefined says @Carlo did you missed this?
undefined says While using the rollups framework, you can use `inspect` api call to fetch values from inside Cartesi Machine. It won't generate any proofs on L1.
undefined says Cool thanks
undefined says hi
undefined says @lyno What is encoded in "ETHER_WITHDRAWAL_HEADER"? I kind of cannot get over it what it is
undefined says ETHER_WITHDRAWAL_HEADER is the secure hash keccak of the value b"etherWithdrawal(bytes)"
If you want to withdraw ether from the portal you should use this value:
```
ETHER_WITHDRAWAL_HEADER = b't\x95k\x94\x10\x92\x96h\x8b \xfe\xd5b\xda\x90\xd9N\r\x81\xbe4\x95\x1a\xf8t\xb5\x13\x0bO\x85\xbd\xbb'
withdraw_header = ETHER_WITHDRAWAL_HEADER[0:4]
```
But if you want to use any other L1 smart contract function you should extract the keccak of the function call 
`keccak(b"myL1SmartContractFunction([argument types])")`
undefined says So you basically have a timer derived from cycle count, is there a way to convert this to seconds in the VM?
undefined says @eigendude  @Carlo
undefined says Hello everyone.
I am currently trying to cross-compile an Python lib (pycryptodomex) into Cartesi Machine. I did the same procedure show in the calculator example (https://github.com/cartesi/rollups-examples/tree/main/calculator), in this example an external lib is also used.
Apparently I succeeded in installing the lib, but I get some errors from the lib code, looks like it can't find the ".so" files that it needs.
undefined says `[server machine-server 5/6] RUN build-machine.sh /opt/cartesi/share/dapp-bin:
#0 1.200
#0 1.200          .
#0 1.200         / \
#0 1.201       /    \
#0 1.201 \---/---\  /----\
#0 1.201  \       X       \
#0 1.202   \----/  \---/---\
#0 1.202        \    / CARTESI
#0 1.203         \ /   MACHINE
#0 1.204          '
#0 1.204
#0 3.552 [INFO  rollup_http_server] starting http dispatcher service...
#0 3.554 [INFO  rollup_http_server::http_service] starting http dispatcher http service!
#0 3.565 [INFO  actix_server::builder] Starting 1 workers
#0 3.567 [INFO  actix_server::server] Actix runtime found; starting in Actix runtime
#0 3.598 [INFO  rollup_http_server::dapp_process] starting dapp: python3 back_end/iot_rollups_dapp.py
#0 36.16 Traceback (most recent call last):
#0 36.16   File "/mnt/dapp/back_end/iot_rollups_dapp.py", line 20, in <module>
#0 36.16     from Cryptodome.Signature import eddsa
#0 36.16   File "/mnt/dapp/.venv/cross/lib/python3.10/site-packages/Cryptodome/Signature/eddsa.py", line 33, in <module>
#0 36.17     from Cryptodome.Hash import SHA512, SHAKE256
#0 36.17   File "/mnt/dapp/.venv/cross/lib/python3.10/site-packages/Cryptodome/Hash/SHA512.py", line 29, in <module>
#0 36.18     _raw_sha512_lib = load_pycryptodome_raw_lib("Cryptodome.Hash._SHA512",
#0 36.18   File "/mnt/dapp/.venv/cross/lib/python3.10/site-packages/Cryptodome/Util/_raw_api.py", line 309, in load_pycryptodome_raw_lib
#0 36.19     raise OSError("Cannot load native module '%s': %s" % (name, ", ".join(attempts)))
#0 36.19 OSError: Cannot load native module 'Cryptodome.Hash._SHA512': Not found '_SHA512.cpython-310-riscv64-linux-gnu.so', Cannot load '_SHA512.abi3.so': /mnt/dapp/.venv/cross/lib/python3.10/site-packages/Cryptodome/Util/../Hash/_SHA512.abi3.so: cannot open shared object file: No such file or directory, Not found '_SHA512.so'`
undefined says The thing is that the ".so" files are in the Cartesi Machine already (with the `ls` command in the "entrypoint.sh" I was able to locate those files.), but looks like they just can't be found.
undefined says Additional info: When I execute the command `ldd` for these ".so" files it returns "not a dynamic executable"
undefined says ```cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (error={"reason":"execution reverted","code":"UNPREDICTABLE_GAS_LIMIT","method":"estimateGas","transaction":{"from":"0x2e50B73C98f4bD2679a5A8A91fA93C3b6737549A","maxPriorityFeePerGas":{"type":"BigNumber","hex":"0x59682f00"},"maxFeePerGas":{"type":"BigNumber","hex":"0x1cf3405004"},....code=UNPREDICTABLE_GAS_LIMIT, version=abstract-signer/5.7.0)```
Anyone familiar with this? On testnet deployment. How can I config gas manually. A custom config file is giving me errors as well.
undefined says Hey @Arthur Vianna 
What is the command in entrypoint.sh? Don't forget to set the PYTHONPATH
Where are the locations of the libs?
undefined says Hello!

My entrypoint.sh has these lines:
`set -e
export PYTHONPATH=/mnt/dapp/.venv/cross/lib/python3.10/site-packages
ls -lh ${PYTHONPATH}/Cryptodome/Hash

python3 back_end/db_manager.py           # create sqlite database
rollup-init python3 back_end/iot_rollups_dapp.py`
undefined says The libs (.so) that the pycryptodomex tries to access are in this directory ${PYTHONPATH}/Cryptodome/Hash
undefined says The "ls" command that I inserted  in the entrypoint.sh was to confirm that they were there.
undefined says is this the full error message?
I think this error message may appear even when the error is unrelated to gas
Just to be reassured, check the account balance. The deployment scripts try to use the first wallet of the account provided, so make sure there are enough funds on it.
undefined says Here is the full error message.
undefined says 
undefined says https://goerli.etherscan.io/address/0x2e50B73C98f4bD2679a5A8A91fA93C3b6737549A
The address has also been funded.
undefined says Try changing the last line in entrypoint.sh to
PYTHONPATH=/mnt/dapp/.venv/cross/lib/python3.10/site-packages rollup-init python3 back_end/iot_rollups_dapp.py
undefined says It gives the same error.
undefined says Yep. Goerli's acting up today.
undefined says 'Goerli' want you to 'go early' to bed
undefined says Validator address is still ```0x18930e8a66a1DbE21D00581216789AAB7460Afd0``` on mumbai?
undefined says Ok Awesome. Looks like it.
https://mumbai.polygonscan.com/address/0x18930e8a66a1DbE21D00581216789AAB7460Afd0
undefined says Hey there! I tested an deploy now and it is fine. This error happens when you use a account without currency in. It is easy to configure a mnemonic without balance due to metamask using the first account of the plugin when you export the mnemonic, so double check if the mnemonic account has goerli ETH and you will be good to go üôÇ
undefined says Hey!
I was able to reproduce the issue. 
Cryptodomex uses compiled libs, so you should avoid using pre-compiled during pip installation (--no-binary option), and you should also define the compiler variables to compile for riscv.
I had to change this 2 files of the calculator example to make it work (I also added `from Cryptodome.Signature import eddsa`  in calculator.py).
If you are still having issues we can schedule a meeting.
undefined says About timers, you should use time based on the metadata you receive on your inputs (there is a header with the block number and another one with the block timestamp). The time inside the Cartesi Machine doesn't have relation with the outside world, so you should not rely on it for any decision like timeouts or scheduling events
undefined says Hello Lyno, thanks for your help!

Everything is working now.
undefined says Just one thing that I noticed after reading about the crossenv (https://pypi.org/project/crossenv/), is that in the Dockerfile (including the one that you sent me) the command `$(which python3)` returns the builder-python, shouldn't we use the host-python? With that in mind I managed to make the pycryptodomex to work without declaring those compiler variables that you mentioned.
I just had to change the following line
`python3 -m crossenv $(which python3) .venv` --> `python3 -m crossenv /mnt/python-dapp/bin/python3 .venv`
undefined says Cool @Arthur Vianna !
undefined says https://optimism.mirror.xyz/fLk5UGjZDiXFuvQh6R_HscMQuuY9ABYNF7PI76-qJYs it seems modular blockchain concepts are gaining fashion. First Celestia, now OP, too ambitious or too unrealistic?
undefined says https://www.youtube.com/watch?v=jnVjhp41pcc also find a DevCon talk from the OP team
undefined says @leonardoaraujos#0001, @max.aetheras is developing a Unity-based game
undefined says Hi @max.aetheras
undefined says @Carlo @eigendude For Rollup v Rollup communication through notices coming later down the line. What sort've latency could be expected.
undefined says We'll have data once that is implemented. ATM this is under research
undefined says Hi! I have a question about vouchers. While we are trying to create some vouchers there is a validation error (our inside-the-app logic). Should we still create a voucher and leave the front end with it? Are they need to try catch decode this voucher and check if the error is present?
undefined says I would advise to reject the state and emit reports informing the errors. 
But in the end, it's up to the DApp logic. If the error wouldn't compromise the DApp functionality, you could still emit the vouchers to avoid forcing the user to send another input. For example, if the user tries to withdraw more funds than he has balance, you could emit a voucher with the maximum amount instead of rejecting the state. But you should be extra careful to avoid exploits.
undefined says Hello,
Can I change parameters of the local blockchain (hardhat) that runs when I use the Cartesi Rollups development environment? For example, can I change the speed at which blocks are confirmed or their size?
undefined says Hello @Aswage! You can experiment in local dev environment. I believe hardhat allows us to change the mining behaviour. Also note that currently Rollups dapps use a 10 blocks confirmation period which we don't advice to change when deploying a dapp to testnet.
undefined says Hi guys, I think it's very important to develop a DApp that is user-friendly. For new users, a tutorial on the system will be essential. I'm using the reactour library for that. This is a library for Reactjs, it's easy to use, nice interface, and fully documented. If you want to show tutorials for your DApp, you can consider this library. I hope it will be useful to you.
Reactour's homepage: https://reactour.js.org/
Reactour v1: https://www.npmjs.com/package//reactour (recommend)
Reactour v2: https://github.com/elrumordelaluz/reactour/tree/main/packages/tour
undefined says Thanks for sharing it with the community @Sonny FE üôå
undefined says Can I get some help? I cross compiled Kubo (go-ipfs) into the VM, but golang only generates code with floats, so I'm building the proxy kernel, and buildroot is failing 25 mins into the fs build. How should I debug buildroot? Or is there someone that can fix the buildroot fs generation?
undefined says The error I'm currently getting is 
```
warning: /usr/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-lp64.h: No such file or directory
warning:     8 | # include <gnu/stubs-lp64.h>
warning:       |           ^~~~~~~~~~~~~~~~~~
```
undefined says Yeah, the go compilations require floating point enabled! We'll release native support for this soon so things will work better. Regarding this particular error, let me check with the team if we can somehow make this possible. Btw, IPFS inside the machine, way to go!
undefined says Yeah, I also accidentally compiled numpy with g++ instead of gcc and caught a bunch of errors that have now been sent upstream to numpy üôÇ
undefined says Speaking of IPFS, would Cartesi be open to an IPFS example in their rollups-examples repo?
undefined says Basically, there would be another contract in the `rollups` repo for IPFS transfers via L1, such as "add file". Later, IPFS files could come directly from L2, and I believe Zippie is working on this, but right now sending all data through L1 is required. But I'm doing the L1 work now so we could use it in the meantime
undefined says We're always open for community contributions. On how should it be integrated is a matter of wider discussion. I'd recommend you to start a discussion on this under CIPs forum. I'd loop in our core research contributors as well. https://github.com/cartesi/cips/discussions
undefined says I think that Zippie is integrating IPFS at the node level, which is probably the way to go. But that requires data availability, so in the meantime, I was just gonna pass IPFS files through L1 and store them in the VM. We wouldn't need libp2p or networking, just a repo for file storage that can check hashes. We just need to cross compile a minimal IPFS implementation to the VM.
undefined says I tried rust-ipfs, but a Rust crypto module doesn't compile for RISC-V
undefined says Kubo compiles, but I can't build the root fs with float support due to the above error
undefined says Node probably isn't fun to cross-compile to RISC-V, which means js-ipfs isn't available
undefined says A Python version of IPFS was started but never went anywhere
undefined says The only other two options are Fuhon and ipfs-tiny, both written in C++, so calling from Python code will take glue code and effort that I was trying to avoid
undefined says Fuhon uses the Hunter build system, which will not be fun to port to RISC-V. Once I was able to build Fuhon without Hunter and sent some patches, but don't really want to again
undefined says @colinsteil @Carlo hope you're well. For Cartesi's decentralised exchange dapp, think dakai, would it have prevented issues we seeing today with binance/ ftx? Specifically, can a truly decentralised exchange help prevent centralised behaviour?
undefined says Well if you truly want to own your assets in a non-custodial manner and don‚Äôt bother about the best UX, a decentralized exchange is always the recommended path. Unlike centralized actors, you get transparency and voting powers in the future of the project as well. This is key to avoid the opaque governance and execution issues that we see today. The decentralized exchange on Cartesi is still a work in progress and we‚Äôll share more details as we achieve further milestones.
undefined says Hi guys, I've tried to deploy our cartesi dapp on to `arbitrum-goerli` and `optimism-goerli` and found that it runs more faster than running on `goerli` testnet. (about 30secs v.s. 150secs)

Just curious that do we still have the "10 blocks confirmation time" limit on `arbitrum-goerli` and `optimism-goerli`? If yes, is it possible for us to modify it?
undefined says OK but I (and probably also everyone else) would see tremendous value-add if the decentralise exchange promised on cartesi prevents large selling of tokens (relative to market cap). Dex is decentralised by allowing community to vote on the allowance of buy and sell orders/ above a community-voted volatility cap, achieving some form of price smoothing, which should in theory avoid scam wicks etc. How does that sound?
@colinsteil @Carlo
undefined says You want to limit the dex users to small-to-medium accounts only?
undefined says No. I'm suggesting the community votes on a volatility cap, and any exceptions are community-voted. That allows for significantly enhanced price smoothing imo
undefined says You know the largest holders of the token will be able to single handedly overpower the rest of the community vote?
undefined says It is configured in `docker-compose-testnet.yml`, once we have our infrastructure ready for deploying on these networks, then we'll adjust the confirmation block parameter accordingly. You can give it a try modifying it to one block.
undefined says That might be so but the dex needs some form of inverse prioritizing of processing orders. So if big whales want to sell and vote it in, their orders get filled last. Something along those lines
undefined says That doesn't make sense, and should not be implemented. Why should someone be able to trade just because he has less than me?
undefined says Because if a whale puts a large order to manipulate the price, they shoot themselves in the foot as go back of the queue
undefined says it doesn't make sense.
undefined says Thanks! I'll try to modify `--confirmations` for `cartesi/rollups-indexer:0.6.0` and modify `--sc-default-confirmations` `--tx-default-confirmations` for `cartesi/rollups-dispatcher:0.6.0`
undefined says I've to check the exact variables to modify with the team internally! You can test meanwhile if this is working well for you!
undefined says @max.aetheras Probably a good idea to wait for the next release, we might see network specific docker-compose files pre-configured.
undefined says Hello guys! I'm trying to run the command `yarn start erc20 deposit --amount 1000`and it's throwing the following error:
```shell
Error: cannot resolve ERC-20 address for chain 31337
     at Object.handler (/home/oshiro/calindra/rollups-examples/frontend-console/src/commands/erc20_commands/deposit.ts:95:15)
```
undefined says I'm running the erc20 example: https://github.com/cartesi/rollups-examples/tree/main/erc20
undefined says the `CartesiToken.json` file does not exist inside `deployments/localhost` folder
undefined says I found Cartesi's token address in the log:
`rollups-examples-hardhat-1                 | deploying "CartesiToken" (tx: 0xb84e1d8372547141b4e8fb9ebfb7a39ed43aa276ddb003bbcce12dba5db85362)...: deployed at 0x610178dA211FEF7D417bC0e6FeD39F05609AD788 with 1770294 gas`
undefined says now its working!

```shell
yarn start erc20 deposit --amount 1000 --erc20 0x610178dA211FEF7D417bC0e6FeD39F05609AD788
yarn run v1.22.19
$ ts-node src/index.ts erc20 deposit --amount 1000 --erc20 0x610178dA211FEF7D417bC0e6FeD39F05609AD788
connecting to http://localhost:8545
connected to chain 31337
using ERC-20 token contract at address "0x610178dA211FEF7D417bC0e6FeD39F05609AD788"
using account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
approving allowance of 1000 tokens...
depositing 1000 tokens...
transaction: 0xb19018bd725cd39605ee8567808aa4297f5f4bdb8a816543e9f4367d0abfe57f
waiting for confirmation...
deposit successfully executed as input 1 of epoch 0
Done in 12.54s.
```
undefined says Hello, I have a problem with executing vouchers and I don't really know what is the problem, any help?
Backend function: https://github.com/wchfs/trip-poc-dapp/blob/f19993ecb376e8d034aa657cd9c8c08915e25321/backend/src/core.rs#L298
Frontend function:
```typescript
async function execute() {
  const variables: VoucherQueryVariables = {
    id: "1",
  };

  ApolloService.getClient().query<VoucherQuery, VoucherQueryVariables>({
    fetchPolicy: 'no-cache',
    query: VoucherDocument,
    variables,
  }).then((response) => {
    if (response?.data?.voucher) {
      const voucher = response
        .data
        .voucher
        // .filter<PartialVoucher>((n: PartialVoucher | null): n is PartialVoucher => n !== null)[0];

      if (!voucher) {
        return;
      }

      const decodedPayload = ethers.utils.toUtf8String(voucher.payload);

      // const payload_object = JSON.parse(decodedPayload);
      // console.log(payload_object.data);
      if (!voucher.proof) {
        throw new Error("no proof");
      }

      const proof: OutputValidityProofStruct = {
        ...voucher.proof,
        epochIndex: voucher.input.epoch.index,
        inputIndex: voucher.input.index,
        outputIndex: voucher.index,
      };
      console.log(voucher.payload);
      RollupService.getContracts().outputContract.executeVoucher(
        voucher.destination,
        voucher.payload,
        proof
      ).then((value) => {
        console.log(value);
      })
    }
  }).catch((error: GraphQLError) => {
    console.log(error.message);
  });
}
```
Error: (image)
undefined says It seem that the machine hash is "0x". 
This normally happens when you are running on host mode, so the you don't have a machine state. (Are you testing on host mode?)
That's why you can't execute vouchers when you are testing on host mode.
undefined says Yeah, I'm testing on host mode... I thought that if I had proof of the voucher everything should works. My bad?
undefined says Indeed, to execute a voucher you need the proof. But the proof also includes the machine state, which is not generated when you are using host mode.
So, to execute the vouchers, your DApp should be running inside a Cartesi Machine.
undefined says Hey @max.aetheras 
Regarding the parameters that should be changed for low latency in Arbitrum/Optimism are:
- rollups-dispatcher: --sc-default-confirmations with value 0 instead of 10 and --tx-default-confirmations with value 1 instead of 11,
- rollups-indexer: --confirmations with value 0  instead of 10

In the next release, these parameters will be already persisted in an environment file for each network.
undefined says Hey @fabio.oshiro 
Our hardhat image export the contract addresses and abis to a json file in a docker volume
The  
 ```
        "--export",
        "/opt/cartesi/share/blockchain/localhost.json",
```
parameter in docker-compose.yml export to this localhost.json, and the volume mapping 
 ```
    volumes:
      - blockchain-data:/opt/cartesi/share/blockchain
```
maps to blockchain-data volume.
To check the contents you can inspect the volume, then cat the json file.
List the volumes:
``` docker volume ls ```
Inspect the volume (rollups-examples_blockchain-data in my case)
``` docker volume inspect rollups-examples_blockchain-data ``` 
It will give you the location of the volume (/var/lib/docker/volumes/rollups-examples_blockchain-data/_data  in my case), which you can check on your host
 ``` 
sudo cat /var/lib/docker/volumes/rollups-examples_blockchain-data/_data/localhost.json
sudo cat /var/lib/docker/volumes/rollups-examples_blockchain-data/_data/localhost.json | jq '.contracts.CartesiToken.address'
```
undefined says Thanks. I'll give it a try
undefined says Hi team, it does not seem that validators can be added during the lifecycle of a validator pool
https://github.com/cartesi/rollups/blob/main/onchain/rollups/contracts/libraries/LibValidatorManager.sol

Is this the intended behaviour? Is a pool meant to live until there are no validators?
undefined says To summarise the questions -- what is intended the lifecycle of a pool of cartesi nodes?
undefined says Also, is there more clarity/docs/tokenomics around reward distribution for cartesi node operation in a validator pool?
undefined says *Thanks*
undefined says Hey Ryan! You're correct about our initial design decision. We are working on a version to make it more flexible, and interchangeable. We are also working on tokenomics for node operators. This may see the light of day early next year, no hard dates yet.
undefined says I see the open issue concerning diamonds was responded to, is it considered closed?
undefined says Thanks for bringing this to our attention! We addressed the issue a while back and it's good to be closed. @Guilherme responded on the issue as well!
undefined says Of course! Trying to do my part and help with housekeeping haha. Have a great weekend!!!
undefined says Some questions @Shaheen, 
Where do rollups off-chain logic actually run, and how does this software relate to the Noether nodes?
Is the rollup off-chain logic run inside of the Cartesi Machine?
What would be defined as a Cartesi Node? (Is this the Off-chain Rollup tech?)
ie. in this architecture https://docs.cartesi.io/cartesi-rollups/dapp-architecture/ -- I don't see a reference to Noether.
undefined says Also can a Validator opt-out of a given Rollup cycle? (ie. in case there infra/env is broken?)
undefined says Hey Ryan! The off-chain logic of the Cartesi-Rollups runs inside the Cartesi Machines. Here, Cartesi Nodes could be seen from two pov - user and validator nodes. The user nodes simply advance the machine state while the Validator Nodes are the ones responsible to run and submit proofs to the underlying chain. Noether, on the other hand, is a PoS side-chain and its nodes serve a different purpose of data-storage solution.
undefined says There are time durations defined to execute and submit proofs on-chain. In case something goes wrong in that period, the validator will miss the chance. It's explained in details under Components section here https://docs.cartesi.io/cartesi-rollups/components/
undefined says Ah I see. 
To clarify, if a validator does not respond to a rollup with a fraud proof, by default the rollup is accepted -- regardless of whether the validators are indeed experiencing downtime.
Is this correct?
undefined says There usually should be a time window, 7 days? a challenge period. I guess a validator won't be down for that long
undefined says 7 day challenge periods? That‚Äôd mean that it‚Äôd take 7 days for transactions to affect L1 blockchains right?
~~But‚Ä¶ that doesn‚Äôt sound right either~~

Update: This is normal for Rollups on Eth Mainnet
undefined says It's a configuration that you can carefully change. It doesn't have to be 7 days. The rollups infra is flexible in this sense as involved parties/stakeholders can decide the duration. Say, you have a small number of validator nodes, healthy with near zero downtime, it would make sense to shorten the challenge period.
undefined says Hi guys, I would like to setup some environment variables to configure my cartesi-dapp.
It seems that I need to pass in these environment variables when building the cartesi-machine.
Is there any suggestion to do so?
undefined says You are able to do this, here:
undefined says We are having  different settings according to different gas fee level for various chain, 
if I choose to set these settings as environment variables in `entrypoint.sh` or `build-machine.sh` we will need to maintain many version of `server-manager` docker images for them.
undefined says Environment variables are typically related to the process so if you are using only 1 thread you can create those in any function of your application it should not be necessary to declare all of your environment variables while building the machine. I'm not sure if this is a good approach.
undefined says Hey guys, i have an existing ruby on rails API running on a docker container in a simple linux server...is there any way i can make it run using cartesi rollups?
undefined says In cartesi docs..all i see are basic python / js examples..how do i include my existing API docker container inside a cartesi machine..thanks for helping
undefined says Hi guys, I've tried to deploy our dapp contract to `Optimism on Gnosis`, and get the following error:
```
[+] Running 4/4
 ‚†ø Network cartesi-dapp_default       Created                                                                               0.1s
 ‚†ø Volume "cartesi-dapp_machine"      Created                                                                               0.0s
 ‚†ø Container cartesi-dapp-machine-1   Created                                                                               2.2s
 ‚†ø Container cartesi-dapp-deployer-1  Created                                                                               0.2s
Attaching to cartesi-dapp-deployer-1, cartesi-dapp-machine-1
cartesi-dapp-machine-1   | 8ffe558139fcc84968fc5dc8c90b998cb3210a45f212ebcc46df752f885fe2e9
cartesi-dapp-machine-1 exited with code 0
cartesi-dapp-deployer-1  | connecting to https://optimism.gnosischain.com
cartesi-dapp-deployer-1  | unsupported network 300
cartesi-dapp-deployer-1 exited with code 1
```

Does that means  the `dapp-deployer` does not support `Optimism on Gnosis` currently?
undefined says Hi guys! I need some help to understand this error:
https://github.com/cartesi/rollups-deployment/actions/runs/3579479166/jobs/6031589335
undefined says ```
Run RPC_URL="https://goerli.infura.io/v3/501b4a58738b45919b9c27d709fd624d"
  RPC_URL="https://goerli.infura.io/v3/501b4a58738b45919b9c27d709fd624d"
  cast call --chain goerli --rpc-url $RPC_URL 0xF494e14115f5AEa6BFB6f1e224F53F48A95E6D21 'getValidatorIndex(address)' 0x18930e8a66a1DbE21D00581216789AAB7460Afd0
  shell: /usr/bin/bash -e {0}
Error: 
(code: 3, message: execution reverted: validator not found, data: Some(String("0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001376616c696461746f72206e6f7420666f756e6400000000000000000000000000")))
Error: Process completed with exit code 1.
```
undefined says Hey @fabio.oshiro 
To deploy using the  rollups-deployment project you should add the validators when you are deploying the contracts, which is done when you run the ```DAPP_NAME=<dapp>  docker compose -f ./deploy-testnet.yml up```
To add the validators you should add the parameter --validators with the following value (cartesi insfrastructure validador address) to the create command of the deployer service```0x18930e8a66a1DbE21D00581216789AAB7460Afd0```
Using this file as a base https://github.com/cartesi/rollups-examples/blob/5f7d0f991b00a281a8a4c7b092643cc917682c4e/deploy-testnet.yml#L25 you should add this line to the list
```
        "--validators","0x18930e8a66a1DbE21D00581216789AAB7460Afd0"
```
We are working on the rollups-deployment docs to add this note.
undefined says 
undefined says I think it will work!
```
cast call --chain goerli --rpc-url $RPC_URL 0xA17BE28F84C89474831261854686a6357B7B9c1E 'getValidatorIndex(address)' 0x18930e8a66a1DbE21D00581216789AAB7460Afd0
0x0000000000000000000000000000000000000000000000000000000000000000
```
Thks @lyno
undefined says Hey there! We haven't tested Ruby extensively inside Cartesi Machine yet. Will keep you posted as and when we make progress here. What are you trying to build with Cartesi Rollups?
undefined says Hi! I have a question about vouchers
code:
https://github.com/wchfs/trip-poc-dapp/blob/91e12c32d0a9ceb98623f76ae3a47aa2c9ade3a7/backend/src/core.rs#L319
https://github.com/wchfs/trip-poc-dapp/blob/91e12c32d0a9ceb98623f76ae3a47aa2c9ade3a7/frontend/src/views/Vouchers/List/VoucherListItem.vue#L62
There is some waiting after executing the voucher? I'm trying to withdraw some ether from the dApp and nothing is showing up on the Metamask.
undefined says I'm testing in the production mode on the local machine.
undefined says In my case, I faced this problem when the amount of token you are trying to withdraw is larger than the amount of token the DApp holds.
undefined says Did you figure out how to check the balance on the localhost?
undefined says After executing a voucher, there should be no extra waiting time, transaction acceptance apart.
Do you have the log of the transaction in the hardhat?
undefined says I'm not sure how to check this. Do you have some instructions/advice? I have only that transaction hash
undefined says Hey @wch-dawid-m | webchefs , I've made a simple custom commands file to add to the rollups example frontend console
You can add this file to frontend-console/src/commands

Then from the frontend-console directory you can run
```yarn start custom accountBalance --target 0xab12...34de
```
To check the balance
undefined says 
undefined says You can check the hardhat logs with 
```docker compose -f docker-compose.yml -f docker-compose.override.yml logs hardhat```
It will have all transactions there, then you can check if something happened
undefined says Ok, so - while I tried to execute the voucher for 0.6 ETH:
Logs:
```
backend-hardhat-1  | Mined block #695
backend-hardhat-1  |   Block: 0x4d4a9342e3c53974398055d3bfb5127204b446abb09c9a6a63c8b14ea3018ea4
backend-hardhat-1  |     Base fee: 7
backend-hardhat-1  |     Transaction:       0x9dba5522e07b1906d3fffa38a86bcce029e33b352cd7a57e6c3538f28220e573
backend-hardhat-1  |       Contract call:   CartesiDApp#<unrecognized-selector>
backend-hardhat-1  |       From:            0xcd3b766ccdd6ae721141f452c550ca635964ce71
backend-hardhat-1  |       To:              0xf8c694fd58360de278d5ff2276b7130bfdc0192a
backend-hardhat-1  |       Value:           0 ETH
backend-hardhat-1  |       Gas used:        114200 of 138288
```
Balance:
```
user   balance(0xcd3B766CCDd6AE721141F452C550Ca635964ce71): 9999.398979972995239874
target balance(0xF8C694fd58360De278d5fF2276B7130Bfdc0192A): 0.6
```
I will try to go through every line of code, one more time üòü  I'm open to suggestions!
undefined says I seems that the voucher executed correctly. No error on hardhat and the final balance has the 0.6 ETH of the voucher, right?
Does the Metamask still doesn't show any balance?
undefined says Yeah, nothing in the Metamask
After I changed the address to the msg_sender address instead of the rollup_address in the response I have something like this, but still nothing in the Metamask. Maybe we can jump on a call to make some debugging together?
undefined says Yes, sure! We can schedule a meeting.
undefined says I've answered in the rust channel
undefined says I'm trying to run Ultrachess on the 0.8.1 release and when I run `docker-compose up` I'm getting the following error:

```
server_manager_1 error opening image file '/opt/cartesi/share/dapp-bin/0000000070000000-60400000.bin' when initializing uarch ROM: No such file or directory StatusCode: 10 side_effect: 0
```

When I build the fs and inspect, I see:

```
# ls /opt/cartesi/share/dapp-bin

total 337000
drwx------ 2 root root      4096 Dec 11 08:38 .
drwxr-xr-x 1 root root      4096 Dec 11 08:38 ..
-rw-r--r-- 1 root root     61440 Dec 11 08:38 0000000000001000-f000.bin
-rw-r--r-- 1 root root     24576 Dec 11 08:38 0000000000020000-6000.bin
-rw-r--r-- 1 root root   2097152 Dec 11 08:38 0000000060000000-200000.bin
-rw-r--r-- 1 root root   2097152 Dec 11 08:38 0000000060200000-200000.bin
-rw-r--r-- 1 root root      4096 Dec 11 08:38 0000000060400000-1000.bin
-rw-r--r-- 1 root root   2097152 Dec 11 08:38 0000000060600000-200000.bin
-rw-r--r-- 1 root root   2097152 Dec 11 08:38 0000000060800000-200000.bin
-rw-r--r-- 1 root root 134217728 Dec 11 08:38 0000000080000000-8000000.bin
-rw-r--r-- 1 root root  71303168 Dec 11 08:38 0080000000000000-4400000.bin
-rw-r--r-- 1 root root 131072000 Dec 11 08:38 0090000000000000-7d00000.bin
-rw-r--r-- 1 root root       730 Dec 11 08:38 config.protobuf
-rw-r--r-- 1 root root        32 Dec 11 08:38 hash
```

Hoes do these files work? Why is it looking for a file that doesn't exist?
undefined says Hello,
Is there a faster way to restart the DApp backend in production mode without having to bring the environment down and up again, with:
docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml down -v
and
docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml up
undefined says Not yet, since the back-end in production mode is inside the docker containers this is the fastest way to do it.
undefined says Hey @eigendude , how did you do to run Ultrachess on the 0.8.1 release? I tried as well and it seems fine for me.
To do it I created a new custom dapp using the create-dapp.sh script in rollups-examples/custom-dapp and copied some files to the ultrachess dapp (I created a patch).
Also, don't forget to run `docker compose down -v` so it will remove all containers and volume before running it again
undefined says Hello!
I was updating my application to the latest version of Cartesi Rollups and I noticed some new components.
The "server_manager_broker_proxy" and the "redis".
So, anyone knows the purpose of these components? I know redis is an in memory database, but how it is being used here?
undefined says I also noticed a new volume: redis-data
undefined says We are improving the internal architecture of the Cartesi node. Redis is used as a broker for messaging between node components.
undefined says @wch-dawid-m | webchefs You can follow this thread here https://discord.com/channels/600597137524391947/813381014104571904/1016329853303267379
undefined says Point 2 for challenge period!
undefined says Will there be a migration
undefined says With Cartesi
undefined says Could you elaborate what do you mean by "migration"?
undefined says hello, I'm still learning about the technology, and I have a conceptual question: in the tutorials, there are some examples of dapps that are already running on Ethereum testnets and other examples are not, which is evident by not spending any ether to run the transactions in these examples. Thus, for these examples that do not run on testnets, my question is: does the mining that I see happen when I ran the containers structure in Docker happen in a private blockchain of Cartesi?
undefined says Hey guys im trying to run the rollups examples, and im having this error, has anyone stumbled in this error too?
undefined says Hello there! Thanks for taking time to learn and dive into the tutorials! 
Yeah, not all examples are deployed right now but spending ether is not an issue on testnet. You'll be spending Goerli eth for transactions. Other examples require more polishing and stability before we deploy them to the testnet. As you understood, you can run any of the rollups-examples in your local machine. Although, the underlying blockchain instance in this case is the local Hardhat node. It's a handy way to spin up a local Ethereum devnet.
undefined says Seems like a bad setup issue! What OS and Docker version are you running?
undefined says Hi, I managed to fix it by cloning directly from wsl
undefined says So it was a path issue?
undefined says apparently yes
undefined says Thanks!!
undefined says Hi üëã, we‚Äôre interested to speak with Cartesi team member as part of product study for decentralize sequencer. I work for a zkp protocol called Espresso Systems
undefined says Is there someone I can reach out to for a quick chat? Thanks
undefined says Hey there! Could you drop me a DM with some more details?
undefined says Hello! I'm running the examples in github and I'm having problems with the erc20 and auction examples. When I run the command "yarn start erc20 deposit" to make the deposit, I always get an error message, as if some parameter was missing. Are there any necessary steps that I'm not doing? Thanks
undefined says Hey @jpaulobg , what is the full command that you are running?  What is the error?
`yarn start erc20 deposit --amount 10` should do if you running one of the examples.
You can run `yarn start erc20 deposit --help` for help.
Also, note that when run this way, it gets the DApp address from `deployments/localhost/dapp.json` file, so it expects that you running the example using local hardhat chain. you can check help for other options.
undefined says You guys raised a hell heck of $money from big funds. üòÅ üëç By the way, why a ZK protocol needs a decentralized sequencer? Is there any special design with Espresso System?
undefined says Hey @lyno , thanks for the reply. When I use the command yarn start erc20 deposit --amount 100 in both dapps I always get the error in the image attached. Am I doing anything wrong?
undefined says @lyno , for the screen captured, I guess yarn can not find the ERC-20 address, but the file deployment/localhost/dapp.json exists.
undefined says By running the examples following the instructions you shouldn't need to provide any extra information.
But if you still have the same error you can provide the dapp address (that you can get from `deployments/localhost/dapp.json` file) `yarn start erc20 deposit --amount 100 --address 0xF8C694fd58360De278d5fF2276B7130Bfdc0192A`
It's worth mentioning that I had to wait for some seconds after the `docker compose [..] up` command until the hardhat mined some blocks. Otherwise, I would get the same error that you got.
undefined says Hello @lyno , I got the same error running the example on two different computers even though I used the address parameter. Interesting that all the other examples work fine for me, using the sequence of steps:  cd <example>
docker buildx bake --load    cd <example>
docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml up  and after that use the yarn command. Seems that the problem is the erc20 option.
undefined says 
undefined says The token address is read from the `deployments/localhost/CartesiToken.json` file. 
It should read from this file by default, but in any case you can check the file provide the token address:
`yarn start erc20 deposit --amount 100 --erc20 0x610178dA211FEF7D417bC0e6FeD39F05609AD788`
undefined says Hello @lyno , it worked fine for me. The problem is that I don't have the deployments/localhost/CartesiToken.json file, only deployments/localhost/dapp.json and this was the whole problem. Strange that I followed all the installation steps in the tutorial. Thanks! Taking the opportunity, I am receiving outputs from past examples when I use "yarn start notice list" even removing the containers from the previous example and creating new ones for the current example. Would you know what I can do to resolve this?
undefined says After you stop docker compose you should always run the `docker compose [..] down -v` command (in particular running the examples `docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml down -v`). It removes the created containers and volumes, and ensures that the environment is not polluted for the next time you start another example.
undefined says @Shaheen @colinsteil @Carlo 
Hope you guys are well
Will Cartesi have ChatGPT integration ? 

https://www.analyticsinsight.net/how-to-run-the-chatgpt-locally-using-a-docker-desktop/
undefined says Hello @lyno, I always use docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml down -v when I am  shutting down the examples and  I even used the command docker rmi $(docker images -aq) to remove all the images and download them again, but I am still receiving only the output from the calculator example and I do not receive new outputs from other examples. Is there any file that retains this information in the system that I can delete to normalise the situation?
undefined says You tried to clear the docker cache? this happened sometimes with me and combined with the compose down command can be useful delete the docker cache too.
undefined says Hello @Marcus Vin√≠cius , Thanks.  Is "docker system prune" the command to clear the cache? If so, I've run it and it's still the same. Here's a startup screen of the containers showing when this data that is continually presented as the current output is received by rollups-example-server-manager. Would it be something residual in the database?
undefined says When running echo example, why does it take long time to receive response (around 30 seconds) despite rollup running locally and backend running as host?
undefined says Yes , it is the prune command. when this happened to me, i've done those steps to clean everything (considering the docker is running):
1 - the down -v command, to remove the volumes
2 - docker ps to show all things related to docker running
3 - docker stop $(docker ps -a -q) < To stop and remove all docker containers (even those not related to the current application you're runnign)
4 - docker system prune --all to clean everything (be sure to set the --all flag)
5 - docker ps (This will show now a clean list, if it show anything in the list you must delete again)
6 - If you are using the front-end console, it can help to clean and rebuild
7 - Try to run and see if it persists

In all cases this problem happened to me, those steps solved the problem. If you don't mind, you can try thos steps in this sequence and see if it helps.
undefined says You should keep in mind that the response can take a while since the blockchain has a 10 seconds window to mine the block answer. It can also change the time depending on the hardware üòâ
undefined says If its running on local host, why does it take that long (ethereum local doesn't take that long)? If its on chain, how long would it take?
undefined says It is a configuration that to mine the blocks has this time window. Its different from ethereum. On chain would have the same 10 seconds window
undefined says Its taking 30 seconds. Any ideas why?
undefined says On a second note, what is the best approach to send a file from backend to frontend? Its around 15-50 mb, would returning it as json within a notice in "submit output" be reasonable or is this saved on the rollup blockchain and would be too big?
undefined says Maybe its a combination of the mining + something else. I don't have more ideas about it üòâ
undefined says storing 15-50 mb in the blockchain would be too big for sure. you should consider the blockchain limitations on moving a file this large
undefined says As Marcus mentioned, *notices* are provable on-chain, generating it for 15-50mb is not the way to go. You could generate a *report*(non-provable) for that size and just have a hash of your output json as *notice*. We can discuss your specific case further, do let us know!
undefined says Ideally, it shouldn't take that much time. Still the same? Which version are you on? I'll try to check!
undefined says Hello @Shaheen , I already tried a lot of things("docker compose -f ... down" , "docker system prune", "docker rmi $(docker images -aq)"  but I keep getting output from a previous example run that I can't get rid of whenever I use "yarn start notice list". Are there any files or databases on the system that you retain that I can delete?  Here's a startup screen of the containers showing when this residual output  that is continually presented as the current output is received by rollups-example-server-manager. Would it be something residual in the database?
undefined says This is normally due to residual volumes from previous instances
That's why it's important to run `docker compose ... down -v` (don't forget the `-v`) to remove the containers and volumes.
Now you should run the `docker compose ... down -v`, then you can check if there are still volumes:
`docker volume list`
and remove them with:
`docker volume remove [...]`
undefined says Thanks for your feedback. Sounds reasonable approach.
undefined says Sorry, It's my bad, those 30 seconds are mostly the time to get the front-end console up and running.
undefined says oh, now it makes sense =). Front end console is a way for us interact with the application and it has it's own time to run üòÑ
undefined says In my previous cases that i faced this problem the down-v command was enough to solve it. There was a time that it wasn't working so i've done the steps i mentioned above and than it worked
undefined says @jpaulobg , have you tried this sequence of steps and it still persists?
undefined says Problem solved! Thanks!
undefined says hello @Marcus Vin√≠cius, yes, I tried the steps but the problem persisted. Only after I erased the volumes in the system the problem was solved.  But thanks for your assistance!
undefined says üôèüèº
undefined says may I know if the cartesi core developers are around?
undefined says I'd like to know some of the learnings from your VM vs cannon(MIPs) and arbritrum (WAVM)... how were you able to enable GC friendly+multi-threading based deterministic computing within memory based FP's?
undefined says also in order for you to scale you will need a good DA plan, what is your plan for rollups + DA?
undefined says At its core, our custom VM, the Cartesi Machine is based on RISC-V ISA. It allows us to boot a full Linux instance on top of it. Hence, a better Web2 like developer tooling while keeping the blockchain security guarantees. It's a single core CPU with soft floating at the moment. No multi-threading to keep computations deterministic! It's a complex task to achieve determinism with parallel computations.
On DA, you could think of Cartesi as a modular execution environment that can be plugged with L1s or L2s. Currently, we've support for Ethereum and L2s(Optimism, Arbitrum and others) but you could think of plugging this execution environment with something like Celestia DA layer. An interesting article on our rollups thesis and DA that you might like https://medium.com/cartesi/application-specific-rollups-e12ed5d9de01
undefined says Soft floating? I saw recent support here is this it?
undefined says https://github.com/cartesi/machine-emulator/commit/62a608f9535263742791c6b71e6d312c320f2419
undefined says @Shaheen
undefined says Ok so at vm level you disable multi threads even if program has multiple threads
undefined says Yup I read that one thanks, on our layer 1 we are secured through bitcoin auxpow and offer rollups short term high availability DA aswell (PoDA) this is where the most secure settlement of rollups txs can be
undefined says https://jsidhu.medium.com/blockchain-idealisms-b61c5781ddc3#3ea3
undefined says Yes! It's a work in progress!
undefined says Always keen to look into DA solutions! Will def share internally as well!
undefined says Hello, in the docs, there is the excerpt " The assumption that state updates will most likely be honest often gives solutions like this the name of Optimistic Rollups. Naturally, this optimism comes paired up with financial incentives for honest behavior...". Would it be possible to suggest me a paper that better explains this reward mechanism?
undefined says AFAIK we haven't published any paper yet that explains the rollups reward mechanism in details. If you're interested here's a link to Ethereum Rollups docs that has multiple resources to dive deeper. The actual implementation of "rewarding and slashing" may differ on a protocol basis but the fundamentals would remain the same. https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/#top
undefined says thanks,  I'm using Cartesi in a Federated Learning application that also uses rewards to encourage nodes to work honestly which I saw is very close to the purpose of rewards in Optimistic Rollups.
undefined says Hey guys just starting to learn about Cartesi and how it works as a dapp developer! I've got a basic understanding of cartesi and hopefully somone can correct me if I'm wrong. If I want to build a dapp on cartesi, let's say a basic lottery dapp. I can use docker to deploy a cartesi VM on something like digital ocean then write the smart contract logic in python which basically talks to the cartesi VM via http requets? I staht correct?
undefined says Hello guys,  I'm trying to use "yarn start input send --payload" command inside a python code passing the value of a variable as payload using the os.system call but when I try to see the notices, only the variable name is published, not the content. Can someone please help me?
undefined says Hey @user2m! Good to see you learning Cartesi tech! üí™ 
So your backend logic that you write in Python(or any other language) is packaged to run inside the Cartesi Machine. There is off-chain and on-chain deployment involved in this process. In general, you follow the below steps:
-> Build and publish the Cartesi Machine with your DApp backend
-> Deploy Rollups smart contract to a public network
-> Deploy the DApp validator node 
We've made it easy to instantiate validator node. Refer this readme for deployments https://github.com/cartesi/rollups-deployment/blob/main/README.md
undefined says Replied in #üêç‚îÉpython channel! Need a bit more info here!
undefined says I am trying to gain understanding about Cartesi and it seems to me an advantage of it that I have not heard highlighted much is the fact that, to the user, Cartesi Dapps are effectively layer 1 dapps that use CTSI as gas - no bridging assets to layer 2's like Polygon. Meanwhile they are faster and cheaper than eth mainnet and offer the ability to compute off chain. Can someone correct my misconceptions here so I can have some better understanding? thanks in advance
undefined says The general concept of rollups applies to Cartesi with some key design decisions. From a user‚Äôs pov, it does feel similar to how you‚Äôd interact with L1 smart contracts. The transaction still happens on-chain but the execution is off-chain. With Cartesi Rollups, you compute off-chain inside the Cartesi Machine, a RISC-V based deterministic VM. The execution environment is a key difference to other rollups as you get Linux with a sophisticated developer tooling. You can run good old languages and libraries in a decentralized manner. There are no gas associated computations inside the Cartesi machine but you do incentivize the validator nodes for submitting proofs of computation on-chain. Just like any other rollups solution, you are required to move data and assets to Cartesi DApps. We have a similar mechanism of teleporting assets such that they have representation inside a specific DApp Rollup. In case of any disputes, you fall back to the base layer for resolution. High computational scalability with app-specific rollups design and a better developer tooling(Linux runtime) while still keeping the security guarantees of the underlying chain sets Cartesi apart. Hope it gives more clarity! üôÇ
undefined says When will the main network come online
undefined says If you wanna build DApps on top of Cartesi rollups, there is no reason to wait for the mainnet release. You can start right away. For any other purpose, we don't have a specific date rather we keep a milestone based roadmap. Stay tuned to public announcements for all upcoming releases!
undefined says Thank you, Shaheen, for that detailed response- very helpful. I do have a follow up question. If you don't mind, could you explain the process a little bit more on how the "mechanism of teleporting assets such that they have representation inside a specific DApp Rollup" looks to a user and also how it works underneath? I tried the voting dapp built on Cartesi and it has peaked my interest in Cartesi more. I know it is chain agnostic which is awesome and that transactions are rolled up to the L1, but I am a little fuzzy on how data is moved to and from the Cartesi Dapps. thanks again
undefined says Shoutout to Shaheen for always taking the time to make the complex idiosyncrasies of Cartesi accessible to all. Also great questions all over the discord!
undefined says hey there guy, I am new to Cartesi, is this the channel for beginners to start learning?
undefined says What I think would help is firstly learning how to build a dapp with Cartesi from scratch
undefined says you are free to ask anything here or in #üê£‚îÉbeginner-friendly chat. Firstly learning , i suggest you to read the docs here: https://docs.cartesi.io/cartesi-rollups/
and also start reading the github rollups examples here: https://github.com/cartesi/rollups-examples. If you have any questions you can always ask here üôÇ
undefined says Sure I‚Äôll try to explain this part! So we know the architecture of a Rollups DApp has both on-chain and off-chain components. The on-chain components include smart contracts for functions like submitting inputs, receiving outputs, depositing assets etc. The off-chain components read data emitted by the blockchain and process it.
Coming to teleporting the assets, for a user, it depends on the DApp developer how they want to show deposits and withdrawals on the front-end. You could think of it as a DApp specific user wallet. To dig in the details, let‚Äôs take the example of the Voting DApp, when you deposit some CTSI(or any other erc20 token), you essentially interact with a smart contract function ‚Üí `erc20Deposit`. We call this on-chain component, the *Portal*. Your tokens gets transferred to this portal contract, it encodes the data and emits it as input msg to the off-chain component. The encoded msg structure represents your assets off-chain. Refer structure here https://github.com/cartesi/rollups/blob/main/onchain/rollups/contracts/facets/ERC20PortalFacet.sol#L45
Once the deposit msg is emitted, it is now upto the DApp‚Äôs backend how it validates it and adds logic around it. Here‚Äôs how Voting DApp is processing this deposit call https://github.com/Sotatek-ManhNguyen3/cartesi_voting_system/blob/feature/profiles/voting.py#L257

Again, on moving outputs of a DApp back to the blockchain, a similar kind of msg calling happens but this time with proofs of validity attached. 
There are other internal components that talk to each other in moving data to and from the blockchain. If you wanna dig deeper, the diagrams and references in docs explain this very well. Here https://docs.cartesi.io/cartesi-rollups/components/
undefined says Hi Cartesi team, I have a few question on rollup. How does the rollup check for transaction validity? Is it expected that sequencer would exclude invalid transactions or is that on the prover?
undefined says Also, is validating ordering of transaction part of task that the cartesi rollup can assume?  That is, the rollup will handle ordering constraints on their own, without guarantee ordering from the sequencer?
undefined says Lastly, would the design incorporate both trusted and untrusted ‚Äúsequencer‚Äù potentially?
undefined says Hello, @minw890 !
We currently do not have a sequencer, so these are my personal thoughts and how I'd go about it (maybe other team members would have different opinions):

We're app-specific rollups, so the "validity" of inputs varies from dapp to dapp. On the other hand, the input comes through an L1 contract, so there are some guarantees around that! I think a sequencer should guarantee some basic stuff about transactions‚Äîconformity to the agreed-upon format, the validity of the signatures, etc.

I also think the sequencer should be responsible for guaranteeing to order every once in a while. Otherwise, you don't get any gains in usability from the dapp perspective (faster transactions, for instance) apart from reduced costs (batching the transactions). And yeah, I see the possibility for both trusted and untrusted sequencers, which can also be defined on the application level! Trusted sequencers (or dapp approved sequencers) would have some advantages ordering-wise to improve the application's usability. Untrusted sequencers, I guess, would only serve the cost purpose.

What do you think?
undefined says Thanks @felipeargento That make sense. Also, for app specific rollup, if I understand it correctly, the transaction ordering is going to be specific to dApp and the rollup would be ok with handling ordering constraints ( not guarantee by the sequencer)
undefined says I think a sequencer that guarantees ordering is much more powerful. If someone interacts with an application through a sequencers that guarantees ordering (at least of the transactions that it received), they know the effects of their actions before the whole batch is posted on the base layer. Therefore, their interaction with the application is much faster than if they had to wait until the batch was posted on L1 and the block got sufficiently deep to be stable.

For applications in which the order of inputs is not very impactful for big windows of time (say a game with commit a reveal scheme) or an application which reorders transactions based on other arbitrary system, then the definition of order given by the sequencer is less important.

However, I'd bet that the big majority of applications would go for sequencers that could handle and guarantee ordering every x seconds, that'd be a key feature imo
undefined says Since the code runs deterministically the order is guaranteed no? The only thing you lose with a central sequencer is possible input inclusion via censoring
undefined says The sequencer must make the data available prior to epoch transition and the order is already inherent in the execution which cannot change unlike other rollup designs. The layer 1 if it has a DA solution can be invoked to save costs and rollup contract can check for data confirmation but pay no attention to order
undefined says So mev is solved aswell afaik
undefined says When I say "guarantee order" I mean that when someone sends their input to the sequencer, they'd ideally know where, in that batch of inputs, their message will be included. That is important so they can update their application state accordingly (the whole time traveling shenanigans)...otherwise you're not tapping into the UX benefits of having a sequencer, other than attenuating costs. 

About MEV, yeah...I was thinking about that the other day! I don't think it is solved because the mev agent can run/simulate all the pieces of the stack, no? Maybe adding some vdf forces the sequencer to commit to the order before knowing the effect of a transaction. Worst case scenario, it does make it harder to extract mev I'd say!
undefined says Hi guys, I restarted the server which the Cartesi node is running on by force due to some infra issue. 

And after the server become normal, I try to restart Cartesi node as well. 

At the beginning, I've seen the logs that indicates that the Cartesi dapp is trying to replay the inputs.

But after replaying some of the inputs, it keeps showing an error message like: `2023-03-01 08:11:22.381062 error server-manager pid:1 request-id:6e9ef2aa-b984-4661-afba-8135f4ef5306 Caught finish_error_yield_none active epoch has processed inputs`

At the same time, new in-coming inputs won't be handled by the Cartesi dapp.

This issue can not be solved by restarting the Cartesi node again.

Any one have the clue for this?
undefined says So you restarted the node and didn't redeploy the on-chain contracts, right? It seems like it has messed up with the sync with on-chain components.
undefined says Also, could you share the Rollups version the DApp was on?
undefined says Yes, I use the original on-chain contract. And our dapp is based on Cartesi rollup v0.8.1
undefined says @max.aetheras I was discussing this issue with the team, would be keen to know which components did you restart? The state is stored in the redis and postgres components. In case you restarted everything, did the above components resume correctly? It should ideally work if the whole node restarted gracefully. If not, it seems like a bug and we'll be pushing some changes in the architecture of DApps components in 0.9.0 release.
undefined says With the addition of redis, I've found a similar error. I solved this by doing `docker volume prune` when the composition was down to clear the redis volume
undefined says I removed the volumes and restarted everything , below is the script:
```
# stop and update containers
docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.aetheras.yml down --remove-orphans --volumes
# docker network prune
docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.aetheras.yml pull rollups_dispatcher state_server server_manager rollups_indexer query_server database

docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.aetheras.yml up -d
```
undefined says And I found following logs in postgres container:
```
2023-02-28 02:56:43.209 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 02:57:45.002 UTC [1883] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:02:53.534 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:03:03.209 UTC [1884] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:06:10.409 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:06:27.153 UTC [1885] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:13:48.750 UTC [1886] LOG:  using stale statistics instead of current ones because stats collector is not responding
2023-02-28 03:14:20.704 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:14:41.081 UTC [1888] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:22:04.711 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:23:59.129 UTC [1891] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:28:11.182 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:30:33.186 UTC [1892] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:40:48.419 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:42:01.129 UTC [1895] WARNING:  autovacuum worker started without a worker entry
2023-02-28 03:48:34.252 UTC [52] WARNING:  worker took too long to start; canceled
2023-02-28 03:48:41.631 UTC [1897] WARNING:  autovacuum worker started without a worker entry
```
undefined says Seems postgres not getting up successfully, @eigendude any inputs on how was postgres behavior for you after restarting the node?
undefined says I saw no postgress issues
undefined says @max.aetheras sent you a dm!
undefined says Hey friends, I met Zach at EthDenver and he told me I could use my Solidity code (it is a DeFi app using Aave) and deploy it on Cartesi so I could use the same logic on several chains, but so far the documentation doesn't talk about this
I'd be interested to know if it is doable and if you have examples/docs
undefined says You could use the same logic and deploy for multiple chains like Ethereum or layer 2s like Optimism and Arbitrum. But bear in mind the code will be running inside Cartesi Machine that doesn‚Äôt support Solidity rather other popular languages like Python, Rust etc. So if you wanna extend capability of your smart contracts, you could do that. You could get outputs from the DeFi contracts and feed them to the Cartesi Machine for some complex computation. You could think of a web2 library that you wanna function together with the contracts. Things you wouldn‚Äôt be able to do in Solidity. Porting the exact same contracts that run on Ethereum honestly won‚Äôt make much sense.
undefined says @L0GYKAL.eth Ultrachess is using DeFi contracts for non-zero-sum betting. I've integrated Aave V2, Curve, Curve DAO, and Uniswap V3. You can see the work here: https://github.com/Ultrachess/contracts/tree/main/tools
undefined says Just like how you can portal ERC-20 and ERC-721 to L2, I'm working on a bridge for portalling LP-NFTs. But because it adds a new diamond facet, I think I'd have to PR it to Cartesi.
undefined says Can  Cartesi Machine get access to web2 APIs directly, such as OpenAI/Huggingface APIs?
undefined says Not really! Once you build and deploy an application, you don't have access to the external API calls. The Cartesi Machine only sees the underlying chain as the source of truth(data availability layer). If you trust the source of data, you could always fetch the data and feed it to the machine. You could though build an application with a machine learning algorithm coupled with a dataset so you don't have to make external calls. We've some PoC machine learning examples. This might help https://github.com/cartesi/rollups-examples/tree/main/knn
undefined says What do you mean by fetching and feeding it into the machine? I saw the example and it seems the dataset is only packaged into the docket image during the build time. And is there any limitation on the machine in terms of storage and compute for deployment?Chainlink functions seem to aim to solve this problem. And I used that for the Eth Denver hackathon. It would be nice to see how both can be integrated with each other.
undefined says For ML use cases, the data is more dynamic and model is usually served as a micro service instead of packaging both into a docker image, especially for large model.
undefined says Yes, the example I shared packages the dataset with backend logic to run inside the Cartesi machine. By fetch and feed I meant to get outputs from a reliable service and then put them on-chain(feed to your DApp rollup input contracts)! Yeah something similar to an integration with Chainlink oracles if that makes sense for your DApp. Agreed, would be nice to see something like this developed in the dev tooling! We've grants program in case you wanna lead this, feel free to apply! 
The storage and compute depends on your requirements. Remember the machine is an emulator and a single core processor so, consider the associated overhead! Just to give you an idea we've seen some complex algorithms and libraries running inside the machine like OpenCV, Rust Mandelbrot set for generative NFTs,  we pulled off Doom running on the machine recently but yeah let us know if you're planning to build something, we could setup a meet as well to discuss your requirements!
undefined says Just curious, do you have an example for the " fetch and feed" pattern like how the Cartesi machine can integrate with Chainlink oracle/ Graph protocol? I think the computation layer would be more powerful when combining with the off-chain/on-chain data stream. Can you also clarify the system specs/constraint - "the machine is an emulator and a single core processor"? How likely can it support the computation for a deep learning model inference?
undefined says I just noticed, the last 4 commits of the v0.8.2 release are missing from the `main` branch: https://github.com/cartesi/rollups/commits/v0.8.2
undefined says Benedict from Espresso proposed a decentralized sequencer solution, solid?
undefined says https://docs.espressosys.com/sequencer/espresso-sequencer-architecture/introduction
undefined says His original post on Twitter: https://twitter.com/benediktbuenz/status/1636477106552025090
undefined says think we'll see a thousand flowers bloom on sequencer side with things like eigenlayer being available as a building block for sequencers too
undefined says Hello all, I registered for the hackathon and desperately needs some YouTube videos or detailed description on how to buidl with cartesi rollups
undefined says Replied in #deleted-channel üôÇ
undefined says Hello friends, lately i have been playing around with the rollups examples.
need some guidance please..
i created a new custom app at **~/rollups-examples/custom-dapps/hello**
after i build, i did a **docker compose up**
sending some input payload through the **frontend-console**
and then listing the notices also through the **frontend-console**
so far so good.. i can see the list of *notices*
and then i try to do **docker compose down**
and then **docker compose up** again
but when i do *notice list* it shows the previously entered payload, although i did the **compose down**
so, how to start fresh again..
thank you very much friends
undefined says The previous notices data is stored in docker volumes, seems like it didn't clear the volumes. Did you add `-v` at the end of **docker compose down** command? That will remove the volumes as well!
undefined says Any clue what the cause of this issue might be?
"
undefined says "app-rollups_indexer-1              | ERROR indexer::data_service: Failed to sync from server manager, details: Tonic status error: Status { code: Aborted, message: "concurrent call in session (already locked by>
app-rollups_indexer-1              |  INFO indexer::data_service: Connecting for sync to server manager http://server_manager:5001
app-rollups_indexer-1              |  INFO indexer::data_service: Trying to sync epoch status from server manager...
app-rollups_indexer-1              |  INFO rollups_data::database: Trying to connect to database postgresql://postgres@database:5432/postgres
app-server_manager-1               | 2023-04-19 20:47:47.288930 error server-manager pid:1 request-id:2ed63c39-4ff3-432e-8429-5dda53d60e06 Caught finish_error_yield_none concurrent call in session (already lock>
app"
undefined says This is the github workflow that I am using to run this:
undefined says Hey guys, I'm a full stack blockchain developer that wants to get into Cartesi. Can someone that understands the technology dm me? I have lots of questions. Thanks in advance!
undefined says Hey Lyo! Feel free to ask your questions here or in #üê£‚îÉbeginner-friendly channel! Might help someone else as well!
undefined says how do we query the states we stored in a machine? lets say that we have a mongo server, could we query from that server?
undefined says There are specific ways you could send input and query the machine state. You could create an `inspect` call to the machine with a payload and generate a `report` as output. For reference https://docs.cartesi.io/cartesi-rollups/api/inspect/inspect/
undefined says Might also be related to the previous issue mentioned. Running instances of a cartesi server on two different machines and both are yielding a different machine state. In fact, everytime I re-run a server, a different machine state is generated. Am I missing an obvious step when running ```DAPP_NAME=dapp docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.override.yml up
```
undefined says For visuals. Two different histories are generated from the same inputs (as seen in the logs)
undefined says @glockchain might be good to schedule a quick call with solutions architect regarding this. Dm me, I'll fix sometime!
undefined says Sounds good.
undefined says Hey Guys, Here's an App I am building, It was voted as #4 Best Health & Fitness Product of the Week on Product Hunt - https://thesenpai.vercel.app - Senpai AI - Let our AI guide you through meditation, Would love to hear your views
undefined says Hello, I have run a number of examples in host mode and it seems like when I use the frontend console to send something the request gets retrieved but the "handle_advance" does not
undefined says Is there a known reason for this?
undefined says It seems like the event gets "consumed", but the actual advance state execution is not done
undefined says How does the server-manager service behave to the sent input? Could you share full logs? Sometimes cleaning up the docker volumes and then restarting the backend node works.
undefined says I'm trying to run erc20 rollup example in my machine with docker buildx bake --load and I keep getting this error
undefined says 
undefined says Does anybody know what's the cause of it?
undefined says Just git cloned the repo, didn't do any changes to the files
undefined says I was trying to reproduce but it seems to build fine for me. So a bit more local context would help. I'm guessing it's the latest rollups-examples repo 0.14 that you cloned. Which OS are you on? And are you using Docker Desktop?
undefined says Hey @lusca, it seems that the error is when trying to run a riscv64 platform image.
Could you confirm that you either have docker desktop installed or docker engine with qemu-user-static installed.
Then try to run this image and see if it works
```docker run -it --rm --platform=linux/riscv64 cartesi/python:3.10-slim-jammy bash```
undefined says Are Cartesi's contracts deployed on the IoTeX network?
undefined says I don't think so we've rollup contracts deployed on IoTex network. What's your requirement here?
undefined says We deployed rollups to IoTex testnet, but we didn‚Äôt implement any examples there yet. Maybe @lyno did?
undefined says Actually we didn't deploy there for rollups 0.8. We probably will for next version (0.9)
undefined says it worked after reinstalling docker-desktop, thanks!
undefined says Thank you, I will wait for the next version.
undefined says Can any risc-v wizards out there take a guess at the appropriate CFLAGS to compile this library?

Here's my issue on the upstream C++ project: https://github.com/antimatter15/alpaca.cpp/issues/231


 I'm calling from within this Dockerfile:

```
# syntax=docker.io/docker/dockerfile:1.4
FROM --platform=linux/riscv64 cartesi/python:3.10-slim-jammy
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/apt/lists/*

WORKDIR /opt/cartesi/dapp
COPY . .
RUN chown -R root /usr/include/riscv64-linux-gnu
# RUN cp /usr/include/riscv64-linux-gnu/stubs-lp64d.h /usr/include/riscv64-linux-gnu/stubs-lp64.h
RUN make
```

Alternatively, the flags I have MIGHT be sufficient, if I can get the lp64 header to be found...
I'd love if the "copy" workaround would work in the docker container as it does for these folks: https://github.com/michaeljclark/busybear-linux/issues/10 (I've seen the files at that location for a previously built image? suspect the difference is from the different user)

TIA!
undefined says in general there's no vector instructions supported yet to my knowledge; also, i would double confirm this but it's lp64d abi on rollup machines isn't it? (floating point)
undefined says you probably want -march=rv64gc and mabi=lp64d (provided your toolchain is 0.13.0)
undefined says Is it possible to use mud & opstack with cartesi?
undefined says is it possible to use tensorflow in a cartesi machine? im having trouble installing it with RUN pip install -r requirements.txt in the Dockerfile
undefined says Unfortunately, it seems like TensorFlow does not provide prebuilt RISC-V binaries. This means you have to build yourself. But I would recommend trying TensorFlow Lite instead to run inference for machine learning models if that is an option for you. TensorFlow Lite is small and designed to run in embedded devices for inference, while TensorFlow is very large and designed to run on beefy machines for training. So I think you may have less headaches and more performance with TensorFlow Lite. Your can follow their instructions on how to build yourself in https://www.tensorflow.org/lite/guide/build_cmake
undefined says Google Fi cellphone released by Google official has Tensorflow built-in. Is it TensorFlow lite version?
undefined says This sounds like a nice discussion topic for #üéÆ‚îÉgames channel! Keep an eye out there üòâ
undefined says Did this work for you @deanna (she/her) ?
undefined says I think if I read the code correctly she reverted to the native toolchain in the image and it worked
undefined says looking at a someone's grants proposal and wondered: what kind of information is generally available to dapps inside a cartesi rollup? is there a notion of time, previous block hash, input/inbox hash or?
undefined says Take a look at the addInput function:
https://github.com/cartesi/rollups/blob/main/onchain/rollups/contracts/inputs/InputBox.sol#L46

The DApp has access to the Input Metadata, which is the first few arguments in the compute hash function (msg.sender, block.timestamp etc). And to the input itself (the payload). So you could use block.timestamp as a notion of time!
undefined says Here is even clearer, actually:
https://github.com/cartesi/rollups/blob/main/offchain/rollups-events/src/rollups_inputs.rs#LL63C27-L63C27
undefined says alright, that's quite useful indeed
undefined says Hey guys, I'm playing with the framework and wrote the echo example in Ruby. Here it is: https://github.com/web3melk/rollups-examples/tree/echo-ruby/echo-ruby

When I run `docker buildx bake --load` to build everything I'm getting an error.

See the output in the image. It says No such file or directory (os error 2)
When I build the docker image by myself, and go to the console I'm able to run the command `ruby echo.rb`.

I suppose it has something to do with the docker-bake.hcl but not sure. Or with the rolloup-init script...

Can anyone help me with this?
undefined says Hey @MŒûLK 
Currently there are 2 possible build options in the rollups examples and I think this is the problem you are facing https://github.com/cartesi/rollups-examples#build-strategies
The toolchain option, which uses a toolchain image so you could cross compile stuff to the Cartesi machine
And the emulated riscv option, which you can apt install files, compile, and all binaries will already be for riscv

So in your case I imagine you want apt install the dependencies, so you should use a riscv image such as cartesi/python:3.10-slim-jammy, cartesi/node:19-jammy-slim, or riscv64/ubuntu:22.04
Besides, the file docker-bake.hcl should be removed and you should create a link for  riscv bake file ` ln -sr ../build/docker-riscv/base.hcl docker-bake.hcl`
I did some tests here and the docker image creation succeeded with this Dockerfile:
```
# syntax=docker.io/docker/dockerfile:1.4
FROM --platform=linux/riscv64 riscv64/ubuntu:22.04

WORKDIR /opt/cartesi/dapp

RUN apt-get update \
    && apt-get install -y ruby ruby-dev build-essential \
    && gem install json http \
    && gem cleanup \
    && rm -rf /usr/lib/ruby/gems/*/cache/* \
    && rm -rf /var/apt/lists/*

COPY echo.rb .
COPY entrypoint.sh .
```
To play around and test if the image builds correctly I suggest that you use `docker run --platform=linux/riscv64 -it --rm <image> bash`
undefined says Nice! Thanks for the help, will work on it.
undefined says https://github.com/cartesi/rollups-examples/pull/23
undefined says After running my node for a while. Something seems to be corrupting inspect calls
``` Failed to inspect state: session is tainted```
undefined says Super nice! Im looking forward to see your next steps on doing more in Web 3 with Cartesi tech
undefined says Too many inspect polls from multiple different players at once = root cause.
undefined says I will do something unique and new üòâ
undefined says Hey Melk Im sure about it üòâ let me know how is that going!
undefined says Hi all, i am curious to know what is the max docker image size that we have tested for cartesi rollup
undefined says I am trying to execute a voucher, but I am getting the following errors. I'll be gratefull for any tip - what might be wrong ...
undefined says The errors could be a red herring. I see these exact two errors when Ultrachess gets confused and tries to call Name() and Decimals() thinking the diamond facets are a token. If you were executing a voucher I'd expect to see one error not two?
undefined says Well, I see these errors after the voucher execution, that's why I think they are related (somehow) to it. I wonder which is the function that does not exist... But most of all - I am confused because receipt.events is null after the transaction ( see the screenshot). I see the ... voucher executed! .... message with the tx.hash printed. And I guess that the voucher execution transaction has been reverted - my guess is that this is the reverted transaction in the error message. Though not sure ...
undefined says It turned out that the voucher execution was unsuccessful due to the problem with the smart contract (the voucher was supposed to mint a nft to this contract). After I changed the contract address, the voucher is executed successfully and there's a non empty events in the recept. The error from the above has nothing to do with the voucher execution. I'll try to upgrade the build in order to remove those errors. Thanks for the support!
undefined says Hi everyone, just want to post a few shared sequencer related documentation from Espresso systems for discussion and consideration:
undefined says About Espresso Sequencer: https://hackmd.io/@EspressoSystems/EspressoSequencer
Espresso Sequencer Documentation:   https://hackmd.io/@EspressoSystems/EspressoSequencer
undefined says Feel free to reach out should you have any question.  @Augusto @felipeargento etc.
undefined says and hello @Carsten | Zippie  üôÇ good see you here
undefined says üëã
undefined says Hello @minw890 ! Thanks for sharing, I'm excited how espresso sequencer is advancing quickly and excited about what it can bring to Cartesi rollups üôÇ
undefined says üôÇ like wise
undefined says :cartesiNew: +‚òï
undefined says Exciting news to have you in here! I have a couple questions: 
Do you know when will your product be available to fully support L2s? 
Is the first public launch of the product going to offer open-source software to be deployed by anyone? Is there any constraint to become part of the consensus?
undefined says Hi Daniel, we're actively working with L2s right now on 1:1 basis, but have testnet planned in the near future to broaden the integration. 
We have traditionally and will continue to open source:)  You can check our open source repo currently (https://github.com/EspressoSystems)
We will have more details on node onboarding in the coming months.
undefined says Hi guys, I'm trying to build a Cartesi dapp that is written in Rust and binding with C++ library using `autocxx` crate, and here are the steps:

1. Cross-compiling our C++ library for risc-v platform
2. Cross-compiling a Rust library binding with (use autocxx crate) the C++ library we generated in previous step
3. Cross-compiling the Rust dapp depends on the lib for risc-v platform

And now I'm blocked in step 2 when trying to do the cross-compiling in the container that derived from `cartesi/toolchain:0.12.0`

- Dockerfile
```
FROM cartesi/toolchain:0.12.0

ENV BUILD_ENV=risc-v
ENV PATH=${PATH}:/opt/riscv/riscv64-cartesi-linux-gnu/bin

RUN apt-get update --allow-insecure-repositories && \
    apt-get install -y --allow-unauthenticated cmake && \
    apt-get install -y --allow-unauthenticated clang
```

- Here is the command I run:
```
CXX=riscv64-cartesi-linux-gnu-g++ cargo build -Z build-std=std,core,alloc,panic_abort,proc_macro --target riscv64g-cartesi-linux-gnu.json --release --lib --package <lib-name>
```

- Error Message:
```
  --- stderr
  ../bignumber.h:4:10: fatal error: 'ostream' file not found
  Error:   √ó the include_cpp! macro couldn't be expanded into Rust bindings to C++:
    ‚îÇ Bindgen was unable to generate the initial .rs bindings for this file.
    ‚îÇ This may indicate a parsing problem with the C++ headers.
```

It seems that it can not find `ostream` which belongs to the C++ standard library which is very strange.
Any suggestion for this error case??
undefined says GM!
I've deployed in sepolia a dapp built from the rollup-examples with custom-dapp script. It all worked fine but when I run the cartesi node validator  with `DAPP_NAME=mydapp docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.override.yml up` I get this kind of errors:

```
daiDaddytest-dispatcher-1 exited with code 1
daiDaddytest-dispatcher-1      | 2023-07-14T11:18:06.964189Z ERROR rollups_dispatcher: Dispatcher stopped: Ok(Err(Tonic error in `get_state` request: status: Unavailable, message: "InnerError { source: FoldableError(Inner error: Error querying for input added events\n\nCaused by:\n    Error querying for input added events) }", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "date": "Fri, 14 Jul 2023 11:18:06 GMT", "content-length": "0"} }
daiDaddytest-dispatcher-1      | 
daiDaddytest-dispatcher-1      | Caused by:
daiDaddytest-dispatcher-1      |     status: Unavailable, message: "InnerError { source: FoldableError(Inner error: Error querying for input added events\n\nCaused by:\n    Error querying for input added events) }", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "date": "Fri, 14 Jul 2023 11:18:06 GMT", "content-length": "0"} }))
daiDaddytest-dispatcher-1      | Error: Tonic error in `get_state` request: status: Unavailable, message: "InnerError { source: FoldableError(Inner error: Error querying for input added events\n\nCaused by:\n    Error querying for input added events) }", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "date": "Fri, 14 Jul 2023 11:18:06 GMT", "content-length": "0"} }
```

I'm quite new to cartesi and don't know how to debug it.

Does this sound like a common issue? Do you know guys what could be going wrong? Also I've tested separately my websocket endpoint with sepolia and it works fine so I think this is not causing it

Thanks in advance
undefined says Cool stuff! We were playing with a Cartesi Rust SDK, though I‚Äôm not sure  we published it. Our mistake.

@pedroargento think we could publish it? I can help.
undefined says @Gabriel Coutinho de Paula Yes! Lets publish it.
undefined says We need to create the repo at cartesi org. I‚Äôve no idea how to setup the CI.
undefined says I've found this issue, I'm on Apple Silicon M1

`! server_manager The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested`

Actually when running it in host mode I had to build my own image: `cartesi/host-server-manager:0.9.1` from https://github.com/cartesi/host-server-manager replace it in https://github.com/cartesi/rollups-examples/blob/main/docker-compose-host.yml#L5  and this fixed my issues for running the node in host mode

Should I do the same to run the node in prod but building this image locally https://github.com/cartesi/server-manager and use it here https://github.com/cartesi/rollups-examples/blob/main/docker-compose.yml#L119 ?
undefined says I've solved the issue by adding the required paths of the std lib provided by cartesi/toolchain:0.12.0 container:
```
 let mut b = autocxx_build::Builder::new("src/lib.rs", [&path2, &path3])
        .extra_clang_args(&[
            "-std=c++14",
            "--target=riscv64-cartesi-linux-gnu-g++",
            "-I/opt/riscv/riscv64-cartesi-linux-gnu/riscv64-cartesi-linux-gnu/include/c++/10.2.0",
            "-I/opt/riscv/riscv64-cartesi-linux-gnu/riscv64-cartesi-linux-gnu/include/c++/10.2.0/riscv64-cartesi-linux-gnu",
            "-I/opt/riscv/riscv64-cartesi-linux-gnu/riscv64-cartesi-linux-gnu/sysroot/usr/include",
        ])
        .build()?;
    b.flag_if_supported("-std=c++14")
        .flag_if_supported("--target=riscv64-cartesi-linux-gnu-g++")
        .compiler("riscv64-cartesi-linux-gnu-g++")
        .compile("autocxx-s2-example");
    println!("cargo:rerun-if-changed=src/lib.rs");
```
undefined says @Prototyping & Support Unit Any suggestions on this issue?
undefined says hi
undefined says Hi! I dont' have a lot of experience developing on the Apple sillicon, but I think that inside the Docker Desktop application you can turn on Rosetta to be able to run the amd64 container images. I reckon this will make things easier for now
undefined says Hi
undefined says Hi guys, following the same context of my previous post, I've built up the C++ libs, Rust ffi library and the Rust dapp executable.

And now I'm trying to build up the Cartesi machine for testing, here is the content of the `entrypoint.sh` file: 
```
set -e
ls -l /mnt/dapp/poker-lib
export LD_LIBRARY_PATH=/mnt/dapp/poker-lib
rollup-init ./poker-cartesi-dapp.bin mono
``` 

However, it seems that the `LD_LIBRARY_PATH`  value is not passed correctly and shows the error message: 
```
./poker-cartesi-dapp.bin: error while loading shared libraries: libpoker.so: cannot open shared object file: No such file or directory
```

I'm sure the required `libpoker.so` file is located at `/mnt/dapp/poker-lib` through the `ls -l /mnt/dapp/poker-lib` command:

```
.....
.....
lrwxrwxrwx    1 dapp     dapp            22 Jan  1  2022 libpoker-eval.so.1 -> libpoker-eval.so.1.0.0
-rwxr-xr-x    1 dapp     dapp        509600 Jan  1  2022 libpoker-eval.so.1.0.0
-rwxr-xr-x    1 dapp     dapp        658704 Jan  1  2022 libpoker.so
drwxr-xr-x    2 dapp     dapp          1024 Jan  1  2022 pkgconfig
```

And clue for the issue?
undefined says And I tried to enter the cartesi-machine using the console image, setup the `LD_LIBRARY_PATH` manually and run the Rust executable again but get the `Illegal instruction` error without any other clues:
```
Running in interactive mode!

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

cartesi-machine:~ # cd /mnt/dapp
cartesi-machine:/mnt/dapp # ls
entrypoint.sh           lost+found              poker-lib
libpoker_ffi.rlib       poker-cartesi-dapp.bin
cartesi-machine:/mnt/dapp # LD_LIBRARY_PATH=/mnt/dapp/poker-lib ./poker-cartesi-
dapp.bin mono
Illegal instruction
cartesi-machine:/mnt/dapp # 
```
undefined says Looks like you are using a shared library that contains unsupported instructions, targeting a different instruction set. You have to double check the version of cartesi machine you are running supports `RV64GC`, the latest one does. Also check that you are compiling the shared library targeting `RV64GC`, be careful to not copy shared libraries compiled in other architectures or that use unsupported RISC-V extensions, such as V extension.
undefined says Thanks for the suggestion!

However, I'm using the `riscv64-cartesi-linux-gnu-g++` compiler provided in `cartesi/toolchain:0.12.0` to compile the shared library and using the same toolchain to build the cartesi-machine.

I expect that the shared library should be compatible with the cartesi-machine since they are generated by the same version of the toolchain.

Here is the command for compiling the shared library:
```
riscv64-cartesi-linux-gnu-g++ -std=c++14 -fPIC -I/poker/build/include/poker-eval -I/poker/build/include  -Wl,-rpath-link=/mnt/dapp/poker-lib -L/poker/build/lib -lgpg-error -lgcrypt -lgmp -lTMCG -lpoker-eval -lbrotlidec -lbrotlienc -lbrotlicommon   -march=rv64g -mabi=lp64d -shared -o libpoker.so common.o poker-lib-c-api.o game-generator.o verifier.o validator.o game-playback.o blob.o player.o messages.o compression.o bignumber.o solver.o participant.o unencrypted_participant.o poker-lib.o referee.o game-state.o codec.o
```

Checking  the target platform for shared library:
```
file libpoker.so
libpoker.so: ELF 64-bit LSB shared object, UCB RISC-V, double-float ABI, version 1 (GNU/Linux), dynamically linked, not stripped
```
undefined says Instead of using that toolchain and performing cross compilation yourself, you should try to build inside a RISC-V machine using the same distribution your app will be running, you can use a Dockerfile for this, possibly with a multi stage Docker build. There are multiple ways to get cross compilation to not work, specially for projects with multiple dependencies like that one (because it is linking many dependencies), you should avoid cross compilation therefore avoid using that toolchain. Nowadays with our new Docker rootfs solution, that toolchain purpose is to only compile our kernel and rom, not dapps.
undefined says 
undefined says "Vouchers and Notices are intended for on-chain validation by making function calls to the CartesiDApp contract... 

We validate and execute Vouchers using the executeVoucher() function. "

What exactly does executeVoucher() do? What does it achieve - in straightforward terms.
undefined says It checks the validity of the voucher, if valid, it executes it. Validity here is reflected by the consensus proof generated before executing the voucher.
undefined says For reference https://github.com/cartesi/rollups/blob/663b2dc1702d1da10f7764682ca86ad7b9b8a286/onchain/rollups/contracts/dapp/CartesiDApp.sol#L103
undefined says What does a Voucher represent in the context of Cartesi? 

It's my understanding that vouchers are normally used to for minting already signed NFTs
undefined says 2nd Qn:

Let's say that you successfully obtained the input data of your CartesiDApp contract from 

event InputAdded(
       address indexed dapp,
       uint256 indexed inboxInputIndex,
       address sender,
       bytes input
   );

After getting that data, you processed it in your Cartesi Machine, how can you post the verifiable result of your computations back to the blockchain?

What function in the Rollups  contracts do you use? - please also describe its inputs 

(PS: just interested in using the smart contract functions  not the HTTP endpoints)
undefined says A voucher represents a function call in a smart contract. For example, a voucher could be a transaction to the DApp smart contract triggering a transfer of an ERC20 to an user.
undefined says The verifiable results are posted through Consensus contracts. The current implementation is the Authority contract where the DApp validator can call the `submitClaim` function.
undefined says We are currently reviewing a new implementation of consensus where a DApp has multiple validators and the majority has to agree on a certain claim for it to be submited to history.
undefined says Thanks.  So, after a claim is submitted, what happens? 

Is there some event emitted to notify other nodes to verify the claim? 

[ As of the current implementation]
undefined says The current implementation is an Authority, so when the claim is submitted its final and considered part of the History. The history contract emits a `NewClaimToHistory` event.

In the current implementation of the multi validators solution, there are no events. Each validator is expected to run the computations and submit the claim independently. So there is no dispute of a claim, but the same claim hash has to be posted by multiple validators before it enter the History.
undefined says Hello all! 

I just created a "Introduction to Cartesi Rollups" twitter thread! Some of you might be interested...let me know if you have any feedback:
https://twitter.com/felipeargento/status/1691906709743075736
undefined says Hellos

If I am to run a Cartesi node on Goerli, do you I also need stake some Goerli ETH?

Corollary: if you're a node runner, must you always stake some ETH?
undefined says 
undefined says Hi guys, I'm trying to deploy a dapp on Linea-Goerli testnet and encountering this error. Can someone help me?
undefined says New error:
undefined says Hey @henriquemarlon! There are certain contracts that has to be deployed as part of rollups on-chain infrastructure. AFAIK these contracts are not deployed on Linea-Goerli testnet, hence the unsupported network error. Any specific requirement for this particular network?  Right now, you could deploy on ethereum-goerli, arbitrum and optimism goerli testnets.
undefined says Only a few tests deploying a dapp on a zkEVM. However, I would really like to know if there is already a ready infrastructure through which I can deploy rollup contracts on networks that have not yet been deployed (EVMs).
undefined says the way today is to fork the cartesi/rollups repository, then go to `onchain/rollups/hardhat.config.ts`, add the intended network configuration, and deploy the rollups smart contracts yourself. Check the `deploy` target in `package.json` and add one for your network.

Then you need to get the generated json file with the contracts addresses and launch a node that uses those contracts.
undefined says Also, here you found the 'fix' I did for Paris Hackathon using the 0.8.2 version: https://gist.github.com/gbarros/b82778c1d1b3ace934a6980cf1dd8ec5

the only step skipped there is exactly what dtuler said, the `cartesi/rollups` modification, cause I had built it myself and published it for the hackers.
undefined says It's roarrrring! On sepolia
undefined says Is the following config tunable for a dapp? 
https://github.com/cartesi/rollups-node/blob/1da90a45bf43e728b7a48e45d4dc1cf49f12f5ac/offchain/advance-runner/src/server_manager/config.rs#L95
If so, how do I change? The problem is that the default 3 minutes timeout for an advance request is too low for the dapp I am experimenting, I wanted to raise to 20 minutes.
undefined says I think its this one:
https://github.com/cartesi/rollups-node/blob/main/offchain/advance-runner/tests/fixtures/mod.rs#L41
undefined says I think this is just a test, I want to change this config locally and for any node that wants to run my dapp. I am working with a dapp where an advance state taking 10 minutes is a normal situation. This hard-coded 3 minutes limit is a problem for such dapp, but I am not sure how to change this config locally or for node runners.
undefined says Hey guys, how is it going? 
I'm trying to update one of my dapps, and i'm having the problem below (CartesiDapp#unrecognized-selector) in doing a transaction from the web-frontend (Integrated with metamask). I've updated the newest version of cartesi rollups (1.0.0) but it seems there is something else to do there. The transaction reaches the backend but it is reverted. Transactions from the front-end console works fine, if anyone faced something similar let me know about it üôÇ
undefined says what transaction are you trying to send to the CartesiDApp contract?
undefined says It is an addInput. The same the front-end console does in the example for sending string inputs locally, as follows in the image. I'm currently reviewing all the code logic because I really think i forgot something in the front-end üòä  .
undefined says Inputs must be sent to the InputBox contract, not the CartesiDApp contract.
undefined says Yeah, i must be doing something wrong still. inputContract is configured to be a inputbox factory but still sending to the wrong contract. Thanks @tuler.eth , i will review this üôÇ
undefined says The address of the InputBox is `0x59b22D57D4f067708AB0c00552767405926dc768`.
It looks you are using the address of the dapp instead.
undefined says Thanks @tuler.eth, in the old version I was using the address of the dapp. Using the inputbox solves my problem locally for now. 
In a deployed version on a testnet, should we use the dapp address right?
Ty
undefined says No, in version 1.0 you send the input to the InputBox.
undefined says Thanks!
undefined says Please ensure the bot has the correct permissions:

‚úÖ     **View Channel**
‚úÖ     **Send Message**
‚ùå     **Embed Links**
‚úÖ     **Manage Webhooks**
undefined says Hey everyone, how's it going?!

I have already tested my dapp in prod and in host mode (it worked), but when I deploy it and run the node, even defining the NETWORK as sepolia (I have already exported it before running the command DAPP_NAME=verifier docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.override.yml up, I also ran it like this: DAPP_NAME=verifier NETWORK=sepolia docker compose -f ./docker-compose-testnet.yml -f ./docker-compose.override.yml up), it doesn't work, it is picking up the address that I need inside my dapp from the localhost addresses:

```
{
    "localhost":{
        "DAPP_RELAY_ADDRESS":"0x8Bbc0e6daB541DF0A9f0bDdA5D41B3B08B081d55",
        "ETHER_PORTAL_ADDRESS":"0xA89A3216F46F66486C9B794C1e28d3c44D59591e",
        "ERC20_PORTAL_ADDRESS":"0x4340ac4FcdFC5eF8d34930C96BBac2Af1301DF40",
        "ERC721_PORTAL_ADDRESS":"0x4CA354590EB934E6094Be762b38dE75d1Dd605a9",
        "LILIUM_COMPANY_ADDRESS":"0x487c16e3228c9d6be29e4bf400cd21be2e993bbd",
        "ERC1155_SINGLE_PORTAL_ADDRESS":"0x",
        "ERC1155_BATCH_PORTAL_ADDRESS":"0x"
    },
    "sepolia":{
        "DAPP_RELAY_ADDRESS":"0x8Bbc0e6daB541DF0A9f0bDdA5D41B3B08B081d55",
        "ETHER_PORTAL_ADDRESS":"0xA89A3216F46F66486C9B794C1e28d3c44D59591e",
        "ERC20_PORTAL_ADDRESS":"0x4340ac4FcdFC5eF8d34930C96BBac2Af1301DF40",
        "ERC721_PORTAL_ADDRESS":"0x4CA354590EB934E6094Be762b38dE75d1Dd605a9",
        "LILIUM_COMPANY_ADDRESS":"0x862260CB4B0c908c04389664eb395a144C7840Bf",
        "ERC1155_SINGLE_PORTAL_ADDRESS":"0x",
        "ERC1155_BATCH_PORTAL_ADDRESS":"0x"
    }
}
```

This Lilium company address from sepolia is the one I want, and it's picking up the localhost address.

Can anyone help me?

GH link: https://github.com/Lilium-DApp/verifier
undefined says The NETWORK env variable you are expecting inside the dapp must be defined when you build the machine (not when you run the node). How are you building the machine?
undefined says running these commands in order:

```
docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl --load

docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl machine --load
```
from what I understand, I have to run:

```
source <my-env-file>
```

before running the build, right?

my env file is like this:

```
DAPP_NAME=verifier
NETWORK=sepolia
CHAIN_ID=11155111
BLOCK_CONFIRMATIONS=10
BLOCK_CONFIRMATIONS_TX=11
MNEMONIC=<user sequence of twelve words>
RPC_URL=https://eth-sepolia.g.alchemy.com/v2/<USER_KEY>
WSS_URL=wss://eth-sepolia.g.alchemy.com/<USER_KEY>
```
undefined says I don't see the NETWORK env variable being injected into the cartesi build system. @Milton what is the documented way of building network specific machines? I can see the ARG here: https://github.com/Lilium-DApp/verifier/blob/dec926749c8783054022ddb03697b3fdd02314e7/build/docker-riscv/Dockerfile#L88
But I don't see anything setting the ARG value.
undefined says Hello there! If using the rollups-examples build systems, the current documented way of building a machine for a specific NETWORK is here:
https://github.com/cartesi/rollups-examples/#building-machine-to-deploy

Basically, you need to set a NETWORK build arg to the desired one when building the machine, like so:
```
docker buildx bake machine --load --set *.args.NETWORK=sepolia
```
Internally, this will passed on to the `build-machine.sh` script within the appropriate build system, and will be used to set the NETWORK env var as part of the machine initialization command line (e.g., https://github.com/cartesi/rollups-examples/blob/main/build/docker-riscv/build-machine.sh#L29)
undefined says I am not using the build from the rollups-examples, I used as a base a repository called echo-voucher: https://github.com/prototyp3-dev/echo-voucher
undefined says As a standard, the NETWORK configuration is localhost:
undefined says 
undefined says I keep trying to change/overwrite it but I can't...
undefined says Have you tried @Milton 's suggestion?
undefined says Yes, the output was this:
undefined says Could that be an issue with `zsh` and its globbing options? Maybe using quotes around `*.args.NETWORK=sepolia` could help?
undefined says I found out what the "problem" was, my shell ( zsh ).

The alternative to this bash command:

```
docker buildx bake machine --load --set *.args.NETWORK=sepolia
```

It's this one in zsh (in my case):

```
docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl machine --load --set "*.args.NETWORK=sepolia"
```
undefined says if you need, we can a chat about the main changes üòÑ
undefined says is there any rollup deployments to arbitrum or optimism?
undefined says like, non-testnet
undefined says now it's under controll, but if anything else happens i surelly call you guys üôÇ
undefined says we deployed the rollups contracts. but I'm not aware of any dapp test yet.
undefined says SPAM ! Don't try
undefined says Hello, 

Let's use the echo-python example as our reference. 

How can I install dependencies when building a Docker image? I tried adding them to requirements.txt, but when trying to build using `docker buildx bake --load` , it says the dependencies are missing. Also tried adding them using RUN command in the Dockerfile but failed 

Hoping you could help out here=]
undefined says Hey, @Eric. can you post your .toml file or docker config?
undefined says Hello @pedroargento I don't have a .toml file. I am simply modifying 2 files in the echo-python example: the Dockerfile and the echo.py file.
undefined says Please ensure the bot has the correct permissions:

‚úÖ     **View Channel**
‚úÖ     **Send Message**
‚ùå     **Embed Links**
‚úÖ     **Manage Webhooks**
undefined says Hello hope ur still there. This is my Dockerfile:
undefined says 
undefined says Its the web3 and eth_account you are trying to install?
undefined says Yes,  exactly.
undefined says @Gabriel Barros @lyno can you guys help here?
undefined says Hello Eric, how are you?
So, the echo-python is not a good example to increment into because it uses the old build. In the old build, to install libraries, you would need to cross-compile them to RISC-V.
It would be best if you started from a project that uses the new build, such as the `calculator` or the `sqlite`.
undefined says I managed to build a project with the libraries you want (web3 and eth_account). So, you can follow the steps below to reproduce.
1) Add the libraries to `the requirements.txt`.
```txt
requests == 2.23.0
web3
eth_account
```

2)  Change the Dockerfile. (I think it is a good approach to separate the build and the actual runtime images)
```Dockerfile
# syntax=docker.io/docker/dockerfile:1.4
FROM --platform=linux/riscv64 cartesi/python:3.10-slim-jammy as build-stage

RUN apt-get update \
    && apt-get install -y --no-install-recommends build-essential=12.9ubuntu3 \
    && apt install -y --no-install-recommends curl \
    && rm -rf /var/apt/lists/*

# install rust compiler
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
# Add .cargo/bin to PATH
ENV PATH="/root/.cargo/bin:${PATH}"

RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

COPY ./requirements.txt .
RUN pip install -r requirements.txt --no-cache \
    && find /usr/local/lib -type d -name __pycache__ -exec rm -r {} +

# runtime stage: produces final image that will be executed
FROM --platform=linux/riscv64 cartesi/python:3.10-slim-jammy

COPY --from=build-stage /opt/venv /opt/venv

WORKDIR /opt/cartesi/dapp
COPY ./entrypoint.sh .
COPY ./your_dapp.py .
```
3) Change the `entrypoint.sh` (You you need to add the venv copied to the PATH).
```shell
set -e
export PATH="/opt/venv/bin:$PATH"
rollup-init python3 your_dapp.py
```
undefined says One of the libraries you tried to install needed a Rust compiler, so I had to install it in the Dockerfile. And to install it, I had to install `curl` too.
undefined says To make `echo-python` use the new build, change the build it references. Projects using the new build reference the `build/docker-riscv/base.hcl`
```shell
ln -s ../build/docker-riscv/base.hcl docker-bake.hcl
```
undefined says Hello, is  cartesi OpenCV library  available on github? or any other thing.
undefined says Hey Larry! There are a few examples of it such as https://discord.com/channels/600597137524391947/1148646893023404142
undefined says However, these use the cross-compilation format that might be a bit challenging. By using the emulated environment of qemu, you can just "apt install" OpenCV at the machine.

Here is one template/example of this being used:
https://github.com/cartesi/rollups-examples/tree/main/calculator
undefined says For anyone who chooses this approach and has any doubts about any specific point, feel free to contact me üôÇ
undefined
undefined says üëã Hey all Cartesi Compute users!

Here's where you can ask any and all questions about Cartesi Compute, the Compute team and the community is more than happy to help!

Also see #compute and #deleted-channel for seeing more detail on Cartesi Compute's development
undefined says @Shaheen and ü§ñ  maybe for icon?
undefined says or something more creative that symbolizes computation
undefined says I was thinking about this! Toughest task! How about üßÆ ?
undefined says Whatever you relate compute with let me know!
undefined says üß±  maybe since we're a building block
undefined says (also, i'm danish, so, that's obviously a LEGO üòÇ )
undefined says :bricks : ?
undefined says I've to pick from macOS emojis
undefined says ah fun
undefined says It looks different to me! What do you see?
undefined says 
undefined says (on macos)
undefined says ah same! This is the only block here!
undefined says üì¶ maybe ?
undefined says iT WORKS!
undefined says hardest thing in computing: naming things and picking right discord emojis
undefined says Let's keep it for now! Later if we have anything better, we edit!
undefined says You can repost the intro again here if you want! Make the channel focused again!
undefined says Pinned a message.
undefined says How can one maintain the machine? Is it possible to update the system while its deployed (e.g. via an upgrade command)
undefined says so in general you can replace a flash drive in a state snapshot, but you also need to think of it in terms of how a linux kernel reacts to a disk drive being replaced without proper mounting/unmounting
undefined says huiuiui, well alright for now but sounds pretty complex
undefined says Thanks for the updates on the Compute R&D channel @Carsten | Zippie! I'm quite curious (and excited) about these two experimental plans:

> - To prototype a EigenLayer AVS that is slashable based on a Compute result
> - Get a Cartesi Machine memory image backed RiscZero ZK proof of a Cartesi Machine working with a few (big machine) cycles

Can you shed more light on EigenLayer AVS? Do you see this as the best option to spin up & bootstrap compute validators (given restaking/ability to tap into eth validators & stake)? Do you think this could also be beneficial for Cartesi Rollups?
undefined says Right now it's mostly skill-up so we understand where the walls are there. I think AVS'es will help in:
- Sequencing
- Short term provable message busses (like, for arbitration verification games happening off-chain in a high security manner)
- Data availability
- Possible staking models around compute validators
- Better ways to bridge and do L2<->L2 stuff
- Better sync committes than Ethereum L1 itself provides since they're actually slashable
undefined says it's one of those a bit where i think there's potential and a lot of blind spots to where it can help verified computation
undefined says will share all learnings here on discord and/or blogs, naturally, as things progress - think in 2024 ethereum-based systems likely are completely unrecognisable from what we see today so, because of tech like these
undefined says Thanks for the insights and yea will definitely keep an eye out for your writings haha! This seems super promising and I can definitely imagine that it might shake up and change up some of the systems we have today
undefined says i'm just looking forward to have to spend less time with the EVM üòÇ
undefined says ah, also, DKG's at mass scale
undefined says Can you elaborate on this one?
undefined says basically a bit like how dfinity does it, it has a single ICP public key, because there was a distributed key generation process across all nodes so each have a shard of the 'private key' but nobody ever has the whole private key; so you can ask a certain threshold of the nodes to sign for you and it adds up as if the "private key" signed it
undefined says it's useful for a lot of things such as conditional decryption and so forth
undefined says https://litprotocol.com/ is probably what comes close atm
undefined says Very interesting!
undefined says Regarding the RiscZero implementation. Is it sort of similar to the Layer N implementation, but this time putting the Cartesi Machine onto the RiscZero zkVM? https://twitter.com/RiscZero/status/1660712143032041472
undefined says to be honest i'm not exactly sure what Layer N is actually doing üôÇ I want to be the first to boot up a Linux system in ZK, roughly around end of July latest. It'll be a lot of proofs, a lot of processing, but it'll be a nice accomplishment. Doing a single step big machine or uarch is probably a nice sideeffect too
undefined says are the state changes recorded somewhere? So that they are traceable like with any DLT + Explorer?
undefined says you've had a chance to read through https://docs.cartesi.io/cartesi-machine/ yet? - also, the original cartesi whitepaper is quite good
undefined says I read some parts more indepth but mostly skipped through it. Will dig deeper when you say the info is hidden in there üëç
undefined says it's somewhere in between that and realizations while sitting with a glass of red wine and playing with the machine and it's command line options itself üôÇ
undefined says https://www.youtube.com/watch?v=kGkd48vo6UI is a old video but i've used that to explain a bit when i originally was training them
undefined says Based on your replies I get the feeling that I might have a different picture of Cartesi Compute than what it actually is üòÖ So I will happily watch the video again
undefined says in general you can do a lot with compute that's not immediately obvious from the docs, but start making sense if you understand how you can actually modify a state hash and so on and control the process more with a smart contract
undefined says do i understand a bit that you are kind of looking for some kind of continous VM tho? like, same nodes iterating on same virtual machine\
undefined says a bit like start up at point zero, take in some input, agree on machine state, take in more input, agree on new machine state, etc?
undefined says YES!! exactly that one
undefined says Thats the idea and I think this might only be feasible with rollup then right (neglecting the privacy requirement for now)
undefined says The concept I have in mind was designed for EVM, so I make a lot of assumptions about the similarity of it and Cartesi (continuous VM, transactions, blockchain)
undefined says Basically I thought Cartesi provides a L2 Network (wrong already) that has an Ubuntu State more or less which is also transitioned by transactions that inbound via L2 directly. Only the state hash is then anchored to L1.
undefined says I wasn't able to find too many details either, but I thought it was EVM based. But yeah putting Linux in there would be something else entirely haha. I was comparing more in terms of potential use cases/benefits of combining optimistic and zk rollups
undefined says One thing I never really tested is how it‚Äôs exactly handled in compute when something does a yield - if it‚Äôs seen as end of execution (that you then can continue on in a second run based on the resulting machine hash)
undefined says Yield is a bit like stopping the machine but it‚Äôs continuable, for example, for replacing a flash drive in between
undefined says I don't know exactly what you are trying to achieve, but it is right to assume that Cartesi Rollups (unlike Cartesi Compute) is a continuous/stateful VM. Transactions go to L1 or a sequencer in L2 (if you use Cartesi as L3) and the VM updates its state accordingly.
undefined says Then from time to time the validator nodes make a claim on-chain with a hash that represents the VM state.
undefined says The manual yield creates a fixed point in the machine, a trap, from which the machine cannot escape unless it is released from the outside.
undefined says From the point of view or arbitration in compute, it is just as if the machine was halted.
undefined says You can, however, take that machine, "unhalt it" and give it whatever input it needs to continue running, and start a new compute stage.
undefined says This is the basis for "rollups".
undefined says These transitions from a fixed state to a runnable state are doable with a few surgeries using hashes, or directly on the machine using a few entrypoints.
undefined says You could treat a manually yielded machine (iflags_Y set) just like you treat a halted machine (iflags_H set) for the purpose of compute, I think. Or you could consider it an error and bail.
undefined says Also, in regard to your privacy requirement, the discussion you had previously with Carsten about permissioned nodes applies to rollups as well.
undefined says Thanks a lot @erickdemoura! Is there no option to submit the transactions directly to the nodes? Because if they go via L1 then the privacy is not given
undefined says @diego.nehab mostly out of idle curiousity, why the separate rollup/voucher/etc buffers and not go through flash drives? kernel / caching gotchas?
undefined says They are just memory ranges that the kernel can access.
undefined says Flash drives load a driver for mtd (we will replace it with another driver later on) and get exposed as an mtd device and an associated block device.
undefined says We didn't want processes to access these memory ranges in random ways.
undefined says So we created an API for rollups and only the rollup driver can access these memory ranges.
undefined says Felt cleaner this way.
undefined says I see. If data availability is given by the blockchain (or L2), then you could consider sending encrypted input. 
In your case, you may not need hard DA assumptions. Perhaps you could use IPFS and only store the hashes on-chain. Or some customization of the rollups nodes to receive and retain data themselves.
undefined says Then it's really up to the security and availability guarantees you want to work with.
undefined says Edit: nvm that first part i sent 

But in general I feel now more confident that Cartesi could be the right tool by applying certain modifications or workarounds.
undefined says A core assumption from my side was that the Cartesi rollup nodes constitute a full fledged network themselves, so that DA is given
undefined says No. Rollups nodes don‚Äôt communicate with each other (through p2p or whatever). Only ‚Äúthrough‚Äù base layer, which currently works as DA and consensus.
undefined says and we just posted a new development increment update (increment 2) in ‚Å†https://discord.com/channels/600597137524391947/1108842830912307220 if anyone is interested üôÇ
undefined says https://docs.cartesi.io/compute/overview/ now has Compute 1.3.0 docs ü•Ç
undefined says @Shaheen 
Has Cartesi considered a partnership with CUDOS to leverage their tech for 3d rendering and motion graphics for dApps ? Seems like some good synergies. Interested in thoughts? Thanks

https://www.cudocompute.com/solutions/rendering/
undefined says On a similar note , IDEX - who plans to build a COMPLETELY decentralised DEX ( which is as good as a  CEX )
undefined says From what I gather, they want to decentralize rendering graphics by leveraging idle gpu resources. I don't think they are trying to associate it with deterministic machines. It should be a developers' choice imo on which rendering service they would opt.
undefined says Hey @Carsten | Zippie 

Jessy from EigenLayer reached out and wanted to get in touch to chat about the design around building an economic layer on top of Cartesi Compute. Who can I best connect him with?
He sadly doesn't have a Discord so he's unable to join in here.
undefined says Yup Erick got same message, we are on it üôÇ
undefined
undefined says like it üôÇ
undefined says Anyone has already done front end app in the Vue or am I first :D?
undefined says I think that this might be Vue or smth similar eg. angular, react or vanilla js üòâ
undefined says basically, any web frontend example will be helpful for us üòÑ
undefined says Hi @wch-dawid-m | webchefs and @wch-karol-p | webchefs  
We'll probably release a well polished web frontend version in a future release.
Anyway, I've prepared a simple, quick and dirty version.
Let me know if this helps.
undefined says It worked with my rust backend. A step forward for me, we will work on that üôÇ
undefined says Referring to: https://github.com/cartesi/rollups-examples/tree/main/echo-js
Where Can I find info that txiki was implemented to machine?
undefined says txiki was added to the base rootfs image, no need to install it, just use an updated rootfs
undefined says it was added on this commit
undefined says https://github.com/cartesi/image-rootfs/commit/e13038f852d5421abacd5f06923cc330c15b14ab
undefined says Hey @Cartesi Developer! Check out the Sports betting DApp by @tuler.eth . It has backend and frontend built in TypeScript! Deployed on Goerli! 
https://discord.com/channels/600597137524391947/1001138047313789071/1052190414343507988
undefined says wen svelte SSR
undefined says lol
undefined says xd
undefined says Wen Node.js? It's time!

Hey @Cartesi Developer! Update you would like to hear!

Now you can write your back-ends using Node.js! üòç
The Cartesi Rollups Echo JS Example DApp has been updated to show you how it's done!
Explore it here: https://github.com/cartesi/rollups-examples/tree/main/echo-js
undefined says Hi guys, I‚Äôm trying to run the echo-js example and the `docker buildx bake --load` command gives me an error:
```
#0 0.554 exec /bin/sh: exec format error
------
Dockerfile:24
--------------------
  22 |     
  23 |     # add the required 'dapp' user
  24 | >>> RUN useradd --create-home --user-group --uid 2874 dapp
  25 |     RUN chown -R 2874:2874 /opt/cartesi/dapp
  26 |     
--------------------
ERROR: failed to solve: process "/bin/sh -c useradd --create-home --user-group --uid 2874 dapp" did not complete successfully: exit code: 1
```
undefined says same
undefined says Trying to reproduce, it's building fine for me. On rollups-examples 0.14.0 Docker Desktop on MacOS. @Prototyping & Support Unit Any insights here?
undefined says It's building and running fine for me too. Fabio, check if you are missing one of the requirements (qemu), to do it run the command ``docker buildx ls``  and you should see something like the screen that I sent. Notice that the ``linux/riscv64`` appears in the platform list, if it not appear to you refer to this part of the docs to solve the issue https://github.com/cartesi/rollups-examples/#docker-riscv-using-risc-v-base-docker-images.
undefined says Ok, I got it. qemu isnt available on Gitpod...
undefined says There is this Ansible automation created by @Felipe Grael that sets a VPS with everything to get started on Cartesi and an in browser IDE as well. If you use the stackscript in Linode, you get started in a couple of clicks. 
https://github.com/prototyp3-dev/code-server-dev-env
undefined says Linode stackscript: https://cloud.linode.com/linodes/create?type=StackScripts&subtype=Account&stackScriptID=1168216
undefined says Thanks @Carlo, we decided to write the middleware with Rust/Actix, and the example with Nodejs
undefined says bun.sh 1.0 is out. This is in interesting news. They don‚Äôt provide RISC-V builds, but it may be interesting if some hacker tries to build it.
undefined says has anyone tried using bun.sh instead of nodejs for Sunodo + dapp Frontend ? Should it work as a replacement for node/npm?
undefined says It should work, but didn't on first try. I'll try more when I find the time.
undefined says If you were going to a Hackathon where you have a few hours to create a beautiful frontend for a web3 dapp. Which agile web frontend framework (or tools) would you use? Just researching opinions.
undefined says https://wagmi.sh/cli/create-wagmi#nextjs
next-rainbowkit
undefined says Interesting, will take a look and maybe try, thanks
undefined says I was thinking in Vue at first, because I had experience with Vue years ago and was "ok", but I might be a not a great option today, not sure
undefined says I think React derivated frameworks has dominated since then
undefined says Vue itself is good (even though I don't speak from personal experience). The killer IMO is wagmi. And there is not an official vue-wagmi package, but people can build vue apps on top of @wagmi/core
undefined says But @wagmi/react is pretty awesome.
undefined says Let me rephrase, if you are into Vue, use @wagmi/core. I don't have personal experience with that yet. 
@Bruno Menezes is a fan of svelte, but you would have to use @wagmi/core as well.
Personally I choose React only because it's the one I have more experience.
undefined says I found this Vue + wagmi/core tutorial on WalletConnect website, giving it a try
https://docs.walletconnect.com/2.0/web3modal/v3/vue/about
But it is in Alpha
undefined says I gave both Next.js and Vue a try. I could achieve more in less time in the frontend with Vue, what I felt:
- Next.js/React I had to learn how to use their own HTML components like `Link` instead of `a`, and I do not feel coding HTML code,  I had to re-learn some basic HTML components again, this slowed me, while in Vue I can still use raw HTML5 code
- Next.js is meant to also have server side code, I had to use `typeof window !== "undefined"` is places to trigger client side code only, this felt hacky, my frontend is single page only, while Vue is meant for single page apps only, no server side stuff
- Next.js I must use TypeScript, there were places I need to use external JS libraries with untyped code, I spent valuable hours trying to please the type checker, eventually I gave up and I had to end up using `// @ts-ignore:next-line` everywhere, whereas in Vue without typescript I could go faster

Overall I feel that TypeScript is valuable for large complex dapps when working with large teams, due type checking and safety. But for quickly hacking a prototype seems like to slow me down, might work better for people with experience on it. TypeScript+React+Next.js feels like you need to relearn both HTML and JS, while Vue+JS feels like bare old HTML5 and JS, requiring less to learn and faster to prototype. I only did web dev in a time before TS existed, so this is my biased opinion.
undefined says In both cases I could use `@wagmi`, and it was nice for wallet stuff
undefined says - you can use plain html with next.js. `Link` does other goodies like pre-fetching.
- just add `"use client;"` in the top of the file and the component will render on the client. By default it renders on the server for performance reasons
- I rarely find libraries without typescript support. Which one you had problems with?
undefined says > I rarely find libraries without typescript support. Which one you had problems with?
the JS APIs I made on top of Emscripten WASM APIs üòÜ , I was doing stuff like JS <-> WASM calls, such as:
```js
        // @ts-ignore:next-line
        let buf = Module._malloc(cartridge_data.length);
        // @ts-ignore:next-line
        Module.HEAPU8.set(cartridge_data, buf);
        // @ts-ignore:next-line
        Module.ccall('rivemu_start', null, [ 'number', 'number' ], [ buf, cartridge_data.length ]);
        // @ts-ignore:next-line
        Module._free(buf);
```
`ts-ignore:next-line` everywhere üôÇ
undefined says Ahh, so you are blaming yourself. got it üòÜ
undefined says "external" JS libraries
undefined says I wish we had a start template dapp example using Cartesi + Sunodo, where you can deposit/withdraw an ERC-20 token from L1<->L2, also execute vouchers, with a minimal frontend and test suite.  The frontend using some framework stack like (vite + wagmi + wagmi-cli + react + bootstrap v5 + rainbowkit) and a reference backend using any language (not that important, the developer could swap the backend to his language of choice), this would save me a lot of time and effort
undefined says I spent the weekend trying to figure out the frontend side of a dapp, I spent a lot of time figuring out these details, and found myself navigating source code of other cartesi dapps of hackathons, like the Ballum dapp, DCA.Monster dapp, and others. I learned some interesting ways to do stuff from them
undefined says I agree that writing a good web3 frontend is quite a task. And most of the job is not related to Cartesi at all. Wallets interaction and GraphQL interaction are the bulk of it, and tools like wagmi (1) and graphql-codegen (2) help a lot. There is a lot of asynchronicity, even more with Cartesi, where inputs are transactions that can take a long time, and then there is machine execution that adds to that. It's hard IMO to provide a good template because I feel the frontend depends a lot on the application.

1. https://wagmi.sh
2. https://the-guild.dev/graphql/codegen
undefined says I used both wagmi and graphql-codegen, they were handy, I wish a had more time to elaborate a starter template for myself with everything related to Cartesi/GraphQL/wagmi/Wallet sorted out. Any frontend starter template would be very opinionated, but handy for hackathons, because people could start from this wallet dapp template from minute 0 already integrated with Cartesi, and just add the dapp logic with a few new advance states and UI components.
undefined
undefined says üëã ü¶Ä***Hello, Rustaceans!***

This channel is for all your needs. Ask questions from setting up, building or deploying Rust DApps.

**Run a simple Rust DApp**
Check our echo-rust example: https://github.com/cartesi/rollups-examples/tree/main/echo-rust

*Not sure where to begin you Cartesi Dev Journey? *
Head over to #üê£‚îÉbeginner-friendly channel to take your first step.
undefined says Hello, I have a problem with building rust dapp in production mode. The error is: "cannot find -lsqlite3" while I'm trying to add diesel crate (I want to use SQLite in the project). Is any help?
undefined says 
undefined says Can you share the steps to reproduce this? Seems like it's missing the libsqlite3-dev inside the toolchain containter
undefined says https://github.com/cartesi/rollups-examples/blob/main/docker/Dockerfile#L3
undefined says I'm using this command to build an app.
```docker buildx bake -f docker-bake.hcl -f docker-bake.override.hcl --load --no-cache```
and adding this in the lib.rs file breaks build
```#[macro_use]
extern crate diesel;```

git:
https://github.com/wchfs/trip-poc-dapp/blob/ebe1abd5d678ce13ba92a46c358c98b142d7ebbe/backend/Cargo.toml#L19
https://github.com/wchfs/trip-poc-dapp/blob/ebe1abd5d678ce13ba92a46c358c98b142d7ebbe/backend/src/lib.rs#L2
https://github.com/wchfs/trip-poc-dapp/blob/ebe1abd5d678ce13ba92a46c358c98b142d7ebbe/backend/Dockerfile#L6
undefined says I suspected that but I'm not sure how to fix that issue.
undefined says if you insert bellow line 3 (https://github.com/cartesi/rollups-examples/blob/main/docker/Dockerfile#L3):
``` RUN \
    apt-get update && \
    apt-get install --no-install-recommends -y \
    libsqlite3-dev
```
it should solve your issue
undefined says can you give it a try and let me know how it goes @wch-dawid-m | webchefs ?
undefined says Ok, on my way to test üôÇ
undefined says great
undefined says still the same:
undefined says If it is missing in the toolchain container should I rebuild that image and install the library there? I had to rebuild the toolchain image because of my M1 computer, is it correlated?
undefined says Let me ask around here and get back to you, seems to me it's missing the riscv version of the libsqlite3.so in order to build
undefined says Hi, I'm wondering if you have examples of the flow for paying procedure (maybe in rust?). I figure out something like this but confirmation will be useful.
undefined says Hey, @wch-dawid-m | webchefs!
Yes, in the first flow chart, to query the state and check some information, you can use inspects.

Regarding the other flow charts, they contain some unnecessary steps. To pay, Users can directly deposit assets without having to ask for a specific output. To deposit assets, instead of sending inputs to the InputFacet, the users interact with another Facet, either the EtherPortalFacet, ERC20PortalFacet, or ERC721PortalFacet. Using the deposit function of one of these facets, the user transfers the assets to the portal and includes any data. Then, the Rollups Framework sends a special advance state to the backend containing the deposit information.

Vouchers, on the other hand, are outputs from the backend that define a contract call. So they are a way for the DApp to interact with the blockchain. For example, they allow users to withdraw assets from the portal. So, they aren't used to transfer assets to the DApp.
Let me know if you have any more doubts!
undefined says Hi guys! I got a error like this issue:
https://github.com/briansmith/ring/issues/1488
undefined says #0 41.90 error: failed to run custom build command for `ring v0.16.20`
#0 41.90 
#0 41.90 Caused by:
#0 41.90   process didn't exit successfully: `/opt/cartesi/dapp/target/release/build/ring-0c5e4cd48b59c0c3/build-script-build` (exit status: 101)
#0 41.90   --- stderr
#0 41.90   thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', /opt/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/build.rs:358:10
#0 41.90   note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#0 41.90 warning: build failed, waiting for other jobs to finish...
------
error: failed to solve: executor failed running [/bin/sh -c cargo build -Z build-std=std,core,alloc,panic_abort,proc_macro --target riscv64ima-cartesi-linux-gnu.json --release]: exit code: 101
undefined says Hi, you are trying to use unwrap() method on the None and this method is not implemented within this type.
undefined says If I understand correctly this is the issue inside the library that you are trying to use so it might be hard to fix. I think I can test if I can build my project with this version of Ring.
undefined says I can confirm that I have the same issue and it looks like there are needed environment variables
undefined says Hi guys! Is it possible to run the echo-rust on mac m1?
undefined says A few weeks ago I was able to run echo-rust on M1 but there was an issue with the docker image. If you have any error messages, please share, and maybe I will be able to help with your issue (I have instructions from Carlo).
undefined says docker --version
Docker version 20.10.17, build 100c701
undefined says ```
------
 > [console 4/4] RUN cargo build -Z build-std=std,core,alloc,panic_abort,proc_macro --target riscv64ima-cartesi-linux-gnu.json --release:
#0 2.906     Updating crates.io index
#0 136.2 Killed
------
ERROR: failed to solve: executor failed running [/bin/sh -c cargo build -Z build-std=std,core,alloc,panic_abort,proc_macro --target riscv64ima-cartesi-linux-gnu.json --release]: exit code: 137
```
Ok, so after investigation I found out that the toolchain version changed from 0.10.0 to 0.11.0 and I also have an issue with building that echo-rust example. But when I change to the last toolchain image which is built for M1 everything works fine as it should.
undefined says This is the instruction that helped me:
```
$ git clone https://github.com/cartesi/image-toolchain.git
$ cd image-toolchain
$ git checkout v0.10.0
$ make build TOOLCHAIN_TAG=0.10.0
```
I think that if you try to build the 0.11.0 version everything should work again. I will try to build that version in the future (I'm currently working on something else)
undefined says @fabio.oshiro @wch-dawid-m | webchefs we have issues building the M1 toolchain images in the CI/CD as those need to use an emulator and are getting a timeout. If you build them locally, should have no issues.
undefined says Success! After a while, like 31 min...
Tomorrow I will try the 0.11.0 version!
undefined says Hi guys it works with 0.11.0
undefined says @fabio.oshiro Did you ever figure out how to compile ring? I forked ring 0.6.20 and backported two patches that allow it be to compiled for RISC-V
undefined says You can use my fork by adding these arguments to your `cargo build` command:

-Z unstable-options
--config "patch.crates-io.ring.git='https://github.com/juztamau5/ring'"
--config "patch.crates-io.ring.rev='534f2cebbeeb3457bda2d62f98b37592ad56e269'"
undefined says You also need
```
export TARGET_CC=riscv64-cartesi-linux-gnu-gcc
export CRATE_CC_NO_DEFAULTS=1
```
undefined says My full command to build rust-ipfs is:

```
# Note: A patched version of ring is required to support RISC-V
# See https://github.com/briansmith/ring/pull/1506
export RING_REPO=https://github.com/juztamau5/ring
export RING_VERSION=534f2cebbeeb3457bda2d62f98b37592ad56e269
export TARGET_CC=riscv64-cartesi-linux-gnu-gcc
export CRATE_CC_NO_DEFAULTS=1
cargo build \
  -Z build-std=std,core,alloc,panic_abort,proc_macro \
  --target riscv64ima-cartesi-linux-gnu.json \
  --release \
  -Z unstable-options \
  --config "patch.crates-io.ring.git='${RING_REPO}'" \
  --config "patch.crates-io.ring.rev='${RING_VERSION}'"
```
undefined says @eigendude  thank you so much! In the end I solved it without needing the `ring`
undefined says Nice. I commented on the long running RISC-V PR, maybe a maintainer will care
undefined says Hey @wch-dawid-m | webchefs 
We managed to reproduce and test different approaches to add sqlite to rust.
We recommend changing rusqlite default config to have libsqlite3 built locally (using CC).
This way, diesel, which uses rusqlite underneath should be able to find libsqlite3 in the file system and access SQLite DBs normally.

Attached a patch which adapts the echo-rust example to use SQLite
undefined says I appreciate your help! Production mode is now working fine just fine but I encountered another problem, I made a follow-up here (but sadly it seems like it's hardware related):
https://discord.com/channels/600597137524391947/1001118234327666728/1044283071354130543
undefined says Hey @wch-dawid-m | webchefs, regarding the voucher issue
I'm continuing the conversation here because the problem that you encountered is specific to the rust implementation.
Basically there was 2 issues. The first was about the amount of the voucher. which it should convert to uint256 from decimal string. Also, the value  was missing some zeros (9).
The second was about the encoding of the voucher. Basically it was converting the byte array to string, then encoding to hex. but it should encode directly to hex.
I've included a patch that should help you.
undefined says how do I know whether a cargo package is supported by the cartesi machine or not?
undefined says Having problems with tensorflow, and also can't get to use onnx runtime for risc-v to work at all
undefined says looking for alternatives and I think I might be able to do it with rust
undefined says @marcelofeitoza take a look at this message: https://discord.com/channels/600597137524391947/813381014104571904/1108351152409559062
Hope it helps you!
undefined says [Resolved] Hi everyone, I'm attempting to compile my application, and I encountered the following error:
```error: package `socket2 v0.5.3` cannot be built because it requires rustc 1.63 or newer, while the currently active rustc version is 1.62.0-nightly
```
undefined says I also attempted to use the 0.15.0 toolchain without success...